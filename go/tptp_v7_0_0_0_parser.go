// Code generated from tptp_v7_0_0_0.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // tptp_v7_0_0_0

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 101, 1640,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 3, 2, 7, 2, 406, 10, 2, 12, 2, 14, 2, 409, 11,
	2, 3, 2, 3, 2, 3, 3, 3, 3, 5, 3, 415, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 3, 4, 5, 4, 424, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 433, 10, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 3, 7, 3, 7, 5, 7, 446, 10, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 5, 8, 457, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 5, 9, 468, 10, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 5, 10, 479, 10, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 490, 10, 11, 3, 11, 3, 11, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 501, 10, 12, 3, 12, 3,
	12, 3, 13, 3, 13, 3, 13, 5, 13, 508, 10, 13, 3, 14, 3, 14, 3, 15, 3, 15,
	5, 15, 514, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 520, 10, 16, 3,
	17, 3, 17, 3, 17, 5, 17, 525, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 19,
	3, 19, 3, 19, 5, 19, 534, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 7, 20, 544, 10, 20, 12, 20, 14, 20, 547, 11, 20, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 7, 21, 557, 10, 21, 12,
	21, 14, 21, 560, 11, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 7, 22, 570, 10, 22, 12, 22, 14, 22, 573, 11, 22, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 585, 10, 23,
	3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3,
	26, 3, 26, 7, 26, 599, 10, 26, 12, 26, 14, 26, 602, 11, 26, 3, 27, 3, 27,
	5, 27, 606, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 621, 10, 30, 3, 31, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 3, 31, 5, 31, 639, 10, 31, 3, 32, 3, 32, 3, 32, 5, 32,
	644, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36,
	3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 671, 10, 37, 3, 38, 3,
	38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 5, 39, 680, 10, 39, 3, 40, 3, 40,
	3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 5, 42, 689, 10, 42, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 699, 10, 43, 3, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 709, 10, 44, 12, 44, 14,
	44, 712, 11, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	7, 45, 722, 10, 45, 12, 45, 14, 45, 725, 11, 45, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 735, 10, 46, 3, 47, 3, 47, 3, 47,
	3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 747, 10, 47, 3,
	48, 3, 48, 3, 48, 7, 48, 752, 10, 48, 12, 48, 14, 48, 755, 11, 48, 3, 49,
	3, 49, 5, 49, 759, 10, 49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 5, 51, 766,
	10, 51, 3, 52, 3, 52, 3, 52, 5, 52, 771, 10, 52, 3, 53, 3, 53, 5, 53, 775,
	10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 5, 55, 783, 10, 55, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 7, 56, 793, 10, 56,
	12, 56, 14, 56, 796, 11, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 57, 3, 57, 7, 57, 806, 10, 57, 12, 57, 14, 57, 809, 11, 57, 3, 58, 3,
	58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 820, 10, 58,
	3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 7,
	60, 832, 10, 60, 12, 60, 14, 60, 835, 11, 60, 3, 61, 3, 61, 5, 61, 839,
	10, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63,
	849, 10, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3,
	65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66,
	3, 66, 3, 66, 3, 66, 5, 66, 873, 10, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3,
	67, 5, 67, 880, 10, 67, 3, 68, 3, 68, 3, 68, 7, 68, 885, 10, 68, 12, 68,
	14, 68, 888, 11, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3,
	69, 5, 69, 898, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 5, 70, 908, 10, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 915,
	10, 71, 3, 72, 3, 72, 3, 72, 7, 72, 920, 10, 72, 12, 72, 14, 72, 923, 11,
	72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 933,
	10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74,
	943, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 5,
	75, 953, 10, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 960, 10, 76,
	3, 77, 3, 77, 3, 77, 7, 77, 965, 10, 77, 12, 77, 14, 77, 968, 11, 77, 3,
	78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 978, 10, 78,
	3, 79, 3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3,
	80, 5, 80, 991, 10, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 1005, 10, 82, 3, 83, 3, 83, 3,
	83, 3, 83, 3, 83, 5, 83, 1012, 10, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84,
	3, 84, 3, 84, 3, 84, 5, 84, 1022, 10, 84, 3, 85, 3, 85, 3, 85, 7, 85, 1027,
	10, 85, 12, 85, 14, 85, 1030, 11, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 7, 87, 1044, 10, 87, 12,
	87, 14, 87, 1047, 11, 87, 3, 88, 3, 88, 5, 88, 1051, 10, 88, 3, 89, 3,
	89, 5, 89, 1055, 10, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	3, 91, 3, 91, 5, 91, 1066, 10, 91, 3, 92, 3, 92, 5, 92, 1070, 10, 92, 3,
	93, 3, 93, 5, 93, 1074, 10, 93, 3, 94, 3, 94, 3, 94, 3, 94, 3, 95, 3, 95,
	5, 95, 1082, 10, 95, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3,
	96, 7, 96, 1092, 10, 96, 12, 96, 14, 96, 1095, 11, 96, 3, 97, 3, 97, 3,
	97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 7, 97, 1105, 10, 97, 12, 97, 14,
	97, 1108, 11, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 5, 98,
	1117, 10, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 100,
	3, 100, 3, 100, 7, 100, 1129, 10, 100, 12, 100, 14, 100, 1132, 11, 100,
	3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1138, 10, 101, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 5, 103, 1147, 10, 103, 3, 104,
	3, 104, 3, 105, 3, 105, 5, 105, 1153, 10, 105, 3, 106, 3, 106, 3, 107,
	3, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 109, 3, 109,
	3, 109, 3, 109, 5, 109, 1169, 10, 109, 3, 110, 3, 110, 5, 110, 1173, 10,
	110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 5,
	112, 1183, 10, 112, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 5,
	113, 1191, 10, 113, 3, 114, 3, 114, 3, 114, 7, 114, 1196, 10, 114, 12,
	114, 14, 114, 1199, 11, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 5,
	115, 1206, 10, 115, 3, 116, 3, 116, 3, 116, 5, 116, 1211, 10, 116, 3, 117,
	3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 5, 118, 1233, 10, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119,
	5, 119, 1240, 10, 119, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120,
	3, 120, 3, 120, 5, 120, 1250, 10, 120, 3, 121, 3, 121, 3, 121, 3, 121,
	3, 121, 5, 121, 1257, 10, 121, 3, 122, 3, 122, 3, 122, 7, 122, 1262, 10,
	122, 12, 122, 14, 122, 1265, 11, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3,
	123, 5, 123, 1272, 10, 123, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3,
	124, 7, 124, 1280, 10, 124, 12, 124, 14, 124, 1283, 11, 124, 3, 125, 3,
	125, 3, 125, 3, 125, 5, 125, 1289, 10, 125, 3, 126, 3, 126, 3, 126, 5,
	126, 1294, 10, 126, 3, 127, 3, 127, 3, 128, 3, 128, 3, 129, 3, 129, 3,
	129, 3, 129, 5, 129, 1304, 10, 129, 3, 130, 3, 130, 5, 130, 1308, 10, 130,
	3, 131, 3, 131, 3, 132, 3, 132, 5, 132, 1314, 10, 132, 3, 133, 3, 133,
	3, 134, 3, 134, 3, 135, 3, 135, 3, 136, 3, 136, 3, 137, 3, 137, 3, 138,
	3, 138, 3, 139, 3, 139, 3, 140, 3, 140, 3, 141, 3, 141, 5, 141, 1334, 10,
	141, 3, 142, 3, 142, 5, 142, 1338, 10, 142, 3, 143, 3, 143, 3, 144, 3,
	144, 3, 145, 3, 145, 3, 146, 3, 146, 3, 147, 3, 147, 3, 148, 3, 148, 3,
	149, 3, 149, 3, 150, 3, 150, 3, 151, 3, 151, 3, 152, 3, 152, 5, 152, 1360,
	10, 152, 3, 153, 3, 153, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154,
	3, 154, 3, 154, 5, 154, 1372, 10, 154, 3, 155, 3, 155, 3, 155, 7, 155,
	1377, 10, 155, 12, 155, 14, 155, 1380, 11, 155, 3, 156, 3, 156, 5, 156,
	1384, 10, 156, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157,
	3, 157, 3, 158, 3, 158, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 5, 159,
	1401, 10, 159, 3, 160, 3, 160, 3, 160, 7, 160, 1406, 10, 160, 12, 160,
	14, 160, 1409, 11, 160, 3, 161, 3, 161, 5, 161, 1413, 10, 161, 3, 162,
	3, 162, 3, 162, 3, 163, 3, 163, 3, 163, 5, 163, 1421, 10, 163, 3, 163,
	3, 163, 3, 164, 3, 164, 3, 165, 3, 165, 3, 165, 5, 165, 1430, 10, 165,
	3, 166, 3, 166, 3, 166, 5, 166, 1435, 10, 166, 3, 166, 3, 166, 3, 167,
	3, 167, 3, 167, 3, 168, 3, 168, 3, 168, 5, 168, 1445, 10, 168, 3, 168,
	3, 168, 3, 169, 3, 169, 3, 170, 3, 170, 3, 170, 5, 170, 1454, 10, 170,
	3, 170, 3, 170, 3, 171, 3, 171, 3, 172, 3, 172, 3, 172, 3, 173, 3, 173,
	3, 173, 3, 173, 3, 173, 3, 173, 5, 173, 1469, 10, 173, 3, 174, 3, 174,
	3, 174, 7, 174, 1474, 10, 174, 12, 174, 14, 174, 1477, 11, 174, 3, 175,
	3, 175, 3, 175, 5, 175, 1482, 10, 175, 3, 176, 3, 176, 5, 176, 1486, 10,
	176, 3, 177, 3, 177, 3, 177, 3, 177, 3, 178, 3, 178, 3, 178, 3, 178, 3,
	179, 3, 179, 3, 179, 3, 179, 5, 179, 1500, 10, 179, 3, 180, 3, 180, 3,
	180, 3, 180, 3, 180, 5, 180, 1507, 10, 180, 3, 181, 3, 181, 3, 182, 3,
	182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 183, 3, 183, 3, 183, 3,
	183, 3, 183, 3, 183, 3, 184, 3, 184, 3, 184, 3, 184, 3, 185, 3, 185, 3,
	185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 3, 186, 3, 186, 3, 186, 7,
	186, 1539, 10, 186, 12, 186, 14, 186, 1542, 11, 186, 3, 187, 3, 187, 5,
	187, 1546, 10, 187, 3, 188, 3, 188, 3, 188, 5, 188, 1551, 10, 188, 3, 188,
	3, 188, 3, 189, 3, 189, 3, 189, 3, 189, 3, 189, 3, 190, 3, 190, 3, 190,
	7, 190, 1563, 10, 190, 12, 190, 14, 190, 1566, 11, 190, 3, 191, 3, 191,
	3, 191, 3, 191, 3, 191, 3, 191, 5, 191, 1574, 10, 191, 3, 192, 3, 192,
	3, 192, 3, 192, 3, 192, 3, 192, 5, 192, 1582, 10, 192, 3, 193, 3, 193,
	3, 193, 3, 193, 3, 193, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194,
	3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194,
	3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 5, 194, 1609, 10, 194, 3, 195,
	3, 195, 3, 195, 3, 195, 3, 195, 5, 195, 1616, 10, 195, 3, 196, 3, 196,
	3, 196, 7, 196, 1621, 10, 196, 12, 196, 14, 196, 1624, 11, 196, 3, 197,
	3, 197, 5, 197, 1628, 10, 197, 3, 198, 3, 198, 3, 199, 3, 199, 3, 200,
	3, 200, 3, 201, 3, 201, 3, 202, 3, 202, 3, 202, 2, 13, 38, 40, 42, 86,
	88, 110, 112, 172, 190, 192, 246, 203, 2, 4, 6, 8, 10, 12, 14, 16, 18,
	20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
	56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
	92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
	212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
	242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
	272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300,
	302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330,
	332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360,
	362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390,
	392, 394, 396, 398, 400, 402, 2, 11, 5, 2, 63, 63, 65, 65, 67, 67, 4, 2,
	56, 56, 61, 61, 7, 2, 55, 55, 60, 60, 64, 64, 66, 66, 68, 68, 4, 2, 59,
	59, 62, 62, 3, 2, 48, 53, 3, 2, 46, 47, 4, 2, 58, 58, 70, 70, 3, 2, 96,
	97, 5, 2, 76, 76, 79, 79, 82, 82, 2, 1623, 2, 407, 3, 2, 2, 2, 4, 414,
	3, 2, 2, 2, 6, 423, 3, 2, 2, 2, 8, 425, 3, 2, 2, 2, 10, 436, 3, 2, 2, 2,
	12, 438, 3, 2, 2, 2, 14, 449, 3, 2, 2, 2, 16, 460, 3, 2, 2, 2, 18, 471,
	3, 2, 2, 2, 20, 482, 3, 2, 2, 2, 22, 493, 3, 2, 2, 2, 24, 504, 3, 2, 2,
	2, 26, 509, 3, 2, 2, 2, 28, 513, 3, 2, 2, 2, 30, 519, 3, 2, 2, 2, 32, 524,
	3, 2, 2, 2, 34, 526, 3, 2, 2, 2, 36, 533, 3, 2, 2, 2, 38, 535, 3, 2, 2,
	2, 40, 548, 3, 2, 2, 2, 42, 561, 3, 2, 2, 2, 44, 584, 3, 2, 2, 2, 46, 586,
	3, 2, 2, 2, 48, 589, 3, 2, 2, 2, 50, 595, 3, 2, 2, 2, 52, 605, 3, 2, 2,
	2, 54, 607, 3, 2, 2, 2, 56, 611, 3, 2, 2, 2, 58, 620, 3, 2, 2, 2, 60, 638,
	3, 2, 2, 2, 62, 643, 3, 2, 2, 2, 64, 645, 3, 2, 2, 2, 66, 653, 3, 2, 2,
	2, 68, 659, 3, 2, 2, 2, 70, 661, 3, 2, 2, 2, 72, 670, 3, 2, 2, 2, 74, 672,
	3, 2, 2, 2, 76, 679, 3, 2, 2, 2, 78, 681, 3, 2, 2, 2, 80, 683, 3, 2, 2,
	2, 82, 688, 3, 2, 2, 2, 84, 698, 3, 2, 2, 2, 86, 700, 3, 2, 2, 2, 88, 713,
	3, 2, 2, 2, 90, 734, 3, 2, 2, 2, 92, 746, 3, 2, 2, 2, 94, 748, 3, 2, 2,
	2, 96, 758, 3, 2, 2, 2, 98, 760, 3, 2, 2, 2, 100, 765, 3, 2, 2, 2, 102,
	770, 3, 2, 2, 2, 104, 774, 3, 2, 2, 2, 106, 776, 3, 2, 2, 2, 108, 782,
	3, 2, 2, 2, 110, 784, 3, 2, 2, 2, 112, 797, 3, 2, 2, 2, 114, 819, 3, 2,
	2, 2, 116, 821, 3, 2, 2, 2, 118, 828, 3, 2, 2, 2, 120, 838, 3, 2, 2, 2,
	122, 840, 3, 2, 2, 2, 124, 848, 3, 2, 2, 2, 126, 850, 3, 2, 2, 2, 128,
	852, 3, 2, 2, 2, 130, 872, 3, 2, 2, 2, 132, 879, 3, 2, 2, 2, 134, 881,
	3, 2, 2, 2, 136, 897, 3, 2, 2, 2, 138, 907, 3, 2, 2, 2, 140, 914, 3, 2,
	2, 2, 142, 916, 3, 2, 2, 2, 144, 932, 3, 2, 2, 2, 146, 942, 3, 2, 2, 2,
	148, 952, 3, 2, 2, 2, 150, 959, 3, 2, 2, 2, 152, 961, 3, 2, 2, 2, 154,
	977, 3, 2, 2, 2, 156, 979, 3, 2, 2, 2, 158, 990, 3, 2, 2, 2, 160, 992,
	3, 2, 2, 2, 162, 1004, 3, 2, 2, 2, 164, 1011, 3, 2, 2, 2, 166, 1021, 3,
	2, 2, 2, 168, 1023, 3, 2, 2, 2, 170, 1031, 3, 2, 2, 2, 172, 1035, 3, 2,
	2, 2, 174, 1050, 3, 2, 2, 2, 176, 1054, 3, 2, 2, 2, 178, 1056, 3, 2, 2,
	2, 180, 1065, 3, 2, 2, 2, 182, 1069, 3, 2, 2, 2, 184, 1073, 3, 2, 2, 2,
	186, 1075, 3, 2, 2, 2, 188, 1081, 3, 2, 2, 2, 190, 1083, 3, 2, 2, 2, 192,
	1096, 3, 2, 2, 2, 194, 1116, 3, 2, 2, 2, 196, 1118, 3, 2, 2, 2, 198, 1125,
	3, 2, 2, 2, 200, 1137, 3, 2, 2, 2, 202, 1139, 3, 2, 2, 2, 204, 1146, 3,
	2, 2, 2, 206, 1148, 3, 2, 2, 2, 208, 1152, 3, 2, 2, 2, 210, 1154, 3, 2,
	2, 2, 212, 1156, 3, 2, 2, 2, 214, 1160, 3, 2, 2, 2, 216, 1168, 3, 2, 2,
	2, 218, 1172, 3, 2, 2, 2, 220, 1174, 3, 2, 2, 2, 222, 1182, 3, 2, 2, 2,
	224, 1190, 3, 2, 2, 2, 226, 1192, 3, 2, 2, 2, 228, 1205, 3, 2, 2, 2, 230,
	1210, 3, 2, 2, 2, 232, 1212, 3, 2, 2, 2, 234, 1232, 3, 2, 2, 2, 236, 1239,
	3, 2, 2, 2, 238, 1249, 3, 2, 2, 2, 240, 1256, 3, 2, 2, 2, 242, 1258, 3,
	2, 2, 2, 244, 1271, 3, 2, 2, 2, 246, 1273, 3, 2, 2, 2, 248, 1288, 3, 2,
	2, 2, 250, 1293, 3, 2, 2, 2, 252, 1295, 3, 2, 2, 2, 254, 1297, 3, 2, 2,
	2, 256, 1303, 3, 2, 2, 2, 258, 1307, 3, 2, 2, 2, 260, 1309, 3, 2, 2, 2,
	262, 1313, 3, 2, 2, 2, 264, 1315, 3, 2, 2, 2, 266, 1317, 3, 2, 2, 2, 268,
	1319, 3, 2, 2, 2, 270, 1321, 3, 2, 2, 2, 272, 1323, 3, 2, 2, 2, 274, 1325,
	3, 2, 2, 2, 276, 1327, 3, 2, 2, 2, 278, 1329, 3, 2, 2, 2, 280, 1333, 3,
	2, 2, 2, 282, 1337, 3, 2, 2, 2, 284, 1339, 3, 2, 2, 2, 286, 1341, 3, 2,
	2, 2, 288, 1343, 3, 2, 2, 2, 290, 1345, 3, 2, 2, 2, 292, 1347, 3, 2, 2,
	2, 294, 1349, 3, 2, 2, 2, 296, 1351, 3, 2, 2, 2, 298, 1353, 3, 2, 2, 2,
	300, 1355, 3, 2, 2, 2, 302, 1359, 3, 2, 2, 2, 304, 1361, 3, 2, 2, 2, 306,
	1371, 3, 2, 2, 2, 308, 1373, 3, 2, 2, 2, 310, 1383, 3, 2, 2, 2, 312, 1385,
	3, 2, 2, 2, 314, 1393, 3, 2, 2, 2, 316, 1400, 3, 2, 2, 2, 318, 1402, 3,
	2, 2, 2, 320, 1410, 3, 2, 2, 2, 322, 1414, 3, 2, 2, 2, 324, 1417, 3, 2,
	2, 2, 326, 1424, 3, 2, 2, 2, 328, 1429, 3, 2, 2, 2, 330, 1431, 3, 2, 2,
	2, 332, 1438, 3, 2, 2, 2, 334, 1441, 3, 2, 2, 2, 336, 1448, 3, 2, 2, 2,
	338, 1450, 3, 2, 2, 2, 340, 1457, 3, 2, 2, 2, 342, 1459, 3, 2, 2, 2, 344,
	1468, 3, 2, 2, 2, 346, 1470, 3, 2, 2, 2, 348, 1481, 3, 2, 2, 2, 350, 1485,
	3, 2, 2, 2, 352, 1487, 3, 2, 2, 2, 354, 1491, 3, 2, 2, 2, 356, 1499, 3,
	2, 2, 2, 358, 1506, 3, 2, 2, 2, 360, 1508, 3, 2, 2, 2, 362, 1510, 3, 2,
	2, 2, 364, 1517, 3, 2, 2, 2, 366, 1523, 3, 2, 2, 2, 368, 1527, 3, 2, 2,
	2, 370, 1535, 3, 2, 2, 2, 372, 1545, 3, 2, 2, 2, 374, 1547, 3, 2, 2, 2,
	376, 1554, 3, 2, 2, 2, 378, 1559, 3, 2, 2, 2, 380, 1573, 3, 2, 2, 2, 382,
	1581, 3, 2, 2, 2, 384, 1583, 3, 2, 2, 2, 386, 1608, 3, 2, 2, 2, 388, 1615,
	3, 2, 2, 2, 390, 1617, 3, 2, 2, 2, 392, 1627, 3, 2, 2, 2, 394, 1629, 3,
	2, 2, 2, 396, 1631, 3, 2, 2, 2, 398, 1633, 3, 2, 2, 2, 400, 1635, 3, 2,
	2, 2, 402, 1637, 3, 2, 2, 2, 404, 406, 5, 4, 3, 2, 405, 404, 3, 2, 2, 2,
	406, 409, 3, 2, 2, 2, 407, 405, 3, 2, 2, 2, 407, 408, 3, 2, 2, 2, 408,
	410, 3, 2, 2, 2, 409, 407, 3, 2, 2, 2, 410, 411, 7, 2, 2, 3, 411, 3, 3,
	2, 2, 2, 412, 415, 5, 6, 4, 2, 413, 415, 5, 374, 188, 2, 414, 412, 3, 2,
	2, 2, 414, 413, 3, 2, 2, 2, 415, 5, 3, 2, 2, 2, 416, 424, 5, 12, 7, 2,
	417, 424, 5, 14, 8, 2, 418, 424, 5, 16, 9, 2, 419, 424, 5, 18, 10, 2, 420,
	424, 5, 20, 11, 2, 421, 424, 5, 22, 12, 2, 422, 424, 5, 8, 5, 2, 423, 416,
	3, 2, 2, 2, 423, 417, 3, 2, 2, 2, 423, 418, 3, 2, 2, 2, 423, 419, 3, 2,
	2, 2, 423, 420, 3, 2, 2, 2, 423, 421, 3, 2, 2, 2, 423, 422, 3, 2, 2, 2,
	424, 7, 3, 2, 2, 2, 425, 426, 7, 3, 2, 2, 426, 427, 5, 392, 197, 2, 427,
	428, 7, 4, 2, 2, 428, 429, 5, 26, 14, 2, 429, 430, 7, 4, 2, 2, 430, 432,
	5, 10, 6, 2, 431, 433, 5, 24, 13, 2, 432, 431, 3, 2, 2, 2, 432, 433, 3,
	2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 435, 7, 5, 2, 2, 435, 9, 3, 2, 2, 2,
	436, 437, 5, 180, 91, 2, 437, 11, 3, 2, 2, 2, 438, 439, 7, 6, 2, 2, 439,
	440, 5, 392, 197, 2, 440, 441, 7, 4, 2, 2, 441, 442, 5, 26, 14, 2, 442,
	443, 7, 4, 2, 2, 443, 445, 5, 28, 15, 2, 444, 446, 5, 24, 13, 2, 445, 444,
	3, 2, 2, 2, 445, 446, 3, 2, 2, 2, 446, 447, 3, 2, 2, 2, 447, 448, 7, 5,
	2, 2, 448, 13, 3, 2, 2, 2, 449, 450, 7, 7, 2, 2, 450, 451, 5, 392, 197,
	2, 451, 452, 7, 4, 2, 2, 452, 453, 5, 26, 14, 2, 453, 454, 7, 4, 2, 2,
	454, 456, 5, 96, 49, 2, 455, 457, 5, 24, 13, 2, 456, 455, 3, 2, 2, 2, 456,
	457, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 459, 7, 5, 2, 2, 459, 15, 3,
	2, 2, 2, 460, 461, 7, 8, 2, 2, 461, 462, 5, 392, 197, 2, 462, 463, 7, 4,
	2, 2, 463, 464, 5, 26, 14, 2, 464, 465, 7, 4, 2, 2, 465, 467, 5, 100, 51,
	2, 466, 468, 5, 24, 13, 2, 467, 466, 3, 2, 2, 2, 467, 468, 3, 2, 2, 2,
	468, 469, 3, 2, 2, 2, 469, 470, 7, 5, 2, 2, 470, 17, 3, 2, 2, 2, 471, 472,
	7, 9, 2, 2, 472, 473, 5, 392, 197, 2, 473, 474, 7, 4, 2, 2, 474, 475, 5,
	26, 14, 2, 475, 476, 7, 4, 2, 2, 476, 478, 5, 174, 88, 2, 477, 479, 5,
	24, 13, 2, 478, 477, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 480, 3, 2,
	2, 2, 480, 481, 7, 5, 2, 2, 481, 19, 3, 2, 2, 2, 482, 483, 7, 10, 2, 2,
	483, 484, 5, 392, 197, 2, 484, 485, 7, 4, 2, 2, 485, 486, 5, 26, 14, 2,
	486, 487, 7, 4, 2, 2, 487, 489, 5, 180, 91, 2, 488, 490, 5, 24, 13, 2,
	489, 488, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491,
	492, 7, 5, 2, 2, 492, 21, 3, 2, 2, 2, 493, 494, 7, 11, 2, 2, 494, 495,
	5, 392, 197, 2, 495, 496, 7, 4, 2, 2, 496, 497, 5, 26, 14, 2, 497, 498,
	7, 4, 2, 2, 498, 500, 5, 244, 123, 2, 499, 501, 5, 24, 13, 2, 500, 499,
	3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502, 503, 7, 5,
	2, 2, 503, 23, 3, 2, 2, 2, 504, 505, 7, 4, 2, 2, 505, 507, 5, 306, 154,
	2, 506, 508, 5, 342, 172, 2, 507, 506, 3, 2, 2, 2, 507, 508, 3, 2, 2, 2,
	508, 25, 3, 2, 2, 2, 509, 510, 7, 96, 2, 2, 510, 27, 3, 2, 2, 2, 511, 514,
	5, 30, 16, 2, 512, 514, 5, 90, 46, 2, 513, 511, 3, 2, 2, 2, 513, 512, 3,
	2, 2, 2, 514, 29, 3, 2, 2, 2, 515, 520, 5, 32, 17, 2, 516, 520, 5, 44,
	23, 2, 517, 520, 5, 70, 36, 2, 518, 520, 5, 74, 38, 2, 519, 515, 3, 2,
	2, 2, 519, 516, 3, 2, 2, 2, 519, 517, 3, 2, 2, 2, 519, 518, 3, 2, 2, 2,
	520, 31, 3, 2, 2, 2, 521, 525, 5, 34, 18, 2, 522, 525, 5, 36, 19, 2, 523,
	525, 5, 82, 42, 2, 524, 521, 3, 2, 2, 2, 524, 522, 3, 2, 2, 2, 524, 523,
	3, 2, 2, 2, 525, 33, 3, 2, 2, 2, 526, 527, 5, 44, 23, 2, 527, 528, 5, 256,
	129, 2, 528, 529, 5, 44, 23, 2, 529, 35, 3, 2, 2, 2, 530, 534, 5, 38, 20,
	2, 531, 534, 5, 40, 21, 2, 532, 534, 5, 42, 22, 2, 533, 530, 3, 2, 2, 2,
	533, 531, 3, 2, 2, 2, 533, 532, 3, 2, 2, 2, 534, 37, 3, 2, 2, 2, 535, 536,
	8, 20, 1, 2, 536, 537, 5, 44, 23, 2, 537, 538, 7, 46, 2, 2, 538, 539, 5,
	44, 23, 2, 539, 545, 3, 2, 2, 2, 540, 541, 12, 3, 2, 2, 541, 542, 7, 46,
	2, 2, 542, 544, 5, 44, 23, 2, 543, 540, 3, 2, 2, 2, 544, 547, 3, 2, 2,
	2, 545, 543, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2, 546, 39, 3, 2, 2, 2, 547,
	545, 3, 2, 2, 2, 548, 549, 8, 21, 1, 2, 549, 550, 5, 44, 23, 2, 550, 551,
	7, 47, 2, 2, 551, 552, 5, 44, 23, 2, 552, 558, 3, 2, 2, 2, 553, 554, 12,
	3, 2, 2, 554, 555, 7, 47, 2, 2, 555, 557, 5, 44, 23, 2, 556, 553, 3, 2,
	2, 2, 557, 560, 3, 2, 2, 2, 558, 556, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2,
	559, 41, 3, 2, 2, 2, 560, 558, 3, 2, 2, 2, 561, 562, 8, 22, 1, 2, 562,
	563, 5, 44, 23, 2, 563, 564, 7, 69, 2, 2, 564, 565, 5, 44, 23, 2, 565,
	571, 3, 2, 2, 2, 566, 567, 12, 3, 2, 2, 567, 568, 7, 69, 2, 2, 568, 570,
	5, 44, 23, 2, 569, 566, 3, 2, 2, 2, 570, 573, 3, 2, 2, 2, 571, 569, 3,
	2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 43, 3, 2, 2, 2, 573, 571, 3, 2, 2,
	2, 574, 585, 5, 46, 24, 2, 575, 585, 5, 56, 29, 2, 576, 585, 5, 58, 30,
	2, 577, 585, 5, 64, 33, 2, 578, 585, 5, 66, 34, 2, 579, 585, 5, 92, 47,
	2, 580, 581, 7, 12, 2, 2, 581, 582, 5, 30, 16, 2, 582, 583, 7, 13, 2, 2,
	583, 585, 3, 2, 2, 2, 584, 574, 3, 2, 2, 2, 584, 575, 3, 2, 2, 2, 584,
	576, 3, 2, 2, 2, 584, 577, 3, 2, 2, 2, 584, 578, 3, 2, 2, 2, 584, 579,
	3, 2, 2, 2, 584, 580, 3, 2, 2, 2, 585, 45, 3, 2, 2, 2, 586, 587, 5, 48,
	25, 2, 587, 588, 5, 44, 23, 2, 588, 47, 3, 2, 2, 2, 589, 590, 5, 250, 126,
	2, 590, 591, 7, 14, 2, 2, 591, 592, 5, 50, 26, 2, 592, 593, 7, 15, 2, 2,
	593, 594, 7, 16, 2, 2, 594, 49, 3, 2, 2, 2, 595, 600, 5, 52, 27, 2, 596,
	597, 7, 4, 2, 2, 597, 599, 5, 52, 27, 2, 598, 596, 3, 2, 2, 2, 599, 602,
	3, 2, 2, 2, 600, 598, 3, 2, 2, 2, 600, 601, 3, 2, 2, 2, 601, 51, 3, 2,
	2, 2, 602, 600, 3, 2, 2, 2, 603, 606, 5, 54, 28, 2, 604, 606, 5, 304, 153,
	2, 605, 603, 3, 2, 2, 2, 605, 604, 3, 2, 2, 2, 606, 53, 3, 2, 2, 2, 607,
	608, 5, 304, 153, 2, 608, 609, 7, 16, 2, 2, 609, 610, 5, 76, 39, 2, 610,
	55, 3, 2, 2, 2, 611, 612, 5, 258, 130, 2, 612, 613, 7, 12, 2, 2, 613, 614,
	5, 30, 16, 2, 614, 615, 7, 13, 2, 2, 615, 57, 3, 2, 2, 2, 616, 621, 5,
	60, 31, 2, 617, 621, 5, 304, 153, 2, 618, 621, 5, 302, 152, 2, 619, 621,
	5, 62, 32, 2, 620, 616, 3, 2, 2, 2, 620, 617, 3, 2, 2, 2, 620, 618, 3,
	2, 2, 2, 620, 619, 3, 2, 2, 2, 621, 59, 3, 2, 2, 2, 622, 639, 5, 280, 141,
	2, 623, 624, 5, 292, 147, 2, 624, 625, 7, 12, 2, 2, 625, 626, 5, 68, 35,
	2, 626, 627, 7, 13, 2, 2, 627, 639, 3, 2, 2, 2, 628, 629, 5, 300, 151,
	2, 629, 630, 7, 12, 2, 2, 630, 631, 5, 68, 35, 2, 631, 632, 7, 13, 2, 2,
	632, 639, 3, 2, 2, 2, 633, 634, 5, 296, 149, 2, 634, 635, 7, 12, 2, 2,
	635, 636, 5, 68, 35, 2, 636, 637, 7, 13, 2, 2, 637, 639, 3, 2, 2, 2, 638,
	622, 3, 2, 2, 2, 638, 623, 3, 2, 2, 2, 638, 628, 3, 2, 2, 2, 638, 633,
	3, 2, 2, 2, 639, 61, 3, 2, 2, 2, 640, 644, 5, 256, 129, 2, 641, 644, 5,
	268, 135, 2, 642, 644, 5, 258, 130, 2, 643, 640, 3, 2, 2, 2, 643, 641,
	3, 2, 2, 2, 643, 642, 3, 2, 2, 2, 644, 63, 3, 2, 2, 2, 645, 646, 7, 17,
	2, 2, 646, 647, 5, 30, 16, 2, 647, 648, 7, 4, 2, 2, 648, 649, 5, 30, 16,
	2, 649, 650, 7, 4, 2, 2, 650, 651, 5, 30, 16, 2, 651, 652, 7, 13, 2, 2,
	652, 65, 3, 2, 2, 2, 653, 654, 7, 18, 2, 2, 654, 655, 5, 44, 23, 2, 655,
	656, 7, 4, 2, 2, 656, 657, 5, 28, 15, 2, 657, 658, 7, 13, 2, 2, 658, 67,
	3, 2, 2, 2, 659, 660, 5, 94, 48, 2, 660, 69, 3, 2, 2, 2, 661, 662, 5, 72,
	37, 2, 662, 663, 7, 16, 2, 2, 663, 664, 5, 76, 39, 2, 664, 71, 3, 2, 2,
	2, 665, 671, 5, 58, 30, 2, 666, 667, 7, 12, 2, 2, 667, 668, 5, 30, 16,
	2, 668, 669, 7, 13, 2, 2, 669, 671, 3, 2, 2, 2, 670, 665, 3, 2, 2, 2, 670,
	666, 3, 2, 2, 2, 671, 73, 3, 2, 2, 2, 672, 673, 5, 58, 30, 2, 673, 674,
	7, 74, 2, 2, 674, 675, 5, 58, 30, 2, 675, 75, 3, 2, 2, 2, 676, 680, 5,
	78, 40, 2, 677, 680, 5, 84, 43, 2, 678, 680, 5, 80, 41, 2, 679, 676, 3,
	2, 2, 2, 679, 677, 3, 2, 2, 2, 679, 678, 3, 2, 2, 2, 680, 77, 3, 2, 2,
	2, 681, 682, 5, 44, 23, 2, 682, 79, 3, 2, 2, 2, 683, 684, 5, 42, 22, 2,
	684, 81, 3, 2, 2, 2, 685, 689, 5, 84, 43, 2, 686, 689, 5, 86, 44, 2, 687,
	689, 5, 88, 45, 2, 688, 685, 3, 2, 2, 2, 688, 686, 3, 2, 2, 2, 688, 687,
	3, 2, 2, 2, 689, 83, 3, 2, 2, 2, 690, 691, 5, 78, 40, 2, 691, 692, 7, 71,
	2, 2, 692, 693, 5, 78, 40, 2, 693, 699, 3, 2, 2, 2, 694, 695, 5, 78, 40,
	2, 695, 696, 7, 71, 2, 2, 696, 697, 5, 84, 43, 2, 697, 699, 3, 2, 2, 2,
	698, 690, 3, 2, 2, 2, 698, 694, 3, 2, 2, 2, 699, 85, 3, 2, 2, 2, 700, 701,
	8, 44, 1, 2, 701, 702, 5, 78, 40, 2, 702, 703, 7, 72, 2, 2, 703, 704, 5,
	78, 40, 2, 704, 710, 3, 2, 2, 2, 705, 706, 12, 3, 2, 2, 706, 707, 7, 72,
	2, 2, 707, 709, 5, 78, 40, 2, 708, 705, 3, 2, 2, 2, 709, 712, 3, 2, 2,
	2, 710, 708, 3, 2, 2, 2, 710, 711, 3, 2, 2, 2, 711, 87, 3, 2, 2, 2, 712,
	710, 3, 2, 2, 2, 713, 714, 8, 45, 1, 2, 714, 715, 5, 78, 40, 2, 715, 716,
	7, 73, 2, 2, 716, 717, 5, 78, 40, 2, 717, 723, 3, 2, 2, 2, 718, 719, 12,
	3, 2, 2, 719, 720, 7, 73, 2, 2, 720, 722, 5, 78, 40, 2, 721, 718, 3, 2,
	2, 2, 722, 725, 3, 2, 2, 2, 723, 721, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2,
	724, 89, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 726, 727, 5, 92, 47, 2, 727,
	728, 7, 75, 2, 2, 728, 729, 5, 92, 47, 2, 729, 735, 3, 2, 2, 2, 730, 731,
	7, 12, 2, 2, 731, 732, 5, 90, 46, 2, 732, 733, 7, 13, 2, 2, 733, 735, 3,
	2, 2, 2, 734, 726, 3, 2, 2, 2, 734, 730, 3, 2, 2, 2, 735, 91, 3, 2, 2,
	2, 736, 747, 7, 19, 2, 2, 737, 738, 7, 14, 2, 2, 738, 739, 5, 94, 48, 2,
	739, 740, 7, 15, 2, 2, 740, 747, 3, 2, 2, 2, 741, 747, 7, 20, 2, 2, 742,
	743, 7, 21, 2, 2, 743, 744, 5, 94, 48, 2, 744, 745, 7, 22, 2, 2, 745, 747,
	3, 2, 2, 2, 746, 736, 3, 2, 2, 2, 746, 737, 3, 2, 2, 2, 746, 741, 3, 2,
	2, 2, 746, 742, 3, 2, 2, 2, 747, 93, 3, 2, 2, 2, 748, 753, 5, 30, 16, 2,
	749, 750, 7, 4, 2, 2, 750, 752, 5, 30, 16, 2, 751, 749, 3, 2, 2, 2, 752,
	755, 3, 2, 2, 2, 753, 751, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754, 95, 3,
	2, 2, 2, 755, 753, 3, 2, 2, 2, 756, 759, 5, 98, 50, 2, 757, 759, 5, 90,
	46, 2, 758, 756, 3, 2, 2, 2, 758, 757, 3, 2, 2, 2, 759, 97, 3, 2, 2, 2,
	760, 761, 5, 30, 16, 2, 761, 99, 3, 2, 2, 2, 762, 766, 5, 102, 52, 2, 763,
	766, 5, 154, 78, 2, 764, 766, 5, 148, 75, 2, 765, 762, 3, 2, 2, 2, 765,
	763, 3, 2, 2, 2, 765, 764, 3, 2, 2, 2, 766, 101, 3, 2, 2, 2, 767, 771,
	5, 104, 53, 2, 768, 771, 5, 114, 58, 2, 769, 771, 5, 156, 79, 2, 770, 767,
	3, 2, 2, 2, 770, 768, 3, 2, 2, 2, 770, 769, 3, 2, 2, 2, 771, 103, 3, 2,
	2, 2, 772, 775, 5, 106, 54, 2, 773, 775, 5, 108, 55, 2, 774, 772, 3, 2,
	2, 2, 774, 773, 3, 2, 2, 2, 775, 105, 3, 2, 2, 2, 776, 777, 5, 114, 58,
	2, 777, 778, 5, 266, 134, 2, 778, 779, 5, 114, 58, 2, 779, 107, 3, 2, 2,
	2, 780, 783, 5, 110, 56, 2, 781, 783, 5, 112, 57, 2, 782, 780, 3, 2, 2,
	2, 782, 781, 3, 2, 2, 2, 783, 109, 3, 2, 2, 2, 784, 785, 8, 56, 1, 2, 785,
	786, 5, 114, 58, 2, 786, 787, 7, 46, 2, 2, 787, 788, 5, 114, 58, 2, 788,
	794, 3, 2, 2, 2, 789, 790, 12, 3, 2, 2, 790, 791, 7, 46, 2, 2, 791, 793,
	5, 114, 58, 2, 792, 789, 3, 2, 2, 2, 793, 796, 3, 2, 2, 2, 794, 792, 3,
	2, 2, 2, 794, 795, 3, 2, 2, 2, 795, 111, 3, 2, 2, 2, 796, 794, 3, 2, 2,
	2, 797, 798, 8, 57, 1, 2, 798, 799, 5, 114, 58, 2, 799, 800, 7, 47, 2,
	2, 800, 801, 5, 114, 58, 2, 801, 807, 3, 2, 2, 2, 802, 803, 12, 3, 2, 2,
	803, 804, 7, 47, 2, 2, 804, 806, 5, 114, 58, 2, 805, 802, 3, 2, 2, 2, 806,
	809, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 113,
	3, 2, 2, 2, 809, 807, 3, 2, 2, 2, 810, 820, 5, 116, 59, 2, 811, 820, 5,
	124, 63, 2, 812, 820, 5, 126, 64, 2, 813, 820, 5, 128, 65, 2, 814, 820,
	5, 130, 66, 2, 815, 816, 7, 12, 2, 2, 816, 817, 5, 102, 52, 2, 817, 818,
	7, 13, 2, 2, 818, 820, 3, 2, 2, 2, 819, 810, 3, 2, 2, 2, 819, 811, 3, 2,
	2, 2, 819, 812, 3, 2, 2, 2, 819, 813, 3, 2, 2, 2, 819, 814, 3, 2, 2, 2,
	819, 815, 3, 2, 2, 2, 820, 115, 3, 2, 2, 2, 821, 822, 5, 264, 133, 2, 822,
	823, 7, 14, 2, 2, 823, 824, 5, 118, 60, 2, 824, 825, 7, 15, 2, 2, 825,
	826, 7, 16, 2, 2, 826, 827, 5, 114, 58, 2, 827, 117, 3, 2, 2, 2, 828, 833,
	5, 120, 61, 2, 829, 830, 7, 4, 2, 2, 830, 832, 5, 120, 61, 2, 831, 829,
	3, 2, 2, 2, 832, 835, 3, 2, 2, 2, 833, 831, 3, 2, 2, 2, 833, 834, 3, 2,
	2, 2, 834, 119, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 836, 839, 5, 122, 62,
	2, 837, 839, 5, 304, 153, 2, 838, 836, 3, 2, 2, 2, 838, 837, 3, 2, 2, 2,
	839, 121, 3, 2, 2, 2, 840, 841, 5, 304, 153, 2, 841, 842, 7, 16, 2, 2,
	842, 843, 5, 166, 84, 2, 843, 123, 3, 2, 2, 2, 844, 845, 5, 270, 136, 2,
	845, 846, 5, 114, 58, 2, 846, 849, 3, 2, 2, 2, 847, 849, 5, 202, 102, 2,
	848, 844, 3, 2, 2, 2, 848, 847, 3, 2, 2, 2, 849, 125, 3, 2, 2, 2, 850,
	851, 5, 204, 103, 2, 851, 127, 3, 2, 2, 2, 852, 853, 7, 23, 2, 2, 853,
	854, 5, 102, 52, 2, 854, 855, 7, 4, 2, 2, 855, 856, 5, 102, 52, 2, 856,
	857, 7, 4, 2, 2, 857, 858, 5, 102, 52, 2, 858, 859, 7, 13, 2, 2, 859, 129,
	3, 2, 2, 2, 860, 861, 7, 24, 2, 2, 861, 862, 5, 132, 67, 2, 862, 863, 7,
	4, 2, 2, 863, 864, 5, 100, 51, 2, 864, 865, 7, 13, 2, 2, 865, 873, 3, 2,
	2, 2, 866, 867, 7, 25, 2, 2, 867, 868, 5, 140, 71, 2, 868, 869, 7, 4, 2,
	2, 869, 870, 5, 100, 51, 2, 870, 871, 7, 13, 2, 2, 871, 873, 3, 2, 2, 2,
	872, 860, 3, 2, 2, 2, 872, 866, 3, 2, 2, 2, 873, 131, 3, 2, 2, 2, 874,
	880, 5, 136, 69, 2, 875, 876, 7, 14, 2, 2, 876, 877, 5, 134, 68, 2, 877,
	878, 7, 15, 2, 2, 878, 880, 3, 2, 2, 2, 879, 874, 3, 2, 2, 2, 879, 875,
	3, 2, 2, 2, 880, 133, 3, 2, 2, 2, 881, 886, 5, 136, 69, 2, 882, 883, 7,
	4, 2, 2, 883, 885, 5, 136, 69, 2, 884, 882, 3, 2, 2, 2, 885, 888, 3, 2,
	2, 2, 886, 884, 3, 2, 2, 2, 886, 887, 3, 2, 2, 2, 887, 135, 3, 2, 2, 2,
	888, 886, 3, 2, 2, 2, 889, 890, 7, 59, 2, 2, 890, 891, 7, 14, 2, 2, 891,
	892, 5, 118, 60, 2, 892, 893, 7, 15, 2, 2, 893, 894, 7, 16, 2, 2, 894,
	895, 5, 136, 69, 2, 895, 898, 3, 2, 2, 2, 896, 898, 5, 138, 70, 2, 897,
	889, 3, 2, 2, 2, 897, 896, 3, 2, 2, 2, 898, 137, 3, 2, 2, 2, 899, 900,
	5, 216, 109, 2, 900, 901, 7, 58, 2, 2, 901, 902, 5, 228, 115, 2, 902, 908,
	3, 2, 2, 2, 903, 904, 7, 12, 2, 2, 904, 905, 5, 138, 70, 2, 905, 906, 7,
	13, 2, 2, 906, 908, 3, 2, 2, 2, 907, 899, 3, 2, 2, 2, 907, 903, 3, 2, 2,
	2, 908, 139, 3, 2, 2, 2, 909, 915, 5, 144, 73, 2, 910, 911, 7, 14, 2, 2,
	911, 912, 5, 142, 72, 2, 912, 913, 7, 15, 2, 2, 913, 915, 3, 2, 2, 2, 914,
	909, 3, 2, 2, 2, 914, 910, 3, 2, 2, 2, 915, 141, 3, 2, 2, 2, 916, 921,
	5, 144, 73, 2, 917, 918, 7, 4, 2, 2, 918, 920, 5, 144, 73, 2, 919, 917,
	3, 2, 2, 2, 920, 923, 3, 2, 2, 2, 921, 919, 3, 2, 2, 2, 921, 922, 3, 2,
	2, 2, 922, 143, 3, 2, 2, 2, 923, 921, 3, 2, 2, 2, 924, 925, 7, 59, 2, 2,
	925, 926, 7, 14, 2, 2, 926, 927, 5, 118, 60, 2, 927, 928, 7, 15, 2, 2,
	928, 929, 7, 16, 2, 2, 929, 930, 5, 144, 73, 2, 930, 933, 3, 2, 2, 2, 931,
	933, 5, 146, 74, 2, 932, 924, 3, 2, 2, 2, 932, 931, 3, 2, 2, 2, 933, 145,
	3, 2, 2, 2, 934, 935, 5, 206, 104, 2, 935, 936, 7, 48, 2, 2, 936, 937,
	5, 114, 58, 2, 937, 943, 3, 2, 2, 2, 938, 939, 7, 12, 2, 2, 939, 940, 5,
	146, 74, 2, 940, 941, 7, 13, 2, 2, 941, 943, 3, 2, 2, 2, 942, 934, 3, 2,
	2, 2, 942, 938, 3, 2, 2, 2, 943, 147, 3, 2, 2, 2, 944, 945, 5, 150, 76,
	2, 945, 946, 7, 75, 2, 2, 946, 947, 5, 150, 76, 2, 947, 953, 3, 2, 2, 2,
	948, 949, 7, 12, 2, 2, 949, 950, 5, 148, 75, 2, 950, 951, 7, 13, 2, 2,
	951, 953, 3, 2, 2, 2, 952, 944, 3, 2, 2, 2, 952, 948, 3, 2, 2, 2, 953,
	149, 3, 2, 2, 2, 954, 960, 7, 19, 2, 2, 955, 956, 7, 14, 2, 2, 956, 957,
	5, 152, 77, 2, 957, 958, 7, 15, 2, 2, 958, 960, 3, 2, 2, 2, 959, 954, 3,
	2, 2, 2, 959, 955, 3, 2, 2, 2, 960, 151, 3, 2, 2, 2, 961, 966, 5, 102,
	52, 2, 962, 963, 7, 4, 2, 2, 963, 965, 5, 102, 52, 2, 964, 962, 3, 2, 2,
	2, 965, 968, 3, 2, 2, 2, 966, 964, 3, 2, 2, 2, 966, 967, 3, 2, 2, 2, 967,
	153, 3, 2, 2, 2, 968, 966, 3, 2, 2, 2, 969, 970, 5, 282, 142, 2, 970, 971,
	7, 16, 2, 2, 971, 972, 5, 158, 80, 2, 972, 978, 3, 2, 2, 2, 973, 974, 7,
	12, 2, 2, 974, 975, 5, 154, 78, 2, 975, 976, 7, 13, 2, 2, 976, 978, 3,
	2, 2, 2, 977, 969, 3, 2, 2, 2, 977, 973, 3, 2, 2, 2, 978, 155, 3, 2, 2,
	2, 979, 980, 5, 282, 142, 2, 980, 981, 7, 74, 2, 2, 981, 982, 5, 280, 141,
	2, 982, 157, 3, 2, 2, 2, 983, 991, 5, 166, 84, 2, 984, 991, 5, 170, 86,
	2, 985, 991, 5, 160, 81, 2, 986, 987, 7, 12, 2, 2, 987, 988, 5, 158, 80,
	2, 988, 989, 7, 13, 2, 2, 989, 991, 3, 2, 2, 2, 990, 983, 3, 2, 2, 2, 990,
	984, 3, 2, 2, 2, 990, 985, 3, 2, 2, 2, 990, 986, 3, 2, 2, 2, 991, 159,
	3, 2, 2, 2, 992, 993, 7, 56, 2, 2, 993, 994, 7, 14, 2, 2, 994, 995, 5,
	118, 60, 2, 995, 996, 7, 15, 2, 2, 996, 997, 7, 16, 2, 2, 997, 998, 5,
	162, 82, 2, 998, 161, 3, 2, 2, 2, 999, 1005, 5, 166, 84, 2, 1000, 1001,
	7, 12, 2, 2, 1001, 1002, 5, 170, 86, 2, 1002, 1003, 7, 13, 2, 2, 1003,
	1005, 3, 2, 2, 2, 1004, 999, 3, 2, 2, 2, 1004, 1000, 3, 2, 2, 2, 1005,
	163, 3, 2, 2, 2, 1006, 1012, 5, 166, 84, 2, 1007, 1008, 7, 12, 2, 2, 1008,
	1009, 5, 172, 87, 2, 1009, 1010, 7, 13, 2, 2, 1010, 1012, 3, 2, 2, 2, 1011,
	1006, 3, 2, 2, 2, 1011, 1007, 3, 2, 2, 2, 1012, 165, 3, 2, 2, 2, 1013,
	1022, 5, 272, 137, 2, 1014, 1022, 5, 276, 139, 2, 1015, 1016, 5, 274, 138,
	2, 1016, 1017, 7, 12, 2, 2, 1017, 1018, 5, 168, 85, 2, 1018, 1019, 7, 13,
	2, 2, 1019, 1022, 3, 2, 2, 2, 1020, 1022, 5, 304, 153, 2, 1021, 1013, 3,
	2, 2, 2, 1021, 1014, 3, 2, 2, 2, 1021, 1015, 3, 2, 2, 2, 1021, 1020, 3,
	2, 2, 2, 1022, 167, 3, 2, 2, 2, 1023, 1028, 5, 166, 84, 2, 1024, 1025,
	7, 4, 2, 2, 1025, 1027, 5, 166, 84, 2, 1026, 1024, 3, 2, 2, 2, 1027, 1030,
	3, 2, 2, 2, 1028, 1026, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 169,
	3, 2, 2, 2, 1030, 1028, 3, 2, 2, 2, 1031, 1032, 5, 164, 83, 2, 1032, 1033,
	7, 71, 2, 2, 1033, 1034, 5, 166, 84, 2, 1034, 171, 3, 2, 2, 2, 1035, 1036,
	8, 87, 1, 2, 1036, 1037, 5, 164, 83, 2, 1037, 1038, 7, 72, 2, 2, 1038,
	1039, 5, 166, 84, 2, 1039, 1045, 3, 2, 2, 2, 1040, 1041, 12, 3, 2, 2, 1041,
	1042, 7, 72, 2, 2, 1042, 1044, 5, 166, 84, 2, 1043, 1040, 3, 2, 2, 2, 1044,
	1047, 3, 2, 2, 2, 1045, 1043, 3, 2, 2, 2, 1045, 1046, 3, 2, 2, 2, 1046,
	173, 3, 2, 2, 2, 1047, 1045, 3, 2, 2, 2, 1048, 1051, 5, 176, 89, 2, 1049,
	1051, 5, 154, 78, 2, 1050, 1048, 3, 2, 2, 2, 1050, 1049, 3, 2, 2, 2, 1051,
	175, 3, 2, 2, 2, 1052, 1055, 5, 178, 90, 2, 1053, 1055, 5, 244, 123, 2,
	1054, 1052, 3, 2, 2, 2, 1054, 1053, 3, 2, 2, 2, 1055, 177, 3, 2, 2, 2,
	1056, 1057, 7, 59, 2, 2, 1057, 1058, 7, 14, 2, 2, 1058, 1059, 5, 118, 60,
	2, 1059, 1060, 7, 15, 2, 2, 1060, 1061, 7, 16, 2, 2, 1061, 1062, 5, 244,
	123, 2, 1062, 179, 3, 2, 2, 2, 1063, 1066, 5, 182, 92, 2, 1064, 1066, 5,
	238, 120, 2, 1065, 1063, 3, 2, 2, 2, 1065, 1064, 3, 2, 2, 2, 1066, 181,
	3, 2, 2, 2, 1067, 1070, 5, 184, 93, 2, 1068, 1070, 5, 194, 98, 2, 1069,
	1067, 3, 2, 2, 2, 1069, 1068, 3, 2, 2, 2, 1070, 183, 3, 2, 2, 2, 1071,
	1074, 5, 186, 94, 2, 1072, 1074, 5, 188, 95, 2, 1073, 1071, 3, 2, 2, 2,
	1073, 1072, 3, 2, 2, 2, 1074, 185, 3, 2, 2, 2, 1075, 1076, 5, 194, 98,
	2, 1076, 1077, 5, 266, 134, 2, 1077, 1078, 5, 194, 98, 2, 1078, 187, 3,
	2, 2, 2, 1079, 1082, 5, 190, 96, 2, 1080, 1082, 5, 192, 97, 2, 1081, 1079,
	3, 2, 2, 2, 1081, 1080, 3, 2, 2, 2, 1082, 189, 3, 2, 2, 2, 1083, 1084,
	8, 96, 1, 2, 1084, 1085, 5, 194, 98, 2, 1085, 1086, 7, 46, 2, 2, 1086,
	1087, 5, 194, 98, 2, 1087, 1093, 3, 2, 2, 2, 1088, 1089, 12, 3, 2, 2, 1089,
	1090, 7, 46, 2, 2, 1090, 1092, 5, 194, 98, 2, 1091, 1088, 3, 2, 2, 2, 1092,
	1095, 3, 2, 2, 2, 1093, 1091, 3, 2, 2, 2, 1093, 1094, 3, 2, 2, 2, 1094,
	191, 3, 2, 2, 2, 1095, 1093, 3, 2, 2, 2, 1096, 1097, 8, 97, 1, 2, 1097,
	1098, 5, 194, 98, 2, 1098, 1099, 7, 47, 2, 2, 1099, 1100, 5, 194, 98, 2,
	1100, 1106, 3, 2, 2, 2, 1101, 1102, 12, 3, 2, 2, 1102, 1103, 7, 47, 2,
	2, 1103, 1105, 5, 194, 98, 2, 1104, 1101, 3, 2, 2, 2, 1105, 1108, 3, 2,
	2, 2, 1106, 1104, 3, 2, 2, 2, 1106, 1107, 3, 2, 2, 2, 1107, 193, 3, 2,
	2, 2, 1108, 1106, 3, 2, 2, 2, 1109, 1117, 5, 196, 99, 2, 1110, 1117, 5,
	200, 101, 2, 1111, 1117, 5, 204, 103, 2, 1112, 1113, 7, 12, 2, 2, 1113,
	1114, 5, 182, 92, 2, 1114, 1115, 7, 13, 2, 2, 1115, 1117, 3, 2, 2, 2, 1116,
	1109, 3, 2, 2, 2, 1116, 1110, 3, 2, 2, 2, 1116, 1111, 3, 2, 2, 2, 1116,
	1112, 3, 2, 2, 2, 1117, 195, 3, 2, 2, 2, 1118, 1119, 5, 264, 133, 2, 1119,
	1120, 7, 14, 2, 2, 1120, 1121, 5, 198, 100, 2, 1121, 1122, 7, 15, 2, 2,
	1122, 1123, 7, 16, 2, 2, 1123, 1124, 5, 194, 98, 2, 1124, 197, 3, 2, 2,
	2, 1125, 1130, 5, 304, 153, 2, 1126, 1127, 7, 4, 2, 2, 1127, 1129, 5, 304,
	153, 2, 1128, 1126, 3, 2, 2, 2, 1129, 1132, 3, 2, 2, 2, 1130, 1128, 3,
	2, 2, 2, 1130, 1131, 3, 2, 2, 2, 1131, 199, 3, 2, 2, 2, 1132, 1130, 3,
	2, 2, 2, 1133, 1134, 5, 270, 136, 2, 1134, 1135, 5, 194, 98, 2, 1135, 1138,
	3, 2, 2, 2, 1136, 1138, 5, 202, 102, 2, 1137, 1133, 3, 2, 2, 2, 1137, 1136,
	3, 2, 2, 2, 1138, 201, 3, 2, 2, 2, 1139, 1140, 5, 228, 115, 2, 1140, 1141,
	7, 57, 2, 2, 1141, 1142, 5, 228, 115, 2, 1142, 203, 3, 2, 2, 2, 1143, 1147,
	5, 206, 104, 2, 1144, 1147, 5, 208, 105, 2, 1145, 1147, 5, 214, 108, 2,
	1146, 1143, 3, 2, 2, 2, 1146, 1144, 3, 2, 2, 2, 1146, 1145, 3, 2, 2, 2,
	1147, 205, 3, 2, 2, 2, 1148, 1149, 5, 216, 109, 2, 1149, 207, 3, 2, 2,
	2, 1150, 1153, 5, 210, 106, 2, 1151, 1153, 5, 212, 107, 2, 1152, 1150,
	3, 2, 2, 2, 1152, 1151, 3, 2, 2, 2, 1153, 209, 3, 2, 2, 2, 1154, 1155,
	5, 218, 110, 2, 1155, 211, 3, 2, 2, 2, 1156, 1157, 5, 228, 115, 2, 1157,
	1158, 5, 288, 145, 2, 1158, 1159, 5, 228, 115, 2, 1159, 213, 3, 2, 2, 2,
	1160, 1161, 5, 224, 113, 2, 1161, 215, 3, 2, 2, 2, 1162, 1169, 5, 290,
	146, 2, 1163, 1164, 5, 292, 147, 2, 1164, 1165, 7, 12, 2, 2, 1165, 1166,
	5, 226, 114, 2, 1166, 1167, 7, 13, 2, 2, 1167, 1169, 3, 2, 2, 2, 1168,
	1162, 3, 2, 2, 2, 1168, 1163, 3, 2, 2, 2, 1169, 217, 3, 2, 2, 2, 1170,
	1173, 5, 302, 152, 2, 1171, 1173, 5, 220, 111, 2, 1172, 1170, 3, 2, 2,
	2, 1172, 1171, 3, 2, 2, 2, 1173, 219, 3, 2, 2, 2, 1174, 1175, 5, 222, 112,
	2, 1175, 221, 3, 2, 2, 2, 1176, 1183, 5, 298, 150, 2, 1177, 1178, 5, 300,
	151, 2, 1178, 1179, 7, 12, 2, 2, 1179, 1180, 5, 226, 114, 2, 1180, 1181,
	7, 13, 2, 2, 1181, 1183, 3, 2, 2, 2, 1182, 1176, 3, 2, 2, 2, 1182, 1177,
	3, 2, 2, 2, 1183, 223, 3, 2, 2, 2, 1184, 1191, 5, 294, 148, 2, 1185, 1186,
	5, 296, 149, 2, 1186, 1187, 7, 12, 2, 2, 1187, 1188, 5, 226, 114, 2, 1188,
	1189, 7, 13, 2, 2, 1189, 1191, 3, 2, 2, 2, 1190, 1184, 3, 2, 2, 2, 1190,
	1185, 3, 2, 2, 2, 1191, 225, 3, 2, 2, 2, 1192, 1197, 5, 228, 115, 2, 1193,
	1194, 7, 4, 2, 2, 1194, 1196, 5, 228, 115, 2, 1195, 1193, 3, 2, 2, 2, 1196,
	1199, 3, 2, 2, 2, 1197, 1195, 3, 2, 2, 2, 1197, 1198, 3, 2, 2, 2, 1198,
	227, 3, 2, 2, 2, 1199, 1197, 3, 2, 2, 2, 1200, 1206, 5, 230, 116, 2, 1201,
	1206, 5, 304, 153, 2, 1202, 1206, 5, 232, 117, 2, 1203, 1206, 5, 234, 118,
	2, 1204, 1206, 5, 236, 119, 2, 1205, 1200, 3, 2, 2, 2, 1205, 1201, 3, 2,
	2, 2, 1205, 1202, 3, 2, 2, 2, 1205, 1203, 3, 2, 2, 2, 1205, 1204, 3, 2,
	2, 2, 1206, 229, 3, 2, 2, 2, 1207, 1211, 5, 216, 109, 2, 1208, 1211, 5,
	218, 110, 2, 1209, 1211, 5, 224, 113, 2, 1210, 1207, 3, 2, 2, 2, 1210,
	1208, 3, 2, 2, 2, 1210, 1209, 3, 2, 2, 2, 1211, 231, 3, 2, 2, 2, 1212,
	1213, 7, 26, 2, 2, 1213, 1214, 5, 102, 52, 2, 1214, 1215, 7, 4, 2, 2, 1215,
	1216, 5, 228, 115, 2, 1216, 1217, 7, 4, 2, 2, 1217, 1218, 5, 228, 115,
	2, 1218, 1219, 7, 13, 2, 2, 1219, 233, 3, 2, 2, 2, 1220, 1221, 7, 27, 2,
	2, 1221, 1222, 5, 140, 71, 2, 1222, 1223, 7, 4, 2, 2, 1223, 1224, 5, 228,
	115, 2, 1224, 1225, 7, 13, 2, 2, 1225, 1233, 3, 2, 2, 2, 1226, 1227, 7,
	28, 2, 2, 1227, 1228, 5, 132, 67, 2, 1228, 1229, 7, 4, 2, 2, 1229, 1230,
	5, 228, 115, 2, 1230, 1231, 7, 13, 2, 2, 1231, 1233, 3, 2, 2, 2, 1232,
	1220, 3, 2, 2, 2, 1232, 1226, 3, 2, 2, 2, 1233, 235, 3, 2, 2, 2, 1234,
	1240, 7, 20, 2, 2, 1235, 1236, 7, 21, 2, 2, 1236, 1237, 5, 226, 114, 2,
	1237, 1238, 7, 22, 2, 2, 1238, 1240, 3, 2, 2, 2, 1239, 1234, 3, 2, 2, 2,
	1239, 1235, 3, 2, 2, 2, 1240, 237, 3, 2, 2, 2, 1241, 1242, 5, 240, 121,
	2, 1242, 1243, 7, 75, 2, 2, 1243, 1244, 5, 240, 121, 2, 1244, 1250, 3,
	2, 2, 2, 1245, 1246, 7, 12, 2, 2, 1246, 1247, 5, 238, 120, 2, 1247, 1248,
	7, 13, 2, 2, 1248, 1250, 3, 2, 2, 2, 1249, 1241, 3, 2, 2, 2, 1249, 1245,
	3, 2, 2, 2, 1250, 239, 3, 2, 2, 2, 1251, 1257, 7, 19, 2, 2, 1252, 1253,
	7, 14, 2, 2, 1253, 1254, 5, 242, 122, 2, 1254, 1255, 7, 15, 2, 2, 1255,
	1257, 3, 2, 2, 2, 1256, 1251, 3, 2, 2, 2, 1256, 1252, 3, 2, 2, 2, 1257,
	241, 3, 2, 2, 2, 1258, 1263, 5, 182, 92, 2, 1259, 1260, 7, 4, 2, 2, 1260,
	1262, 5, 182, 92, 2, 1261, 1259, 3, 2, 2, 2, 1262, 1265, 3, 2, 2, 2, 1263,
	1261, 3, 2, 2, 2, 1263, 1264, 3, 2, 2, 2, 1264, 243, 3, 2, 2, 2, 1265,
	1263, 3, 2, 2, 2, 1266, 1272, 5, 246, 124, 2, 1267, 1268, 7, 12, 2, 2,
	1268, 1269, 5, 246, 124, 2, 1269, 1270, 7, 13, 2, 2, 1270, 1272, 3, 2,
	2, 2, 1271, 1266, 3, 2, 2, 2, 1271, 1267, 3, 2, 2, 2, 1272, 245, 3, 2,
	2, 2, 1273, 1274, 8, 124, 1, 2, 1274, 1275, 5, 248, 125, 2, 1275, 1281,
	3, 2, 2, 2, 1276, 1277, 12, 3, 2, 2, 1277, 1278, 7, 46, 2, 2, 1278, 1280,
	5, 248, 125, 2, 1279, 1276, 3, 2, 2, 2, 1280, 1283, 3, 2, 2, 2, 1281, 1279,
	3, 2, 2, 2, 1281, 1282, 3, 2, 2, 2, 1282, 247, 3, 2, 2, 2, 1283, 1281,
	3, 2, 2, 2, 1284, 1289, 5, 204, 103, 2, 1285, 1286, 7, 54, 2, 2, 1286,
	1289, 5, 204, 103, 2, 1287, 1289, 5, 202, 102, 2, 1288, 1284, 3, 2, 2,
	2, 1288, 1285, 3, 2, 2, 2, 1288, 1287, 3, 2, 2, 2, 1289, 249, 3, 2, 2,
	2, 1290, 1294, 5, 264, 133, 2, 1291, 1294, 5, 252, 127, 2, 1292, 1294,
	5, 254, 128, 2, 1293, 1290, 3, 2, 2, 2, 1293, 1291, 3, 2, 2, 2, 1293, 1292,
	3, 2, 2, 2, 1294, 251, 3, 2, 2, 2, 1295, 1296, 9, 2, 2, 2, 1296, 253, 3,
	2, 2, 2, 1297, 1298, 9, 3, 2, 2, 1298, 255, 3, 2, 2, 2, 1299, 1304, 7,
	58, 2, 2, 1300, 1304, 7, 57, 2, 2, 1301, 1304, 5, 266, 134, 2, 1302, 1304,
	7, 70, 2, 2, 1303, 1299, 3, 2, 2, 2, 1303, 1300, 3, 2, 2, 2, 1303, 1301,
	3, 2, 2, 2, 1303, 1302, 3, 2, 2, 2, 1304, 257, 3, 2, 2, 2, 1305, 1308,
	5, 270, 136, 2, 1306, 1308, 5, 260, 131, 2, 1307, 1305, 3, 2, 2, 2, 1307,
	1306, 3, 2, 2, 2, 1308, 259, 3, 2, 2, 2, 1309, 1310, 9, 4, 2, 2, 1310,
	261, 3, 2, 2, 2, 1311, 1314, 5, 266, 134, 2, 1312, 1314, 7, 70, 2, 2, 1313,
	1311, 3, 2, 2, 2, 1313, 1312, 3, 2, 2, 2, 1314, 263, 3, 2, 2, 2, 1315,
	1316, 9, 5, 2, 2, 1316, 265, 3, 2, 2, 2, 1317, 1318, 9, 6, 2, 2, 1318,
	267, 3, 2, 2, 2, 1319, 1320, 9, 7, 2, 2, 1320, 269, 3, 2, 2, 2, 1321, 1322,
	7, 54, 2, 2, 1322, 271, 3, 2, 2, 2, 1323, 1324, 5, 274, 138, 2, 1324, 273,
	3, 2, 2, 2, 1325, 1326, 5, 394, 198, 2, 1326, 275, 3, 2, 2, 2, 1327, 1328,
	7, 93, 2, 2, 1328, 277, 3, 2, 2, 2, 1329, 1330, 5, 398, 200, 2, 1330, 279,
	3, 2, 2, 2, 1331, 1334, 5, 282, 142, 2, 1332, 1334, 5, 298, 150, 2, 1333,
	1331, 3, 2, 2, 2, 1333, 1332, 3, 2, 2, 2, 1334, 281, 3, 2, 2, 2, 1335,
	1338, 5, 290, 146, 2, 1336, 1338, 5, 294, 148, 2, 1337, 1335, 3, 2, 2,
	2, 1337, 1336, 3, 2, 2, 2, 1338, 283, 3, 2, 2, 2, 1339, 1340, 7, 93, 2,
	2, 1340, 285, 3, 2, 2, 2, 1341, 1342, 7, 93, 2, 2, 1342, 287, 3, 2, 2,
	2, 1343, 1344, 9, 8, 2, 2, 1344, 289, 3, 2, 2, 2, 1345, 1346, 5, 292, 147,
	2, 1346, 291, 3, 2, 2, 2, 1347, 1348, 5, 394, 198, 2, 1348, 293, 3, 2,
	2, 2, 1349, 1350, 5, 296, 149, 2, 1350, 295, 3, 2, 2, 2, 1351, 1352, 5,
	398, 200, 2, 1352, 297, 3, 2, 2, 2, 1353, 1354, 5, 300, 151, 2, 1354, 299,
	3, 2, 2, 2, 1355, 1356, 5, 396, 199, 2, 1356, 301, 3, 2, 2, 2, 1357, 1360,
	5, 400, 201, 2, 1358, 1360, 7, 98, 2, 2, 1359, 1357, 3, 2, 2, 2, 1359,
	1358, 3, 2, 2, 2, 1360, 303, 3, 2, 2, 2, 1361, 1362, 7, 95, 2, 2, 1362,
	305, 3, 2, 2, 2, 1363, 1372, 5, 310, 156, 2, 1364, 1372, 5, 324, 163, 2,
	1365, 1372, 5, 328, 165, 2, 1366, 1372, 7, 96, 2, 2, 1367, 1368, 7, 14,
	2, 2, 1368, 1369, 5, 308, 155, 2, 1369, 1370, 7, 15, 2, 2, 1370, 1372,
	3, 2, 2, 2, 1371, 1363, 3, 2, 2, 2, 1371, 1364, 3, 2, 2, 2, 1371, 1365,
	3, 2, 2, 2, 1371, 1366, 3, 2, 2, 2, 1371, 1367, 3, 2, 2, 2, 1372, 307,
	3, 2, 2, 2, 1373, 1378, 5, 306, 154, 2, 1374, 1375, 7, 4, 2, 2, 1375, 1377,
	5, 306, 154, 2, 1376, 1374, 3, 2, 2, 2, 1377, 1380, 3, 2, 2, 2, 1378, 1376,
	3, 2, 2, 2, 1378, 1379, 3, 2, 2, 2, 1379, 309, 3, 2, 2, 2, 1380, 1378,
	3, 2, 2, 2, 1381, 1384, 5, 392, 197, 2, 1382, 1384, 5, 312, 157, 2, 1383,
	1381, 3, 2, 2, 2, 1383, 1382, 3, 2, 2, 2, 1384, 311, 3, 2, 2, 2, 1385,
	1386, 7, 29, 2, 2, 1386, 1387, 5, 314, 158, 2, 1387, 1388, 7, 4, 2, 2,
	1388, 1389, 5, 344, 173, 2, 1389, 1390, 7, 4, 2, 2, 1390, 1391, 5, 316,
	159, 2, 1391, 1392, 7, 13, 2, 2, 1392, 313, 3, 2, 2, 2, 1393, 1394, 5,
	394, 198, 2, 1394, 315, 3, 2, 2, 2, 1395, 1401, 7, 19, 2, 2, 1396, 1397,
	7, 14, 2, 2, 1397, 1398, 5, 318, 160, 2, 1398, 1399, 7, 15, 2, 2, 1399,
	1401, 3, 2, 2, 2, 1400, 1395, 3, 2, 2, 2, 1400, 1396, 3, 2, 2, 2, 1401,
	317, 3, 2, 2, 2, 1402, 1407, 5, 320, 161, 2, 1403, 1404, 7, 4, 2, 2, 1404,
	1406, 5, 320, 161, 2, 1405, 1403, 3, 2, 2, 2, 1406, 1409, 3, 2, 2, 2, 1407,
	1405, 3, 2, 2, 2, 1407, 1408, 3, 2, 2, 2, 1408, 319, 3, 2, 2, 2, 1409,
	1407, 3, 2, 2, 2, 1410, 1412, 5, 306, 154, 2, 1411, 1413, 5, 322, 162,
	2, 1412, 1411, 3, 2, 2, 2, 1412, 1413, 3, 2, 2, 2, 1413, 321, 3, 2, 2,
	2, 1414, 1415, 7, 16, 2, 2, 1415, 1416, 5, 388, 195, 2, 1416, 323, 3, 2,
	2, 2, 1417, 1418, 7, 30, 2, 2, 1418, 1420, 5, 326, 164, 2, 1419, 1421,
	5, 342, 172, 2, 1420, 1419, 3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421, 1422,
	3, 2, 2, 2, 1422, 1423, 7, 13, 2, 2, 1423, 325, 3, 2, 2, 2, 1424, 1425,
	7, 96, 2, 2, 1425, 327, 3, 2, 2, 2, 1426, 1430, 5, 330, 166, 2, 1427, 1430,
	5, 334, 168, 2, 1428, 1430, 5, 338, 170, 2, 1429, 1426, 3, 2, 2, 2, 1429,
	1427, 3, 2, 2, 2, 1429, 1428, 3, 2, 2, 2, 1430, 329, 3, 2, 2, 2, 1431,
	1432, 7, 31, 2, 2, 1432, 1434, 5, 402, 202, 2, 1433, 1435, 5, 332, 167,
	2, 1434, 1433, 3, 2, 2, 2, 1434, 1435, 3, 2, 2, 2, 1435, 1436, 3, 2, 2,
	2, 1436, 1437, 7, 13, 2, 2, 1437, 331, 3, 2, 2, 2, 1438, 1439, 7, 4, 2,
	2, 1439, 1440, 5, 392, 197, 2, 1440, 333, 3, 2, 2, 2, 1441, 1442, 7, 32,
	2, 2, 1442, 1444, 5, 336, 169, 2, 1443, 1445, 5, 342, 172, 2, 1444, 1443,
	3, 2, 2, 2, 1444, 1445, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446, 1447,
	7, 13, 2, 2, 1447, 335, 3, 2, 2, 2, 1448, 1449, 7, 96, 2, 2, 1449, 337,
	3, 2, 2, 2, 1450, 1451, 7, 33, 2, 2, 1451, 1453, 5, 340, 171, 2, 1452,
	1454, 5, 342, 172, 2, 1453, 1452, 3, 2, 2, 2, 1453, 1454, 3, 2, 2, 2, 1454,
	1455, 3, 2, 2, 2, 1455, 1456, 7, 13, 2, 2, 1456, 339, 3, 2, 2, 2, 1457,
	1458, 5, 394, 198, 2, 1458, 341, 3, 2, 2, 2, 1459, 1460, 7, 4, 2, 2, 1460,
	1461, 5, 344, 173, 2, 1461, 343, 3, 2, 2, 2, 1462, 1469, 7, 19, 2, 2, 1463,
	1464, 7, 14, 2, 2, 1464, 1465, 5, 346, 174, 2, 1465, 1466, 7, 15, 2, 2,
	1466, 1469, 3, 2, 2, 2, 1467, 1469, 5, 388, 195, 2, 1468, 1462, 3, 2, 2,
	2, 1468, 1463, 3, 2, 2, 2, 1468, 1467, 3, 2, 2, 2, 1469, 345, 3, 2, 2,
	2, 1470, 1475, 5, 348, 175, 2, 1471, 1472, 7, 4, 2, 2, 1472, 1474, 5, 348,
	175, 2, 1473, 1471, 3, 2, 2, 2, 1474, 1477, 3, 2, 2, 2, 1475, 1473, 3,
	2, 2, 2, 1475, 1476, 3, 2, 2, 2, 1476, 347, 3, 2, 2, 2, 1477, 1475, 3,
	2, 2, 2, 1478, 1482, 5, 350, 176, 2, 1479, 1482, 5, 356, 179, 2, 1480,
	1482, 5, 384, 193, 2, 1481, 1478, 3, 2, 2, 2, 1481, 1479, 3, 2, 2, 2, 1481,
	1480, 3, 2, 2, 2, 1482, 349, 3, 2, 2, 2, 1483, 1486, 5, 352, 177, 2, 1484,
	1486, 5, 354, 178, 2, 1485, 1483, 3, 2, 2, 2, 1485, 1484, 3, 2, 2, 2, 1486,
	351, 3, 2, 2, 2, 1487, 1488, 7, 34, 2, 2, 1488, 1489, 5, 394, 198, 2, 1489,
	1490, 7, 13, 2, 2, 1490, 353, 3, 2, 2, 2, 1491, 1492, 7, 35, 2, 2, 1492,
	1493, 5, 394, 198, 2, 1493, 1494, 7, 13, 2, 2, 1494, 355, 3, 2, 2, 2, 1495,
	1500, 5, 358, 180, 2, 1496, 1500, 5, 364, 183, 2, 1497, 1500, 5, 368, 185,
	2, 1498, 1500, 5, 366, 184, 2, 1499, 1495, 3, 2, 2, 2, 1499, 1496, 3, 2,
	2, 2, 1499, 1497, 3, 2, 2, 2, 1499, 1498, 3, 2, 2, 2, 1500, 357, 3, 2,
	2, 2, 1501, 1502, 7, 36, 2, 2, 1502, 1503, 5, 360, 181, 2, 1503, 1504,
	7, 13, 2, 2, 1504, 1507, 3, 2, 2, 2, 1505, 1507, 5, 362, 182, 2, 1506,
	1501, 3, 2, 2, 2, 1506, 1505, 3, 2, 2, 2, 1507, 359, 3, 2, 2, 2, 1508,
	1509, 7, 96, 2, 2, 1509, 361, 3, 2, 2, 2, 1510, 1511, 5, 314, 158, 2, 1511,
	1512, 7, 12, 2, 2, 1512, 1513, 5, 394, 198, 2, 1513, 1514, 7, 4, 2, 2,
	1514, 1515, 5, 388, 195, 2, 1515, 1516, 7, 13, 2, 2, 1516, 363, 3, 2, 2,
	2, 1517, 1518, 7, 37, 2, 2, 1518, 1519, 7, 14, 2, 2, 1519, 1520, 5, 378,
	190, 2, 1520, 1521, 7, 15, 2, 2, 1521, 1522, 7, 13, 2, 2, 1522, 365, 3,
	2, 2, 2, 1523, 1524, 7, 38, 2, 2, 1524, 1525, 5, 330, 166, 2, 1525, 1526,
	7, 13, 2, 2, 1526, 367, 3, 2, 2, 2, 1527, 1528, 7, 39, 2, 2, 1528, 1529,
	5, 394, 198, 2, 1529, 1530, 7, 4, 2, 2, 1530, 1531, 7, 14, 2, 2, 1531,
	1532, 5, 370, 186, 2, 1532, 1533, 7, 15, 2, 2, 1533, 1534, 7, 13, 2, 2,
	1534, 369, 3, 2, 2, 2, 1535, 1540, 5, 372, 187, 2, 1536, 1537, 7, 4, 2,
	2, 1537, 1539, 5, 372, 187, 2, 1538, 1536, 3, 2, 2, 2, 1539, 1542, 3, 2,
	2, 2, 1540, 1538, 3, 2, 2, 2, 1540, 1541, 3, 2, 2, 2, 1541, 371, 3, 2,
	2, 2, 1542, 1540, 3, 2, 2, 2, 1543, 1546, 5, 292, 147, 2, 1544, 1546, 5,
	304, 153, 2, 1545, 1543, 3, 2, 2, 2, 1545, 1544, 3, 2, 2, 2, 1546, 373,
	3, 2, 2, 2, 1547, 1548, 7, 40, 2, 2, 1548, 1550, 5, 402, 202, 2, 1549,
	1551, 5, 376, 189, 2, 1550, 1549, 3, 2, 2, 2, 1550, 1551, 3, 2, 2, 2, 1551,
	1552, 3, 2, 2, 2, 1552, 1553, 7, 5, 2, 2, 1553, 375, 3, 2, 2, 2, 1554,
	1555, 7, 4, 2, 2, 1555, 1556, 7, 14, 2, 2, 1556, 1557, 5, 378, 190, 2,
	1557, 1558, 7, 15, 2, 2, 1558, 377, 3, 2, 2, 2, 1559, 1564, 5, 392, 197,
	2, 1560, 1561, 7, 4, 2, 2, 1561, 1563, 5, 392, 197, 2, 1562, 1560, 3, 2,
	2, 2, 1563, 1566, 3, 2, 2, 2, 1564, 1562, 3, 2, 2, 2, 1564, 1565, 3, 2,
	2, 2, 1565, 379, 3, 2, 2, 2, 1566, 1564, 3, 2, 2, 2, 1567, 1574, 5, 382,
	192, 2, 1568, 1569, 5, 382, 192, 2, 1569, 1570, 7, 16, 2, 2, 1570, 1571,
	5, 380, 191, 2, 1571, 1574, 3, 2, 2, 2, 1572, 1574, 5, 388, 195, 2, 1573,
	1567, 3, 2, 2, 2, 1573, 1568, 3, 2, 2, 2, 1573, 1572, 3, 2, 2, 2, 1574,
	381, 3, 2, 2, 2, 1575, 1582, 5, 394, 198, 2, 1576, 1582, 5, 384, 193, 2,
	1577, 1582, 5, 304, 153, 2, 1578, 1582, 5, 400, 201, 2, 1579, 1582, 7,
	98, 2, 2, 1580, 1582, 5, 386, 194, 2, 1581, 1575, 3, 2, 2, 2, 1581, 1576,
	3, 2, 2, 2, 1581, 1577, 3, 2, 2, 2, 1581, 1578, 3, 2, 2, 2, 1581, 1579,
	3, 2, 2, 2, 1581, 1580, 3, 2, 2, 2, 1582, 383, 3, 2, 2, 2, 1583, 1584,
	5, 394, 198, 2, 1584, 1585, 7, 12, 2, 2, 1585, 1586, 5, 390, 196, 2, 1586,
	1587, 7, 13, 2, 2, 1587, 385, 3, 2, 2, 2, 1588, 1589, 7, 41, 2, 2, 1589,
	1590, 5, 28, 15, 2, 1590, 1591, 7, 13, 2, 2, 1591, 1609, 3, 2, 2, 2, 1592,
	1593, 7, 42, 2, 2, 1593, 1594, 5, 100, 51, 2, 1594, 1595, 7, 13, 2, 2,
	1595, 1609, 3, 2, 2, 2, 1596, 1597, 7, 43, 2, 2, 1597, 1598, 5, 180, 91,
	2, 1598, 1599, 7, 13, 2, 2, 1599, 1609, 3, 2, 2, 2, 1600, 1601, 7, 44,
	2, 2, 1601, 1602, 5, 244, 123, 2, 1602, 1603, 7, 13, 2, 2, 1603, 1609,
	3, 2, 2, 2, 1604, 1605, 7, 45, 2, 2, 1605, 1606, 5, 228, 115, 2, 1606,
	1607, 7, 13, 2, 2, 1607, 1609, 3, 2, 2, 2, 1608, 1588, 3, 2, 2, 2, 1608,
	1592, 3, 2, 2, 2, 1608, 1596, 3, 2, 2, 2, 1608, 1600, 3, 2, 2, 2, 1608,
	1604, 3, 2, 2, 2, 1609, 387, 3, 2, 2, 2, 1610, 1616, 7, 19, 2, 2, 1611,
	1612, 7, 14, 2, 2, 1612, 1613, 5, 390, 196, 2, 1613, 1614, 7, 15, 2, 2,
	1614, 1616, 3, 2, 2, 2, 1615, 1610, 3, 2, 2, 2, 1615, 1611, 3, 2, 2, 2,
	1616, 389, 3, 2, 2, 2, 1617, 1622, 5, 380, 191, 2, 1618, 1619, 7, 4, 2,
	2, 1619, 1621, 5, 380, 191, 2, 1620, 1618, 3, 2, 2, 2, 1621, 1624, 3, 2,
	2, 2, 1622, 1620, 3, 2, 2, 2, 1622, 1623, 3, 2, 2, 2, 1623, 391, 3, 2,
	2, 2, 1624, 1622, 3, 2, 2, 2, 1625, 1628, 5, 394, 198, 2, 1626, 1628, 7,
	82, 2, 2, 1627, 1625, 3, 2, 2, 2, 1627, 1626, 3, 2, 2, 2, 1628, 393, 3,
	2, 2, 2, 1629, 1630, 9, 9, 2, 2, 1630, 395, 3, 2, 2, 2, 1631, 1632, 7,
	93, 2, 2, 1632, 397, 3, 2, 2, 2, 1633, 1634, 7, 94, 2, 2, 1634, 399, 3,
	2, 2, 2, 1635, 1636, 9, 10, 2, 2, 1636, 401, 3, 2, 2, 2, 1637, 1638, 7,
	97, 2, 2, 1638, 403, 3, 2, 2, 2, 127, 407, 414, 423, 432, 445, 456, 467,
	478, 489, 500, 507, 513, 519, 524, 533, 545, 558, 571, 584, 600, 605, 620,
	638, 643, 670, 679, 688, 698, 710, 723, 734, 746, 753, 758, 765, 770, 774,
	782, 794, 807, 819, 833, 838, 848, 872, 879, 886, 897, 907, 914, 921, 932,
	942, 952, 959, 966, 977, 990, 1004, 1011, 1021, 1028, 1045, 1050, 1054,
	1065, 1069, 1073, 1081, 1093, 1106, 1116, 1130, 1137, 1146, 1152, 1168,
	1172, 1182, 1190, 1197, 1205, 1210, 1232, 1239, 1249, 1256, 1263, 1271,
	1281, 1288, 1293, 1303, 1307, 1313, 1333, 1337, 1359, 1371, 1378, 1383,
	1400, 1407, 1412, 1420, 1429, 1434, 1444, 1453, 1468, 1475, 1481, 1485,
	1499, 1506, 1540, 1545, 1550, 1564, 1573, 1581, 1608, 1615, 1622, 1627,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'tpi('", "','", "').'", "'thf('", "'tfx('", "'tff('", "'tcf('", "'fof('",
	"'cnf('", "'('", "')'", "'['", "']'", "':'", "'$ite('", "'$let('", "'[]'",
	"'{}'", "'{'", "'}'", "'$ite_f('", "'$let_tf('", "'$let_ff('", "'$ite_t('",
	"'$let_ft('", "'$let_tt('", "'inference('", "'introduced('", "'file('",
	"'theory('", "'creator('", "'description('", "'iquote('", "'status('",
	"'assumptions('", "'refutation('", "'new_symbols('", "'include('", "'$thf('",
	"'$tff('", "'$fof('", "'$cnf('", "'$fot('", "'|'", "'&'", "'<=>'", "'=>'",
	"'<='", "'<~>'", "'~|'", "'~&'", "'~'", "'!!'", "'!>'", "'!='", "'='",
	"'!'", "'??'", "'?*'", "'?'", "'^'", "'@@+'", "'@+'", "'@@-'", "'@-'",
	"'@='", "'@'", "':='", "'>'", "'*'", "'+'", "'<<'", "'-->'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "Or", "And", "Iff", "Impl", "If", "Niff",
	"Nor", "Nand", "Not", "ForallComb", "TyForall", "Infix_inequality", "Infix_equality",
	"Forall", "ExistsComb", "TyExists", "Exists", "Lambda", "ChoiceComb", "Choice",
	"DescriptionComb", "Description", "EqComb", "App", "Assignment", "Arrow",
	"Star", "Plus", "Subtype_sign", "Gentzen_arrow", "Real", "Signed_real",
	"Unsigned_real", "Rational", "Signed_rational", "Unsigned_rational", "Integer",
	"Signed_integer", "Unsigned_integer", "Decimal", "Positive_decimal", "Decimal_exponent",
	"Decimal_fraction", "Dot_decimal", "Exp_integer", "Signed_exp_integer",
	"Unsigned_exp_integer", "Dollar_word", "Dollar_dollar_word", "Upper_word",
	"Lower_word", "Single_quoted", "Distinct_object", "WS", "Line_comment",
	"Block_comment",
}

var ruleNames = []string{
	"tptp_file", "tptp_input", "annotated_formula", "tpi_annotated", "tpi_formula",
	"thf_annotated", "tfx_annotated", "tff_annotated", "tcf_annotated", "fof_annotated",
	"cnf_annotated", "annotations", "formula_role", "thf_formula", "thf_logic_formula",
	"thf_binary_formula", "thf_binary_pair", "thf_binary_tuple", "thf_or_formula",
	"thf_and_formula", "thf_apply_formula", "thf_unitary_formula", "thf_quantified_formula",
	"thf_quantification", "thf_variable_list", "thf_variable", "thf_typed_variable",
	"thf_unary_formula", "thf_atom", "thf_function", "thf_conn_term", "thf_conditional",
	"thf_let", "thf_arguments", "thf_type_formula", "thf_typeable_formula",
	"thf_subtype", "thf_top_level_type", "thf_unitary_type", "thf_apply_type",
	"thf_binary_type", "thf_mapping_type", "thf_xprod_type", "thf_union_type",
	"thf_sequent", "thf_tuple", "thf_formula_list", "tfx_formula", "tfx_logic_formula",
	"tff_formula", "tff_logic_formula", "tff_binary_formula", "tff_binary_nonassoc",
	"tff_binary_assoc", "tff_or_formula", "tff_and_formula", "tff_unitary_formula",
	"tff_quantified_formula", "tff_variable_list", "tff_variable", "tff_typed_variable",
	"tff_unary_formula", "tff_atomic_formula", "tff_conditional", "tff_let",
	"tff_let_term_defns", "tff_let_term_list", "tff_let_term_defn", "tff_let_term_binding",
	"tff_let_formula_defns", "tff_let_formula_list", "tff_let_formula_defn",
	"tff_let_formula_binding", "tff_sequent", "tff_formula_tuple", "tff_formula_tuple_list",
	"tff_typed_atom", "tff_subtype", "tff_top_level_type", "tf1_quantified_type",
	"tff_monotype", "tff_unitary_type", "tff_atomic_type", "tff_type_arguments",
	"tff_mapping_type", "tff_xprod_type", "tcf_formula", "tcf_logic_formula",
	"tcf_quantified_formula", "fof_formula", "fof_logic_formula", "fof_binary_formula",
	"fof_binary_nonassoc", "fof_binary_assoc", "fof_or_formula", "fof_and_formula",
	"fof_unitary_formula", "fof_quantified_formula", "fof_variable_list", "fof_unary_formula",
	"fof_infix_unary", "fof_atomic_formula", "fof_plain_atomic_formula", "fof_defined_atomic_formula",
	"fof_defined_plain_formula", "fof_defined_infix_formula", "fof_system_atomic_formula",
	"fof_plain_term", "fof_defined_term", "fof_defined_atomic_term", "fof_defined_plain_term",
	"fof_system_term", "fof_arguments", "fof_term", "fof_function_term", "tff_conditional_term",
	"tff_let_term", "tff_tuple_term", "fof_sequent", "fof_formula_tuple", "fof_formula_tuple_list",
	"cnf_formula", "cnf_disjunction", "cnf_literal", "thf_quantifier", "th0_quantifier",
	"th1_quantifier", "thf_pair_connective", "thf_unary_connective", "th1_unary_connective",
	"tff_pair_connective", "fof_quantifier", "binary_connective", "assoc_connective",
	"unary_connective", "type_constant", "type_functor", "defined_type", "system_type",
	"atom", "untyped_atom", "defined_proposition", "defined_predicate", "defined_infix_pred",
	"constant", "functor", "system_constant", "system_functor", "defined_constant",
	"defined_functor", "defined_term", "variable", "source", "sources", "dag_source",
	"inference_record", "inference_rule", "inference_parents", "parent_list",
	"parent_info", "parent_details", "internal_source", "intro_type", "external_source",
	"file_source", "file_info", "theory", "theory_name", "creator_source",
	"creator_name", "optional_info", "useful_info", "info_items", "info_item",
	"formula_item", "description_item", "iquote_item", "inference_item", "inference_status",
	"status_value", "inference_info", "assumptions_record", "refutation", "new_symbol_record",
	"new_symbol_list", "principal_symbol", "include", "formula_selection",
	"name_list", "general_term", "general_data", "general_function", "formula_data",
	"general_list", "general_terms", "name", "atomic_word", "atomic_defined_word",
	"atomic_system_word", "number", "file_name",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type tptp_v7_0_0_0Parser struct {
	*antlr.BaseParser
}

func Newtptp_v7_0_0_0Parser(input antlr.TokenStream) *tptp_v7_0_0_0Parser {
	this := new(tptp_v7_0_0_0Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "tptp_v7_0_0_0.g4"

	return this
}

// tptp_v7_0_0_0Parser tokens.
const (
	tptp_v7_0_0_0ParserEOF                  = antlr.TokenEOF
	tptp_v7_0_0_0ParserT__0                 = 1
	tptp_v7_0_0_0ParserT__1                 = 2
	tptp_v7_0_0_0ParserT__2                 = 3
	tptp_v7_0_0_0ParserT__3                 = 4
	tptp_v7_0_0_0ParserT__4                 = 5
	tptp_v7_0_0_0ParserT__5                 = 6
	tptp_v7_0_0_0ParserT__6                 = 7
	tptp_v7_0_0_0ParserT__7                 = 8
	tptp_v7_0_0_0ParserT__8                 = 9
	tptp_v7_0_0_0ParserT__9                 = 10
	tptp_v7_0_0_0ParserT__10                = 11
	tptp_v7_0_0_0ParserT__11                = 12
	tptp_v7_0_0_0ParserT__12                = 13
	tptp_v7_0_0_0ParserT__13                = 14
	tptp_v7_0_0_0ParserT__14                = 15
	tptp_v7_0_0_0ParserT__15                = 16
	tptp_v7_0_0_0ParserT__16                = 17
	tptp_v7_0_0_0ParserT__17                = 18
	tptp_v7_0_0_0ParserT__18                = 19
	tptp_v7_0_0_0ParserT__19                = 20
	tptp_v7_0_0_0ParserT__20                = 21
	tptp_v7_0_0_0ParserT__21                = 22
	tptp_v7_0_0_0ParserT__22                = 23
	tptp_v7_0_0_0ParserT__23                = 24
	tptp_v7_0_0_0ParserT__24                = 25
	tptp_v7_0_0_0ParserT__25                = 26
	tptp_v7_0_0_0ParserT__26                = 27
	tptp_v7_0_0_0ParserT__27                = 28
	tptp_v7_0_0_0ParserT__28                = 29
	tptp_v7_0_0_0ParserT__29                = 30
	tptp_v7_0_0_0ParserT__30                = 31
	tptp_v7_0_0_0ParserT__31                = 32
	tptp_v7_0_0_0ParserT__32                = 33
	tptp_v7_0_0_0ParserT__33                = 34
	tptp_v7_0_0_0ParserT__34                = 35
	tptp_v7_0_0_0ParserT__35                = 36
	tptp_v7_0_0_0ParserT__36                = 37
	tptp_v7_0_0_0ParserT__37                = 38
	tptp_v7_0_0_0ParserT__38                = 39
	tptp_v7_0_0_0ParserT__39                = 40
	tptp_v7_0_0_0ParserT__40                = 41
	tptp_v7_0_0_0ParserT__41                = 42
	tptp_v7_0_0_0ParserT__42                = 43
	tptp_v7_0_0_0ParserOr                   = 44
	tptp_v7_0_0_0ParserAnd                  = 45
	tptp_v7_0_0_0ParserIff                  = 46
	tptp_v7_0_0_0ParserImpl                 = 47
	tptp_v7_0_0_0ParserIf                   = 48
	tptp_v7_0_0_0ParserNiff                 = 49
	tptp_v7_0_0_0ParserNor                  = 50
	tptp_v7_0_0_0ParserNand                 = 51
	tptp_v7_0_0_0ParserNot                  = 52
	tptp_v7_0_0_0ParserForallComb           = 53
	tptp_v7_0_0_0ParserTyForall             = 54
	tptp_v7_0_0_0ParserInfix_inequality     = 55
	tptp_v7_0_0_0ParserInfix_equality       = 56
	tptp_v7_0_0_0ParserForall               = 57
	tptp_v7_0_0_0ParserExistsComb           = 58
	tptp_v7_0_0_0ParserTyExists             = 59
	tptp_v7_0_0_0ParserExists               = 60
	tptp_v7_0_0_0ParserLambda               = 61
	tptp_v7_0_0_0ParserChoiceComb           = 62
	tptp_v7_0_0_0ParserChoice               = 63
	tptp_v7_0_0_0ParserDescriptionComb      = 64
	tptp_v7_0_0_0ParserDescription          = 65
	tptp_v7_0_0_0ParserEqComb               = 66
	tptp_v7_0_0_0ParserApp                  = 67
	tptp_v7_0_0_0ParserAssignment           = 68
	tptp_v7_0_0_0ParserArrow                = 69
	tptp_v7_0_0_0ParserStar                 = 70
	tptp_v7_0_0_0ParserPlus                 = 71
	tptp_v7_0_0_0ParserSubtype_sign         = 72
	tptp_v7_0_0_0ParserGentzen_arrow        = 73
	tptp_v7_0_0_0ParserReal                 = 74
	tptp_v7_0_0_0ParserSigned_real          = 75
	tptp_v7_0_0_0ParserUnsigned_real        = 76
	tptp_v7_0_0_0ParserRational             = 77
	tptp_v7_0_0_0ParserSigned_rational      = 78
	tptp_v7_0_0_0ParserUnsigned_rational    = 79
	tptp_v7_0_0_0ParserInteger              = 80
	tptp_v7_0_0_0ParserSigned_integer       = 81
	tptp_v7_0_0_0ParserUnsigned_integer     = 82
	tptp_v7_0_0_0ParserDecimal              = 83
	tptp_v7_0_0_0ParserPositive_decimal     = 84
	tptp_v7_0_0_0ParserDecimal_exponent     = 85
	tptp_v7_0_0_0ParserDecimal_fraction     = 86
	tptp_v7_0_0_0ParserDot_decimal          = 87
	tptp_v7_0_0_0ParserExp_integer          = 88
	tptp_v7_0_0_0ParserSigned_exp_integer   = 89
	tptp_v7_0_0_0ParserUnsigned_exp_integer = 90
	tptp_v7_0_0_0ParserDollar_word          = 91
	tptp_v7_0_0_0ParserDollar_dollar_word   = 92
	tptp_v7_0_0_0ParserUpper_word           = 93
	tptp_v7_0_0_0ParserLower_word           = 94
	tptp_v7_0_0_0ParserSingle_quoted        = 95
	tptp_v7_0_0_0ParserDistinct_object      = 96
	tptp_v7_0_0_0ParserWS                   = 97
	tptp_v7_0_0_0ParserLine_comment         = 98
	tptp_v7_0_0_0ParserBlock_comment        = 99
)

// tptp_v7_0_0_0Parser rules.
const (
	tptp_v7_0_0_0ParserRULE_tptp_file                  = 0
	tptp_v7_0_0_0ParserRULE_tptp_input                 = 1
	tptp_v7_0_0_0ParserRULE_annotated_formula          = 2
	tptp_v7_0_0_0ParserRULE_tpi_annotated              = 3
	tptp_v7_0_0_0ParserRULE_tpi_formula                = 4
	tptp_v7_0_0_0ParserRULE_thf_annotated              = 5
	tptp_v7_0_0_0ParserRULE_tfx_annotated              = 6
	tptp_v7_0_0_0ParserRULE_tff_annotated              = 7
	tptp_v7_0_0_0ParserRULE_tcf_annotated              = 8
	tptp_v7_0_0_0ParserRULE_fof_annotated              = 9
	tptp_v7_0_0_0ParserRULE_cnf_annotated              = 10
	tptp_v7_0_0_0ParserRULE_annotations                = 11
	tptp_v7_0_0_0ParserRULE_formula_role               = 12
	tptp_v7_0_0_0ParserRULE_thf_formula                = 13
	tptp_v7_0_0_0ParserRULE_thf_logic_formula          = 14
	tptp_v7_0_0_0ParserRULE_thf_binary_formula         = 15
	tptp_v7_0_0_0ParserRULE_thf_binary_pair            = 16
	tptp_v7_0_0_0ParserRULE_thf_binary_tuple           = 17
	tptp_v7_0_0_0ParserRULE_thf_or_formula             = 18
	tptp_v7_0_0_0ParserRULE_thf_and_formula            = 19
	tptp_v7_0_0_0ParserRULE_thf_apply_formula          = 20
	tptp_v7_0_0_0ParserRULE_thf_unitary_formula        = 21
	tptp_v7_0_0_0ParserRULE_thf_quantified_formula     = 22
	tptp_v7_0_0_0ParserRULE_thf_quantification         = 23
	tptp_v7_0_0_0ParserRULE_thf_variable_list          = 24
	tptp_v7_0_0_0ParserRULE_thf_variable               = 25
	tptp_v7_0_0_0ParserRULE_thf_typed_variable         = 26
	tptp_v7_0_0_0ParserRULE_thf_unary_formula          = 27
	tptp_v7_0_0_0ParserRULE_thf_atom                   = 28
	tptp_v7_0_0_0ParserRULE_thf_function               = 29
	tptp_v7_0_0_0ParserRULE_thf_conn_term              = 30
	tptp_v7_0_0_0ParserRULE_thf_conditional            = 31
	tptp_v7_0_0_0ParserRULE_thf_let                    = 32
	tptp_v7_0_0_0ParserRULE_thf_arguments              = 33
	tptp_v7_0_0_0ParserRULE_thf_type_formula           = 34
	tptp_v7_0_0_0ParserRULE_thf_typeable_formula       = 35
	tptp_v7_0_0_0ParserRULE_thf_subtype                = 36
	tptp_v7_0_0_0ParserRULE_thf_top_level_type         = 37
	tptp_v7_0_0_0ParserRULE_thf_unitary_type           = 38
	tptp_v7_0_0_0ParserRULE_thf_apply_type             = 39
	tptp_v7_0_0_0ParserRULE_thf_binary_type            = 40
	tptp_v7_0_0_0ParserRULE_thf_mapping_type           = 41
	tptp_v7_0_0_0ParserRULE_thf_xprod_type             = 42
	tptp_v7_0_0_0ParserRULE_thf_union_type             = 43
	tptp_v7_0_0_0ParserRULE_thf_sequent                = 44
	tptp_v7_0_0_0ParserRULE_thf_tuple                  = 45
	tptp_v7_0_0_0ParserRULE_thf_formula_list           = 46
	tptp_v7_0_0_0ParserRULE_tfx_formula                = 47
	tptp_v7_0_0_0ParserRULE_tfx_logic_formula          = 48
	tptp_v7_0_0_0ParserRULE_tff_formula                = 49
	tptp_v7_0_0_0ParserRULE_tff_logic_formula          = 50
	tptp_v7_0_0_0ParserRULE_tff_binary_formula         = 51
	tptp_v7_0_0_0ParserRULE_tff_binary_nonassoc        = 52
	tptp_v7_0_0_0ParserRULE_tff_binary_assoc           = 53
	tptp_v7_0_0_0ParserRULE_tff_or_formula             = 54
	tptp_v7_0_0_0ParserRULE_tff_and_formula            = 55
	tptp_v7_0_0_0ParserRULE_tff_unitary_formula        = 56
	tptp_v7_0_0_0ParserRULE_tff_quantified_formula     = 57
	tptp_v7_0_0_0ParserRULE_tff_variable_list          = 58
	tptp_v7_0_0_0ParserRULE_tff_variable               = 59
	tptp_v7_0_0_0ParserRULE_tff_typed_variable         = 60
	tptp_v7_0_0_0ParserRULE_tff_unary_formula          = 61
	tptp_v7_0_0_0ParserRULE_tff_atomic_formula         = 62
	tptp_v7_0_0_0ParserRULE_tff_conditional            = 63
	tptp_v7_0_0_0ParserRULE_tff_let                    = 64
	tptp_v7_0_0_0ParserRULE_tff_let_term_defns         = 65
	tptp_v7_0_0_0ParserRULE_tff_let_term_list          = 66
	tptp_v7_0_0_0ParserRULE_tff_let_term_defn          = 67
	tptp_v7_0_0_0ParserRULE_tff_let_term_binding       = 68
	tptp_v7_0_0_0ParserRULE_tff_let_formula_defns      = 69
	tptp_v7_0_0_0ParserRULE_tff_let_formula_list       = 70
	tptp_v7_0_0_0ParserRULE_tff_let_formula_defn       = 71
	tptp_v7_0_0_0ParserRULE_tff_let_formula_binding    = 72
	tptp_v7_0_0_0ParserRULE_tff_sequent                = 73
	tptp_v7_0_0_0ParserRULE_tff_formula_tuple          = 74
	tptp_v7_0_0_0ParserRULE_tff_formula_tuple_list     = 75
	tptp_v7_0_0_0ParserRULE_tff_typed_atom             = 76
	tptp_v7_0_0_0ParserRULE_tff_subtype                = 77
	tptp_v7_0_0_0ParserRULE_tff_top_level_type         = 78
	tptp_v7_0_0_0ParserRULE_tf1_quantified_type        = 79
	tptp_v7_0_0_0ParserRULE_tff_monotype               = 80
	tptp_v7_0_0_0ParserRULE_tff_unitary_type           = 81
	tptp_v7_0_0_0ParserRULE_tff_atomic_type            = 82
	tptp_v7_0_0_0ParserRULE_tff_type_arguments         = 83
	tptp_v7_0_0_0ParserRULE_tff_mapping_type           = 84
	tptp_v7_0_0_0ParserRULE_tff_xprod_type             = 85
	tptp_v7_0_0_0ParserRULE_tcf_formula                = 86
	tptp_v7_0_0_0ParserRULE_tcf_logic_formula          = 87
	tptp_v7_0_0_0ParserRULE_tcf_quantified_formula     = 88
	tptp_v7_0_0_0ParserRULE_fof_formula                = 89
	tptp_v7_0_0_0ParserRULE_fof_logic_formula          = 90
	tptp_v7_0_0_0ParserRULE_fof_binary_formula         = 91
	tptp_v7_0_0_0ParserRULE_fof_binary_nonassoc        = 92
	tptp_v7_0_0_0ParserRULE_fof_binary_assoc           = 93
	tptp_v7_0_0_0ParserRULE_fof_or_formula             = 94
	tptp_v7_0_0_0ParserRULE_fof_and_formula            = 95
	tptp_v7_0_0_0ParserRULE_fof_unitary_formula        = 96
	tptp_v7_0_0_0ParserRULE_fof_quantified_formula     = 97
	tptp_v7_0_0_0ParserRULE_fof_variable_list          = 98
	tptp_v7_0_0_0ParserRULE_fof_unary_formula          = 99
	tptp_v7_0_0_0ParserRULE_fof_infix_unary            = 100
	tptp_v7_0_0_0ParserRULE_fof_atomic_formula         = 101
	tptp_v7_0_0_0ParserRULE_fof_plain_atomic_formula   = 102
	tptp_v7_0_0_0ParserRULE_fof_defined_atomic_formula = 103
	tptp_v7_0_0_0ParserRULE_fof_defined_plain_formula  = 104
	tptp_v7_0_0_0ParserRULE_fof_defined_infix_formula  = 105
	tptp_v7_0_0_0ParserRULE_fof_system_atomic_formula  = 106
	tptp_v7_0_0_0ParserRULE_fof_plain_term             = 107
	tptp_v7_0_0_0ParserRULE_fof_defined_term           = 108
	tptp_v7_0_0_0ParserRULE_fof_defined_atomic_term    = 109
	tptp_v7_0_0_0ParserRULE_fof_defined_plain_term     = 110
	tptp_v7_0_0_0ParserRULE_fof_system_term            = 111
	tptp_v7_0_0_0ParserRULE_fof_arguments              = 112
	tptp_v7_0_0_0ParserRULE_fof_term                   = 113
	tptp_v7_0_0_0ParserRULE_fof_function_term          = 114
	tptp_v7_0_0_0ParserRULE_tff_conditional_term       = 115
	tptp_v7_0_0_0ParserRULE_tff_let_term               = 116
	tptp_v7_0_0_0ParserRULE_tff_tuple_term             = 117
	tptp_v7_0_0_0ParserRULE_fof_sequent                = 118
	tptp_v7_0_0_0ParserRULE_fof_formula_tuple          = 119
	tptp_v7_0_0_0ParserRULE_fof_formula_tuple_list     = 120
	tptp_v7_0_0_0ParserRULE_cnf_formula                = 121
	tptp_v7_0_0_0ParserRULE_cnf_disjunction            = 122
	tptp_v7_0_0_0ParserRULE_cnf_literal                = 123
	tptp_v7_0_0_0ParserRULE_thf_quantifier             = 124
	tptp_v7_0_0_0ParserRULE_th0_quantifier             = 125
	tptp_v7_0_0_0ParserRULE_th1_quantifier             = 126
	tptp_v7_0_0_0ParserRULE_thf_pair_connective        = 127
	tptp_v7_0_0_0ParserRULE_thf_unary_connective       = 128
	tptp_v7_0_0_0ParserRULE_th1_unary_connective       = 129
	tptp_v7_0_0_0ParserRULE_tff_pair_connective        = 130
	tptp_v7_0_0_0ParserRULE_fof_quantifier             = 131
	tptp_v7_0_0_0ParserRULE_binary_connective          = 132
	tptp_v7_0_0_0ParserRULE_assoc_connective           = 133
	tptp_v7_0_0_0ParserRULE_unary_connective           = 134
	tptp_v7_0_0_0ParserRULE_type_constant              = 135
	tptp_v7_0_0_0ParserRULE_type_functor               = 136
	tptp_v7_0_0_0ParserRULE_defined_type               = 137
	tptp_v7_0_0_0ParserRULE_system_type                = 138
	tptp_v7_0_0_0ParserRULE_atom                       = 139
	tptp_v7_0_0_0ParserRULE_untyped_atom               = 140
	tptp_v7_0_0_0ParserRULE_defined_proposition        = 141
	tptp_v7_0_0_0ParserRULE_defined_predicate          = 142
	tptp_v7_0_0_0ParserRULE_defined_infix_pred         = 143
	tptp_v7_0_0_0ParserRULE_constant                   = 144
	tptp_v7_0_0_0ParserRULE_functor                    = 145
	tptp_v7_0_0_0ParserRULE_system_constant            = 146
	tptp_v7_0_0_0ParserRULE_system_functor             = 147
	tptp_v7_0_0_0ParserRULE_defined_constant           = 148
	tptp_v7_0_0_0ParserRULE_defined_functor            = 149
	tptp_v7_0_0_0ParserRULE_defined_term               = 150
	tptp_v7_0_0_0ParserRULE_variable                   = 151
	tptp_v7_0_0_0ParserRULE_source                     = 152
	tptp_v7_0_0_0ParserRULE_sources                    = 153
	tptp_v7_0_0_0ParserRULE_dag_source                 = 154
	tptp_v7_0_0_0ParserRULE_inference_record           = 155
	tptp_v7_0_0_0ParserRULE_inference_rule             = 156
	tptp_v7_0_0_0ParserRULE_inference_parents          = 157
	tptp_v7_0_0_0ParserRULE_parent_list                = 158
	tptp_v7_0_0_0ParserRULE_parent_info                = 159
	tptp_v7_0_0_0ParserRULE_parent_details             = 160
	tptp_v7_0_0_0ParserRULE_internal_source            = 161
	tptp_v7_0_0_0ParserRULE_intro_type                 = 162
	tptp_v7_0_0_0ParserRULE_external_source            = 163
	tptp_v7_0_0_0ParserRULE_file_source                = 164
	tptp_v7_0_0_0ParserRULE_file_info                  = 165
	tptp_v7_0_0_0ParserRULE_theory                     = 166
	tptp_v7_0_0_0ParserRULE_theory_name                = 167
	tptp_v7_0_0_0ParserRULE_creator_source             = 168
	tptp_v7_0_0_0ParserRULE_creator_name               = 169
	tptp_v7_0_0_0ParserRULE_optional_info              = 170
	tptp_v7_0_0_0ParserRULE_useful_info                = 171
	tptp_v7_0_0_0ParserRULE_info_items                 = 172
	tptp_v7_0_0_0ParserRULE_info_item                  = 173
	tptp_v7_0_0_0ParserRULE_formula_item               = 174
	tptp_v7_0_0_0ParserRULE_description_item           = 175
	tptp_v7_0_0_0ParserRULE_iquote_item                = 176
	tptp_v7_0_0_0ParserRULE_inference_item             = 177
	tptp_v7_0_0_0ParserRULE_inference_status           = 178
	tptp_v7_0_0_0ParserRULE_status_value               = 179
	tptp_v7_0_0_0ParserRULE_inference_info             = 180
	tptp_v7_0_0_0ParserRULE_assumptions_record         = 181
	tptp_v7_0_0_0ParserRULE_refutation                 = 182
	tptp_v7_0_0_0ParserRULE_new_symbol_record          = 183
	tptp_v7_0_0_0ParserRULE_new_symbol_list            = 184
	tptp_v7_0_0_0ParserRULE_principal_symbol           = 185
	tptp_v7_0_0_0ParserRULE_include                    = 186
	tptp_v7_0_0_0ParserRULE_formula_selection          = 187
	tptp_v7_0_0_0ParserRULE_name_list                  = 188
	tptp_v7_0_0_0ParserRULE_general_term               = 189
	tptp_v7_0_0_0ParserRULE_general_data               = 190
	tptp_v7_0_0_0ParserRULE_general_function           = 191
	tptp_v7_0_0_0ParserRULE_formula_data               = 192
	tptp_v7_0_0_0ParserRULE_general_list               = 193
	tptp_v7_0_0_0ParserRULE_general_terms              = 194
	tptp_v7_0_0_0ParserRULE_name                       = 195
	tptp_v7_0_0_0ParserRULE_atomic_word                = 196
	tptp_v7_0_0_0ParserRULE_atomic_defined_word        = 197
	tptp_v7_0_0_0ParserRULE_atomic_system_word         = 198
	tptp_v7_0_0_0ParserRULE_number                     = 199
	tptp_v7_0_0_0ParserRULE_file_name                  = 200
)

// ITptp_fileContext is an interface to support dynamic dispatch.
type ITptp_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTptp_fileContext differentiates from other interfaces.
	IsTptp_fileContext()
}

type Tptp_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTptp_fileContext() *Tptp_fileContext {
	var p = new(Tptp_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tptp_file
	return p
}

func (*Tptp_fileContext) IsTptp_fileContext() {}

func NewTptp_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tptp_fileContext {
	var p = new(Tptp_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tptp_file

	return p
}

func (s *Tptp_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Tptp_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserEOF, 0)
}

func (s *Tptp_fileContext) AllTptp_input() []ITptp_inputContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITptp_inputContext)(nil)).Elem())
	var tst = make([]ITptp_inputContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITptp_inputContext)
		}
	}

	return tst
}

func (s *Tptp_fileContext) Tptp_input(i int) ITptp_inputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITptp_inputContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITptp_inputContext)
}

func (s *Tptp_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tptp_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tptp_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTptp_file(s)
	}
}

func (s *Tptp_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTptp_file(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tptp_file() (localctx ITptp_fileContext) {
	localctx = NewTptp_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, tptp_v7_0_0_0ParserRULE_tptp_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<tptp_v7_0_0_0ParserT__0)|(1<<tptp_v7_0_0_0ParserT__3)|(1<<tptp_v7_0_0_0ParserT__4)|(1<<tptp_v7_0_0_0ParserT__5)|(1<<tptp_v7_0_0_0ParserT__6)|(1<<tptp_v7_0_0_0ParserT__7)|(1<<tptp_v7_0_0_0ParserT__8))) != 0) || _la == tptp_v7_0_0_0ParserT__37 {
		{
			p.SetState(402)
			p.Tptp_input()
		}

		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(408)
		p.Match(tptp_v7_0_0_0ParserEOF)
	}

	return localctx
}

// ITptp_inputContext is an interface to support dynamic dispatch.
type ITptp_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTptp_inputContext differentiates from other interfaces.
	IsTptp_inputContext()
}

type Tptp_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTptp_inputContext() *Tptp_inputContext {
	var p = new(Tptp_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tptp_input
	return p
}

func (*Tptp_inputContext) IsTptp_inputContext() {}

func NewTptp_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tptp_inputContext {
	var p = new(Tptp_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tptp_input

	return p
}

func (s *Tptp_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Tptp_inputContext) Annotated_formula() IAnnotated_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotated_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotated_formulaContext)
}

func (s *Tptp_inputContext) Include() IIncludeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncludeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncludeContext)
}

func (s *Tptp_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tptp_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tptp_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTptp_input(s)
	}
}

func (s *Tptp_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTptp_input(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tptp_input() (localctx ITptp_inputContext) {
	localctx = NewTptp_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, tptp_v7_0_0_0ParserRULE_tptp_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(412)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__0, tptp_v7_0_0_0ParserT__3, tptp_v7_0_0_0ParserT__4, tptp_v7_0_0_0ParserT__5, tptp_v7_0_0_0ParserT__6, tptp_v7_0_0_0ParserT__7, tptp_v7_0_0_0ParserT__8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(410)
			p.Annotated_formula()
		}

	case tptp_v7_0_0_0ParserT__37:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(411)
			p.Include()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotated_formulaContext is an interface to support dynamic dispatch.
type IAnnotated_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotated_formulaContext differentiates from other interfaces.
	IsAnnotated_formulaContext()
}

type Annotated_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotated_formulaContext() *Annotated_formulaContext {
	var p = new(Annotated_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_annotated_formula
	return p
}

func (*Annotated_formulaContext) IsAnnotated_formulaContext() {}

func NewAnnotated_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotated_formulaContext {
	var p = new(Annotated_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_annotated_formula

	return p
}

func (s *Annotated_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotated_formulaContext) Thf_annotated() IThf_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_annotatedContext)
}

func (s *Annotated_formulaContext) Tfx_annotated() ITfx_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfx_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfx_annotatedContext)
}

func (s *Annotated_formulaContext) Tff_annotated() ITff_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_annotatedContext)
}

func (s *Annotated_formulaContext) Tcf_annotated() ITcf_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITcf_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITcf_annotatedContext)
}

func (s *Annotated_formulaContext) Fof_annotated() IFof_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_annotatedContext)
}

func (s *Annotated_formulaContext) Cnf_annotated() ICnf_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_annotatedContext)
}

func (s *Annotated_formulaContext) Tpi_annotated() ITpi_annotatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITpi_annotatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITpi_annotatedContext)
}

func (s *Annotated_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotated_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotated_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAnnotated_formula(s)
	}
}

func (s *Annotated_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAnnotated_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Annotated_formula() (localctx IAnnotated_formulaContext) {
	localctx = NewAnnotated_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, tptp_v7_0_0_0ParserRULE_annotated_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(421)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)
			p.Thf_annotated()
		}

	case tptp_v7_0_0_0ParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)
			p.Tfx_annotated()
		}

	case tptp_v7_0_0_0ParserT__5:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(416)
			p.Tff_annotated()
		}

	case tptp_v7_0_0_0ParserT__6:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(417)
			p.Tcf_annotated()
		}

	case tptp_v7_0_0_0ParserT__7:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(418)
			p.Fof_annotated()
		}

	case tptp_v7_0_0_0ParserT__8:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(419)
			p.Cnf_annotated()
		}

	case tptp_v7_0_0_0ParserT__0:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(420)
			p.Tpi_annotated()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITpi_annotatedContext is an interface to support dynamic dispatch.
type ITpi_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTpi_annotatedContext differentiates from other interfaces.
	IsTpi_annotatedContext()
}

type Tpi_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTpi_annotatedContext() *Tpi_annotatedContext {
	var p = new(Tpi_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tpi_annotated
	return p
}

func (*Tpi_annotatedContext) IsTpi_annotatedContext() {}

func NewTpi_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tpi_annotatedContext {
	var p = new(Tpi_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tpi_annotated

	return p
}

func (s *Tpi_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Tpi_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Tpi_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Tpi_annotatedContext) Tpi_formula() ITpi_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITpi_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITpi_formulaContext)
}

func (s *Tpi_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Tpi_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tpi_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tpi_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTpi_annotated(s)
	}
}

func (s *Tpi_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTpi_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tpi_annotated() (localctx ITpi_annotatedContext) {
	localctx = NewTpi_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, tptp_v7_0_0_0ParserRULE_tpi_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		p.Match(tptp_v7_0_0_0ParserT__0)
	}
	{
		p.SetState(424)
		p.Name()
	}
	{
		p.SetState(425)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(426)
		p.Formula_role()
	}
	{
		p.SetState(427)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(428)
		p.Tpi_formula()
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(429)
			p.Annotations()
		}

	}
	{
		p.SetState(432)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// ITpi_formulaContext is an interface to support dynamic dispatch.
type ITpi_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTpi_formulaContext differentiates from other interfaces.
	IsTpi_formulaContext()
}

type Tpi_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTpi_formulaContext() *Tpi_formulaContext {
	var p = new(Tpi_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tpi_formula
	return p
}

func (*Tpi_formulaContext) IsTpi_formulaContext() {}

func NewTpi_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tpi_formulaContext {
	var p = new(Tpi_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tpi_formula

	return p
}

func (s *Tpi_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tpi_formulaContext) Fof_formula() IFof_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_formulaContext)
}

func (s *Tpi_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tpi_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tpi_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTpi_formula(s)
	}
}

func (s *Tpi_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTpi_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tpi_formula() (localctx ITpi_formulaContext) {
	localctx = NewTpi_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, tptp_v7_0_0_0ParserRULE_tpi_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		p.Fof_formula()
	}

	return localctx
}

// IThf_annotatedContext is an interface to support dynamic dispatch.
type IThf_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_annotatedContext differentiates from other interfaces.
	IsThf_annotatedContext()
}

type Thf_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_annotatedContext() *Thf_annotatedContext {
	var p = new(Thf_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_annotated
	return p
}

func (*Thf_annotatedContext) IsThf_annotatedContext() {}

func NewThf_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_annotatedContext {
	var p = new(Thf_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_annotated

	return p
}

func (s *Thf_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Thf_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Thf_annotatedContext) Thf_formula() IThf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_formulaContext)
}

func (s *Thf_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Thf_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_annotated(s)
	}
}

func (s *Thf_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_annotated() (localctx IThf_annotatedContext) {
	localctx = NewThf_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, tptp_v7_0_0_0ParserRULE_thf_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Match(tptp_v7_0_0_0ParserT__3)
	}
	{
		p.SetState(437)
		p.Name()
	}
	{
		p.SetState(438)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(439)
		p.Formula_role()
	}
	{
		p.SetState(440)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(441)
		p.Thf_formula()
	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(442)
			p.Annotations()
		}

	}
	{
		p.SetState(445)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// ITfx_annotatedContext is an interface to support dynamic dispatch.
type ITfx_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfx_annotatedContext differentiates from other interfaces.
	IsTfx_annotatedContext()
}

type Tfx_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfx_annotatedContext() *Tfx_annotatedContext {
	var p = new(Tfx_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tfx_annotated
	return p
}

func (*Tfx_annotatedContext) IsTfx_annotatedContext() {}

func NewTfx_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfx_annotatedContext {
	var p = new(Tfx_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tfx_annotated

	return p
}

func (s *Tfx_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfx_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Tfx_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Tfx_annotatedContext) Tfx_formula() ITfx_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfx_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfx_formulaContext)
}

func (s *Tfx_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Tfx_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfx_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfx_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTfx_annotated(s)
	}
}

func (s *Tfx_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTfx_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tfx_annotated() (localctx ITfx_annotatedContext) {
	localctx = NewTfx_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, tptp_v7_0_0_0ParserRULE_tfx_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(tptp_v7_0_0_0ParserT__4)
	}
	{
		p.SetState(448)
		p.Name()
	}
	{
		p.SetState(449)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(450)
		p.Formula_role()
	}
	{
		p.SetState(451)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(452)
		p.Tfx_formula()
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(453)
			p.Annotations()
		}

	}
	{
		p.SetState(456)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// ITff_annotatedContext is an interface to support dynamic dispatch.
type ITff_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_annotatedContext differentiates from other interfaces.
	IsTff_annotatedContext()
}

type Tff_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_annotatedContext() *Tff_annotatedContext {
	var p = new(Tff_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_annotated
	return p
}

func (*Tff_annotatedContext) IsTff_annotatedContext() {}

func NewTff_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_annotatedContext {
	var p = new(Tff_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_annotated

	return p
}

func (s *Tff_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Tff_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Tff_annotatedContext) Tff_formula() ITff_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_formulaContext)
}

func (s *Tff_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Tff_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_annotated(s)
	}
}

func (s *Tff_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_annotated() (localctx ITff_annotatedContext) {
	localctx = NewTff_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, tptp_v7_0_0_0ParserRULE_tff_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(tptp_v7_0_0_0ParserT__5)
	}
	{
		p.SetState(459)
		p.Name()
	}
	{
		p.SetState(460)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(461)
		p.Formula_role()
	}
	{
		p.SetState(462)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(463)
		p.Tff_formula()
	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(464)
			p.Annotations()
		}

	}
	{
		p.SetState(467)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// ITcf_annotatedContext is an interface to support dynamic dispatch.
type ITcf_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTcf_annotatedContext differentiates from other interfaces.
	IsTcf_annotatedContext()
}

type Tcf_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTcf_annotatedContext() *Tcf_annotatedContext {
	var p = new(Tcf_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_annotated
	return p
}

func (*Tcf_annotatedContext) IsTcf_annotatedContext() {}

func NewTcf_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tcf_annotatedContext {
	var p = new(Tcf_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_annotated

	return p
}

func (s *Tcf_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Tcf_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Tcf_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Tcf_annotatedContext) Tcf_formula() ITcf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITcf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITcf_formulaContext)
}

func (s *Tcf_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Tcf_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tcf_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tcf_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTcf_annotated(s)
	}
}

func (s *Tcf_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTcf_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tcf_annotated() (localctx ITcf_annotatedContext) {
	localctx = NewTcf_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, tptp_v7_0_0_0ParserRULE_tcf_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(tptp_v7_0_0_0ParserT__6)
	}
	{
		p.SetState(470)
		p.Name()
	}
	{
		p.SetState(471)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(472)
		p.Formula_role()
	}
	{
		p.SetState(473)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(474)
		p.Tcf_formula()
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(475)
			p.Annotations()
		}

	}
	{
		p.SetState(478)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// IFof_annotatedContext is an interface to support dynamic dispatch.
type IFof_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_annotatedContext differentiates from other interfaces.
	IsFof_annotatedContext()
}

type Fof_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_annotatedContext() *Fof_annotatedContext {
	var p = new(Fof_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_annotated
	return p
}

func (*Fof_annotatedContext) IsFof_annotatedContext() {}

func NewFof_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_annotatedContext {
	var p = new(Fof_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_annotated

	return p
}

func (s *Fof_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Fof_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Fof_annotatedContext) Fof_formula() IFof_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_formulaContext)
}

func (s *Fof_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Fof_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_annotated(s)
	}
}

func (s *Fof_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_annotated() (localctx IFof_annotatedContext) {
	localctx = NewFof_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, tptp_v7_0_0_0ParserRULE_fof_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		p.Match(tptp_v7_0_0_0ParserT__7)
	}
	{
		p.SetState(481)
		p.Name()
	}
	{
		p.SetState(482)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(483)
		p.Formula_role()
	}
	{
		p.SetState(484)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(485)
		p.Fof_formula()
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(486)
			p.Annotations()
		}

	}
	{
		p.SetState(489)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// ICnf_annotatedContext is an interface to support dynamic dispatch.
type ICnf_annotatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCnf_annotatedContext differentiates from other interfaces.
	IsCnf_annotatedContext()
}

type Cnf_annotatedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCnf_annotatedContext() *Cnf_annotatedContext {
	var p = new(Cnf_annotatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_annotated
	return p
}

func (*Cnf_annotatedContext) IsCnf_annotatedContext() {}

func NewCnf_annotatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cnf_annotatedContext {
	var p = new(Cnf_annotatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_annotated

	return p
}

func (s *Cnf_annotatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Cnf_annotatedContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Cnf_annotatedContext) Formula_role() IFormula_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_roleContext)
}

func (s *Cnf_annotatedContext) Cnf_formula() ICnf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_formulaContext)
}

func (s *Cnf_annotatedContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Cnf_annotatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cnf_annotatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cnf_annotatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterCnf_annotated(s)
	}
}

func (s *Cnf_annotatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitCnf_annotated(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Cnf_annotated() (localctx ICnf_annotatedContext) {
	localctx = NewCnf_annotatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, tptp_v7_0_0_0ParserRULE_cnf_annotated)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(tptp_v7_0_0_0ParserT__8)
	}
	{
		p.SetState(492)
		p.Name()
	}
	{
		p.SetState(493)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(494)
		p.Formula_role()
	}
	{
		p.SetState(495)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(496)
		p.Cnf_formula()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(497)
			p.Annotations()
		}

	}
	{
		p.SetState(500)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) Source() ISourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceContext)
}

func (s *AnnotationsContext) Optional_info() IOptional_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptional_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptional_infoContext)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, tptp_v7_0_0_0ParserRULE_annotations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(503)
		p.Source()
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(504)
			p.Optional_info()
		}

	}

	return localctx
}

// IFormula_roleContext is an interface to support dynamic dispatch.
type IFormula_roleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormula_roleContext differentiates from other interfaces.
	IsFormula_roleContext()
}

type Formula_roleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormula_roleContext() *Formula_roleContext {
	var p = new(Formula_roleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_role
	return p
}

func (*Formula_roleContext) IsFormula_roleContext() {}

func NewFormula_roleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formula_roleContext {
	var p = new(Formula_roleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_role

	return p
}

func (s *Formula_roleContext) GetParser() antlr.Parser { return s.parser }

func (s *Formula_roleContext) Lower_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLower_word, 0)
}

func (s *Formula_roleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formula_roleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formula_roleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFormula_role(s)
	}
}

func (s *Formula_roleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFormula_role(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Formula_role() (localctx IFormula_roleContext) {
	localctx = NewFormula_roleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, tptp_v7_0_0_0ParserRULE_formula_role)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Match(tptp_v7_0_0_0ParserLower_word)
	}

	return localctx
}

// IThf_formulaContext is an interface to support dynamic dispatch.
type IThf_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_formulaContext differentiates from other interfaces.
	IsThf_formulaContext()
}

type Thf_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_formulaContext() *Thf_formulaContext {
	var p = new(Thf_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_formula
	return p
}

func (*Thf_formulaContext) IsThf_formulaContext() {}

func NewThf_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_formulaContext {
	var p = new(Thf_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_formula

	return p
}

func (s *Thf_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_formulaContext) Thf_logic_formula() IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Thf_formulaContext) Thf_sequent() IThf_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_sequentContext)
}

func (s *Thf_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_formula(s)
	}
}

func (s *Thf_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_formula() (localctx IThf_formulaContext) {
	localctx = NewThf_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, tptp_v7_0_0_0ParserRULE_thf_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(509)
			p.Thf_logic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(510)
			p.Thf_sequent()
		}

	}

	return localctx
}

// IThf_logic_formulaContext is an interface to support dynamic dispatch.
type IThf_logic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_logic_formulaContext differentiates from other interfaces.
	IsThf_logic_formulaContext()
}

type Thf_logic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_logic_formulaContext() *Thf_logic_formulaContext {
	var p = new(Thf_logic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_logic_formula
	return p
}

func (*Thf_logic_formulaContext) IsThf_logic_formulaContext() {}

func NewThf_logic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_logic_formulaContext {
	var p = new(Thf_logic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_logic_formula

	return p
}

func (s *Thf_logic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_logic_formulaContext) Thf_binary_formula() IThf_binary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_binary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_binary_formulaContext)
}

func (s *Thf_logic_formulaContext) Thf_unitary_formula() IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_logic_formulaContext) Thf_type_formula() IThf_type_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_type_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_type_formulaContext)
}

func (s *Thf_logic_formulaContext) Thf_subtype() IThf_subtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_subtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_subtypeContext)
}

func (s *Thf_logic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_logic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_logic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_logic_formula(s)
	}
}

func (s *Thf_logic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_logic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_logic_formula() (localctx IThf_logic_formulaContext) {
	localctx = NewThf_logic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, tptp_v7_0_0_0ParserRULE_thf_logic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(513)
			p.Thf_binary_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(514)
			p.Thf_unitary_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(515)
			p.Thf_type_formula()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(516)
			p.Thf_subtype()
		}

	}

	return localctx
}

// IThf_binary_formulaContext is an interface to support dynamic dispatch.
type IThf_binary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_binary_formulaContext differentiates from other interfaces.
	IsThf_binary_formulaContext()
}

type Thf_binary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_binary_formulaContext() *Thf_binary_formulaContext {
	var p = new(Thf_binary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_formula
	return p
}

func (*Thf_binary_formulaContext) IsThf_binary_formulaContext() {}

func NewThf_binary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_binary_formulaContext {
	var p = new(Thf_binary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_formula

	return p
}

func (s *Thf_binary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_binary_formulaContext) Thf_binary_pair() IThf_binary_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_binary_pairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_binary_pairContext)
}

func (s *Thf_binary_formulaContext) Thf_binary_tuple() IThf_binary_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_binary_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_binary_tupleContext)
}

func (s *Thf_binary_formulaContext) Thf_binary_type() IThf_binary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_binary_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_binary_typeContext)
}

func (s *Thf_binary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_binary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_binary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_binary_formula(s)
	}
}

func (s *Thf_binary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_binary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_binary_formula() (localctx IThf_binary_formulaContext) {
	localctx = NewThf_binary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, tptp_v7_0_0_0ParserRULE_thf_binary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.Thf_binary_pair()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(520)
			p.Thf_binary_tuple()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(521)
			p.Thf_binary_type()
		}

	}

	return localctx
}

// IThf_binary_pairContext is an interface to support dynamic dispatch.
type IThf_binary_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_binary_pairContext differentiates from other interfaces.
	IsThf_binary_pairContext()
}

type Thf_binary_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_binary_pairContext() *Thf_binary_pairContext {
	var p = new(Thf_binary_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_pair
	return p
}

func (*Thf_binary_pairContext) IsThf_binary_pairContext() {}

func NewThf_binary_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_binary_pairContext {
	var p = new(Thf_binary_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_pair

	return p
}

func (s *Thf_binary_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_binary_pairContext) AllThf_unitary_formula() []IThf_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IThf_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Thf_binary_pairContext) Thf_unitary_formula(i int) IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_binary_pairContext) Thf_pair_connective() IThf_pair_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_pair_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_pair_connectiveContext)
}

func (s *Thf_binary_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_binary_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_binary_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_binary_pair(s)
	}
}

func (s *Thf_binary_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_binary_pair(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_binary_pair() (localctx IThf_binary_pairContext) {
	localctx = NewThf_binary_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, tptp_v7_0_0_0ParserRULE_thf_binary_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Thf_unitary_formula()
	}
	{
		p.SetState(525)
		p.Thf_pair_connective()
	}
	{
		p.SetState(526)
		p.Thf_unitary_formula()
	}

	return localctx
}

// IThf_binary_tupleContext is an interface to support dynamic dispatch.
type IThf_binary_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_binary_tupleContext differentiates from other interfaces.
	IsThf_binary_tupleContext()
}

type Thf_binary_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_binary_tupleContext() *Thf_binary_tupleContext {
	var p = new(Thf_binary_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_tuple
	return p
}

func (*Thf_binary_tupleContext) IsThf_binary_tupleContext() {}

func NewThf_binary_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_binary_tupleContext {
	var p = new(Thf_binary_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_tuple

	return p
}

func (s *Thf_binary_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_binary_tupleContext) Thf_or_formula() IThf_or_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_or_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_or_formulaContext)
}

func (s *Thf_binary_tupleContext) Thf_and_formula() IThf_and_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_and_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_and_formulaContext)
}

func (s *Thf_binary_tupleContext) Thf_apply_formula() IThf_apply_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_apply_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_apply_formulaContext)
}

func (s *Thf_binary_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_binary_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_binary_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_binary_tuple(s)
	}
}

func (s *Thf_binary_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_binary_tuple(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_binary_tuple() (localctx IThf_binary_tupleContext) {
	localctx = NewThf_binary_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, tptp_v7_0_0_0ParserRULE_thf_binary_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(528)
			p.thf_or_formula(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(529)
			p.thf_and_formula(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(530)
			p.thf_apply_formula(0)
		}

	}

	return localctx
}

// IThf_or_formulaContext is an interface to support dynamic dispatch.
type IThf_or_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_or_formulaContext differentiates from other interfaces.
	IsThf_or_formulaContext()
}

type Thf_or_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_or_formulaContext() *Thf_or_formulaContext {
	var p = new(Thf_or_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_or_formula
	return p
}

func (*Thf_or_formulaContext) IsThf_or_formulaContext() {}

func NewThf_or_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_or_formulaContext {
	var p = new(Thf_or_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_or_formula

	return p
}

func (s *Thf_or_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_or_formulaContext) AllThf_unitary_formula() []IThf_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IThf_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Thf_or_formulaContext) Thf_unitary_formula(i int) IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_or_formulaContext) Or() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserOr, 0)
}

func (s *Thf_or_formulaContext) Thf_or_formula() IThf_or_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_or_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_or_formulaContext)
}

func (s *Thf_or_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_or_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_or_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_or_formula(s)
	}
}

func (s *Thf_or_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_or_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_or_formula() (localctx IThf_or_formulaContext) {
	return p.thf_or_formula(0)
}

func (p *tptp_v7_0_0_0Parser) thf_or_formula(_p int) (localctx IThf_or_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewThf_or_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IThf_or_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 36
	p.EnterRecursionRule(localctx, 36, tptp_v7_0_0_0ParserRULE_thf_or_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Thf_unitary_formula()
	}
	{
		p.SetState(535)
		p.Match(tptp_v7_0_0_0ParserOr)
	}
	{
		p.SetState(536)
		p.Thf_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewThf_or_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_thf_or_formula)
			p.SetState(538)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(539)
				p.Match(tptp_v7_0_0_0ParserOr)
			}
			{
				p.SetState(540)
				p.Thf_unitary_formula()
			}

		}
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
	}

	return localctx
}

// IThf_and_formulaContext is an interface to support dynamic dispatch.
type IThf_and_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_and_formulaContext differentiates from other interfaces.
	IsThf_and_formulaContext()
}

type Thf_and_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_and_formulaContext() *Thf_and_formulaContext {
	var p = new(Thf_and_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_and_formula
	return p
}

func (*Thf_and_formulaContext) IsThf_and_formulaContext() {}

func NewThf_and_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_and_formulaContext {
	var p = new(Thf_and_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_and_formula

	return p
}

func (s *Thf_and_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_and_formulaContext) AllThf_unitary_formula() []IThf_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IThf_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Thf_and_formulaContext) Thf_unitary_formula(i int) IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_and_formulaContext) And() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAnd, 0)
}

func (s *Thf_and_formulaContext) Thf_and_formula() IThf_and_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_and_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_and_formulaContext)
}

func (s *Thf_and_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_and_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_and_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_and_formula(s)
	}
}

func (s *Thf_and_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_and_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_and_formula() (localctx IThf_and_formulaContext) {
	return p.thf_and_formula(0)
}

func (p *tptp_v7_0_0_0Parser) thf_and_formula(_p int) (localctx IThf_and_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewThf_and_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IThf_and_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 38
	p.EnterRecursionRule(localctx, 38, tptp_v7_0_0_0ParserRULE_thf_and_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.Thf_unitary_formula()
	}
	{
		p.SetState(548)
		p.Match(tptp_v7_0_0_0ParserAnd)
	}
	{
		p.SetState(549)
		p.Thf_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewThf_and_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_thf_and_formula)
			p.SetState(551)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(552)
				p.Match(tptp_v7_0_0_0ParserAnd)
			}
			{
				p.SetState(553)
				p.Thf_unitary_formula()
			}

		}
		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IThf_apply_formulaContext is an interface to support dynamic dispatch.
type IThf_apply_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_apply_formulaContext differentiates from other interfaces.
	IsThf_apply_formulaContext()
}

type Thf_apply_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_apply_formulaContext() *Thf_apply_formulaContext {
	var p = new(Thf_apply_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_apply_formula
	return p
}

func (*Thf_apply_formulaContext) IsThf_apply_formulaContext() {}

func NewThf_apply_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_apply_formulaContext {
	var p = new(Thf_apply_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_apply_formula

	return p
}

func (s *Thf_apply_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_apply_formulaContext) AllThf_unitary_formula() []IThf_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IThf_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Thf_apply_formulaContext) Thf_unitary_formula(i int) IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_apply_formulaContext) App() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserApp, 0)
}

func (s *Thf_apply_formulaContext) Thf_apply_formula() IThf_apply_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_apply_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_apply_formulaContext)
}

func (s *Thf_apply_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_apply_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_apply_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_apply_formula(s)
	}
}

func (s *Thf_apply_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_apply_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_apply_formula() (localctx IThf_apply_formulaContext) {
	return p.thf_apply_formula(0)
}

func (p *tptp_v7_0_0_0Parser) thf_apply_formula(_p int) (localctx IThf_apply_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewThf_apply_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IThf_apply_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, tptp_v7_0_0_0ParserRULE_thf_apply_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Thf_unitary_formula()
	}
	{
		p.SetState(561)
		p.Match(tptp_v7_0_0_0ParserApp)
	}
	{
		p.SetState(562)
		p.Thf_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewThf_apply_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_thf_apply_formula)
			p.SetState(564)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(565)
				p.Match(tptp_v7_0_0_0ParserApp)
			}
			{
				p.SetState(566)
				p.Thf_unitary_formula()
			}

		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}

	return localctx
}

// IThf_unitary_formulaContext is an interface to support dynamic dispatch.
type IThf_unitary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_unitary_formulaContext differentiates from other interfaces.
	IsThf_unitary_formulaContext()
}

type Thf_unitary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_unitary_formulaContext() *Thf_unitary_formulaContext {
	var p = new(Thf_unitary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unitary_formula
	return p
}

func (*Thf_unitary_formulaContext) IsThf_unitary_formulaContext() {}

func NewThf_unitary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_unitary_formulaContext {
	var p = new(Thf_unitary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unitary_formula

	return p
}

func (s *Thf_unitary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_unitary_formulaContext) Thf_quantified_formula() IThf_quantified_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_quantified_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_quantified_formulaContext)
}

func (s *Thf_unitary_formulaContext) Thf_unary_formula() IThf_unary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unary_formulaContext)
}

func (s *Thf_unitary_formulaContext) Thf_atom() IThf_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_atomContext)
}

func (s *Thf_unitary_formulaContext) Thf_conditional() IThf_conditionalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_conditionalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_conditionalContext)
}

func (s *Thf_unitary_formulaContext) Thf_let() IThf_letContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_letContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_letContext)
}

func (s *Thf_unitary_formulaContext) Thf_tuple() IThf_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_tupleContext)
}

func (s *Thf_unitary_formulaContext) Thf_logic_formula() IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Thf_unitary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_unitary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_unitary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_unitary_formula(s)
	}
}

func (s *Thf_unitary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_unitary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_unitary_formula() (localctx IThf_unitary_formulaContext) {
	localctx = NewThf_unitary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, tptp_v7_0_0_0ParserRULE_thf_unitary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(572)
			p.Thf_quantified_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(573)
			p.Thf_unary_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(574)
			p.Thf_atom()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(575)
			p.Thf_conditional()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(576)
			p.Thf_let()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(577)
			p.Thf_tuple()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(578)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(579)
			p.Thf_logic_formula()
		}
		{
			p.SetState(580)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// IThf_quantified_formulaContext is an interface to support dynamic dispatch.
type IThf_quantified_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_quantified_formulaContext differentiates from other interfaces.
	IsThf_quantified_formulaContext()
}

type Thf_quantified_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_quantified_formulaContext() *Thf_quantified_formulaContext {
	var p = new(Thf_quantified_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_quantified_formula
	return p
}

func (*Thf_quantified_formulaContext) IsThf_quantified_formulaContext() {}

func NewThf_quantified_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_quantified_formulaContext {
	var p = new(Thf_quantified_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_quantified_formula

	return p
}

func (s *Thf_quantified_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_quantified_formulaContext) Thf_quantification() IThf_quantificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_quantificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_quantificationContext)
}

func (s *Thf_quantified_formulaContext) Thf_unitary_formula() IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_quantified_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_quantified_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_quantified_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_quantified_formula(s)
	}
}

func (s *Thf_quantified_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_quantified_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_quantified_formula() (localctx IThf_quantified_formulaContext) {
	localctx = NewThf_quantified_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, tptp_v7_0_0_0ParserRULE_thf_quantified_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Thf_quantification()
	}
	{
		p.SetState(585)
		p.Thf_unitary_formula()
	}

	return localctx
}

// IThf_quantificationContext is an interface to support dynamic dispatch.
type IThf_quantificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_quantificationContext differentiates from other interfaces.
	IsThf_quantificationContext()
}

type Thf_quantificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_quantificationContext() *Thf_quantificationContext {
	var p = new(Thf_quantificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_quantification
	return p
}

func (*Thf_quantificationContext) IsThf_quantificationContext() {}

func NewThf_quantificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_quantificationContext {
	var p = new(Thf_quantificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_quantification

	return p
}

func (s *Thf_quantificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_quantificationContext) Thf_quantifier() IThf_quantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_quantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_quantifierContext)
}

func (s *Thf_quantificationContext) Thf_variable_list() IThf_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_variable_listContext)
}

func (s *Thf_quantificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_quantificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_quantificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_quantification(s)
	}
}

func (s *Thf_quantificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_quantification(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_quantification() (localctx IThf_quantificationContext) {
	localctx = NewThf_quantificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, tptp_v7_0_0_0ParserRULE_thf_quantification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Thf_quantifier()
	}
	{
		p.SetState(588)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(589)
		p.Thf_variable_list()
	}
	{
		p.SetState(590)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(591)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}

	return localctx
}

// IThf_variable_listContext is an interface to support dynamic dispatch.
type IThf_variable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_variable_listContext differentiates from other interfaces.
	IsThf_variable_listContext()
}

type Thf_variable_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_variable_listContext() *Thf_variable_listContext {
	var p = new(Thf_variable_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_variable_list
	return p
}

func (*Thf_variable_listContext) IsThf_variable_listContext() {}

func NewThf_variable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_variable_listContext {
	var p = new(Thf_variable_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_variable_list

	return p
}

func (s *Thf_variable_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_variable_listContext) AllThf_variable() []IThf_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_variableContext)(nil)).Elem())
	var tst = make([]IThf_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_variableContext)
		}
	}

	return tst
}

func (s *Thf_variable_listContext) Thf_variable(i int) IThf_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_variableContext)
}

func (s *Thf_variable_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_variable_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_variable_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_variable_list(s)
	}
}

func (s *Thf_variable_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_variable_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_variable_list() (localctx IThf_variable_listContext) {
	localctx = NewThf_variable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, tptp_v7_0_0_0ParserRULE_thf_variable_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)
		p.Thf_variable()
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(594)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(595)
			p.Thf_variable()
		}

		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IThf_variableContext is an interface to support dynamic dispatch.
type IThf_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_variableContext differentiates from other interfaces.
	IsThf_variableContext()
}

type Thf_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_variableContext() *Thf_variableContext {
	var p = new(Thf_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_variable
	return p
}

func (*Thf_variableContext) IsThf_variableContext() {}

func NewThf_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_variableContext {
	var p = new(Thf_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_variable

	return p
}

func (s *Thf_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_variableContext) Thf_typed_variable() IThf_typed_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_typed_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_typed_variableContext)
}

func (s *Thf_variableContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Thf_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_variable(s)
	}
}

func (s *Thf_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_variable(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_variable() (localctx IThf_variableContext) {
	localctx = NewThf_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, tptp_v7_0_0_0ParserRULE_thf_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(601)
			p.Thf_typed_variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(602)
			p.Variable()
		}

	}

	return localctx
}

// IThf_typed_variableContext is an interface to support dynamic dispatch.
type IThf_typed_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_typed_variableContext differentiates from other interfaces.
	IsThf_typed_variableContext()
}

type Thf_typed_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_typed_variableContext() *Thf_typed_variableContext {
	var p = new(Thf_typed_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_typed_variable
	return p
}

func (*Thf_typed_variableContext) IsThf_typed_variableContext() {}

func NewThf_typed_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_typed_variableContext {
	var p = new(Thf_typed_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_typed_variable

	return p
}

func (s *Thf_typed_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_typed_variableContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Thf_typed_variableContext) Thf_top_level_type() IThf_top_level_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_top_level_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_top_level_typeContext)
}

func (s *Thf_typed_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_typed_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_typed_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_typed_variable(s)
	}
}

func (s *Thf_typed_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_typed_variable(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_typed_variable() (localctx IThf_typed_variableContext) {
	localctx = NewThf_typed_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, tptp_v7_0_0_0ParserRULE_thf_typed_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Variable()
	}
	{
		p.SetState(606)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(607)
		p.Thf_top_level_type()
	}

	return localctx
}

// IThf_unary_formulaContext is an interface to support dynamic dispatch.
type IThf_unary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_unary_formulaContext differentiates from other interfaces.
	IsThf_unary_formulaContext()
}

type Thf_unary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_unary_formulaContext() *Thf_unary_formulaContext {
	var p = new(Thf_unary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unary_formula
	return p
}

func (*Thf_unary_formulaContext) IsThf_unary_formulaContext() {}

func NewThf_unary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_unary_formulaContext {
	var p = new(Thf_unary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unary_formula

	return p
}

func (s *Thf_unary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_unary_formulaContext) Thf_unary_connective() IThf_unary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unary_connectiveContext)
}

func (s *Thf_unary_formulaContext) Thf_logic_formula() IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Thf_unary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_unary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_unary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_unary_formula(s)
	}
}

func (s *Thf_unary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_unary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_unary_formula() (localctx IThf_unary_formulaContext) {
	localctx = NewThf_unary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, tptp_v7_0_0_0ParserRULE_thf_unary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		p.Thf_unary_connective()
	}
	{
		p.SetState(610)
		p.Match(tptp_v7_0_0_0ParserT__9)
	}
	{
		p.SetState(611)
		p.Thf_logic_formula()
	}
	{
		p.SetState(612)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IThf_atomContext is an interface to support dynamic dispatch.
type IThf_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_atomContext differentiates from other interfaces.
	IsThf_atomContext()
}

type Thf_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_atomContext() *Thf_atomContext {
	var p = new(Thf_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_atom
	return p
}

func (*Thf_atomContext) IsThf_atomContext() {}

func NewThf_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_atomContext {
	var p = new(Thf_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_atom

	return p
}

func (s *Thf_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_atomContext) Thf_function() IThf_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_functionContext)
}

func (s *Thf_atomContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Thf_atomContext) Defined_term() IDefined_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_termContext)
}

func (s *Thf_atomContext) Thf_conn_term() IThf_conn_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_conn_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_conn_termContext)
}

func (s *Thf_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_atom(s)
	}
}

func (s *Thf_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_atom(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_atom() (localctx IThf_atomContext) {
	localctx = NewThf_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, tptp_v7_0_0_0ParserRULE_thf_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(618)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(614)
			p.Thf_function()
		}

	case tptp_v7_0_0_0ParserUpper_word:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(615)
			p.Variable()
		}

	case tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(616)
			p.Defined_term()
		}

	case tptp_v7_0_0_0ParserOr, tptp_v7_0_0_0ParserAnd, tptp_v7_0_0_0ParserIff, tptp_v7_0_0_0ParserImpl, tptp_v7_0_0_0ParserIf, tptp_v7_0_0_0ParserNiff, tptp_v7_0_0_0ParserNor, tptp_v7_0_0_0ParserNand, tptp_v7_0_0_0ParserNot, tptp_v7_0_0_0ParserForallComb, tptp_v7_0_0_0ParserInfix_inequality, tptp_v7_0_0_0ParserInfix_equality, tptp_v7_0_0_0ParserExistsComb, tptp_v7_0_0_0ParserChoiceComb, tptp_v7_0_0_0ParserDescriptionComb, tptp_v7_0_0_0ParserEqComb, tptp_v7_0_0_0ParserAssignment:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(617)
			p.Thf_conn_term()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IThf_functionContext is an interface to support dynamic dispatch.
type IThf_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_functionContext differentiates from other interfaces.
	IsThf_functionContext()
}

type Thf_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_functionContext() *Thf_functionContext {
	var p = new(Thf_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_function
	return p
}

func (*Thf_functionContext) IsThf_functionContext() {}

func NewThf_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_functionContext {
	var p = new(Thf_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_function

	return p
}

func (s *Thf_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_functionContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Thf_functionContext) Functor() IFunctorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctorContext)
}

func (s *Thf_functionContext) Thf_arguments() IThf_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_argumentsContext)
}

func (s *Thf_functionContext) Defined_functor() IDefined_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_functorContext)
}

func (s *Thf_functionContext) System_functor() ISystem_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_functorContext)
}

func (s *Thf_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_function(s)
	}
}

func (s *Thf_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_function(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_function() (localctx IThf_functionContext) {
	localctx = NewThf_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, tptp_v7_0_0_0ParserRULE_thf_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.Atom()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(621)
			p.Functor()
		}
		{
			p.SetState(622)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(623)
			p.Thf_arguments()
		}
		{
			p.SetState(624)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(626)
			p.Defined_functor()
		}
		{
			p.SetState(627)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(628)
			p.Thf_arguments()
		}
		{
			p.SetState(629)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(631)
			p.System_functor()
		}
		{
			p.SetState(632)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(633)
			p.Thf_arguments()
		}
		{
			p.SetState(634)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// IThf_conn_termContext is an interface to support dynamic dispatch.
type IThf_conn_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_conn_termContext differentiates from other interfaces.
	IsThf_conn_termContext()
}

type Thf_conn_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_conn_termContext() *Thf_conn_termContext {
	var p = new(Thf_conn_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_conn_term
	return p
}

func (*Thf_conn_termContext) IsThf_conn_termContext() {}

func NewThf_conn_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_conn_termContext {
	var p = new(Thf_conn_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_conn_term

	return p
}

func (s *Thf_conn_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_conn_termContext) Thf_pair_connective() IThf_pair_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_pair_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_pair_connectiveContext)
}

func (s *Thf_conn_termContext) Assoc_connective() IAssoc_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssoc_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssoc_connectiveContext)
}

func (s *Thf_conn_termContext) Thf_unary_connective() IThf_unary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unary_connectiveContext)
}

func (s *Thf_conn_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_conn_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_conn_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_conn_term(s)
	}
}

func (s *Thf_conn_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_conn_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_conn_term() (localctx IThf_conn_termContext) {
	localctx = NewThf_conn_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, tptp_v7_0_0_0ParserRULE_thf_conn_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(641)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserIff, tptp_v7_0_0_0ParserImpl, tptp_v7_0_0_0ParserIf, tptp_v7_0_0_0ParserNiff, tptp_v7_0_0_0ParserNor, tptp_v7_0_0_0ParserNand, tptp_v7_0_0_0ParserInfix_inequality, tptp_v7_0_0_0ParserInfix_equality, tptp_v7_0_0_0ParserAssignment:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(638)
			p.Thf_pair_connective()
		}

	case tptp_v7_0_0_0ParserOr, tptp_v7_0_0_0ParserAnd:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)
			p.Assoc_connective()
		}

	case tptp_v7_0_0_0ParserNot, tptp_v7_0_0_0ParserForallComb, tptp_v7_0_0_0ParserExistsComb, tptp_v7_0_0_0ParserChoiceComb, tptp_v7_0_0_0ParserDescriptionComb, tptp_v7_0_0_0ParserEqComb:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(640)
			p.Thf_unary_connective()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IThf_conditionalContext is an interface to support dynamic dispatch.
type IThf_conditionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_conditionalContext differentiates from other interfaces.
	IsThf_conditionalContext()
}

type Thf_conditionalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_conditionalContext() *Thf_conditionalContext {
	var p = new(Thf_conditionalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_conditional
	return p
}

func (*Thf_conditionalContext) IsThf_conditionalContext() {}

func NewThf_conditionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_conditionalContext {
	var p = new(Thf_conditionalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_conditional

	return p
}

func (s *Thf_conditionalContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_conditionalContext) AllThf_logic_formula() []IThf_logic_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem())
	var tst = make([]IThf_logic_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_logic_formulaContext)
		}
	}

	return tst
}

func (s *Thf_conditionalContext) Thf_logic_formula(i int) IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Thf_conditionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_conditionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_conditionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_conditional(s)
	}
}

func (s *Thf_conditionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_conditional(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_conditional() (localctx IThf_conditionalContext) {
	localctx = NewThf_conditionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, tptp_v7_0_0_0ParserRULE_thf_conditional)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(tptp_v7_0_0_0ParserT__14)
	}
	{
		p.SetState(644)
		p.Thf_logic_formula()
	}
	{
		p.SetState(645)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(646)
		p.Thf_logic_formula()
	}
	{
		p.SetState(647)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(648)
		p.Thf_logic_formula()
	}
	{
		p.SetState(649)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IThf_letContext is an interface to support dynamic dispatch.
type IThf_letContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_letContext differentiates from other interfaces.
	IsThf_letContext()
}

type Thf_letContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_letContext() *Thf_letContext {
	var p = new(Thf_letContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_let
	return p
}

func (*Thf_letContext) IsThf_letContext() {}

func NewThf_letContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_letContext {
	var p = new(Thf_letContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_let

	return p
}

func (s *Thf_letContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_letContext) Thf_unitary_formula() IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_letContext) Thf_formula() IThf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_formulaContext)
}

func (s *Thf_letContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_letContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_letContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_let(s)
	}
}

func (s *Thf_letContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_let(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_let() (localctx IThf_letContext) {
	localctx = NewThf_letContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, tptp_v7_0_0_0ParserRULE_thf_let)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(tptp_v7_0_0_0ParserT__15)
	}
	{
		p.SetState(652)
		p.Thf_unitary_formula()
	}
	{
		p.SetState(653)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(654)
		p.Thf_formula()
	}
	{
		p.SetState(655)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IThf_argumentsContext is an interface to support dynamic dispatch.
type IThf_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_argumentsContext differentiates from other interfaces.
	IsThf_argumentsContext()
}

type Thf_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_argumentsContext() *Thf_argumentsContext {
	var p = new(Thf_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_arguments
	return p
}

func (*Thf_argumentsContext) IsThf_argumentsContext() {}

func NewThf_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_argumentsContext {
	var p = new(Thf_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_arguments

	return p
}

func (s *Thf_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_argumentsContext) Thf_formula_list() IThf_formula_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_formula_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_formula_listContext)
}

func (s *Thf_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_arguments(s)
	}
}

func (s *Thf_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_arguments(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_arguments() (localctx IThf_argumentsContext) {
	localctx = NewThf_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, tptp_v7_0_0_0ParserRULE_thf_arguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Thf_formula_list()
	}

	return localctx
}

// IThf_type_formulaContext is an interface to support dynamic dispatch.
type IThf_type_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_type_formulaContext differentiates from other interfaces.
	IsThf_type_formulaContext()
}

type Thf_type_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_type_formulaContext() *Thf_type_formulaContext {
	var p = new(Thf_type_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_type_formula
	return p
}

func (*Thf_type_formulaContext) IsThf_type_formulaContext() {}

func NewThf_type_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_type_formulaContext {
	var p = new(Thf_type_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_type_formula

	return p
}

func (s *Thf_type_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_type_formulaContext) Thf_typeable_formula() IThf_typeable_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_typeable_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_typeable_formulaContext)
}

func (s *Thf_type_formulaContext) Thf_top_level_type() IThf_top_level_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_top_level_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_top_level_typeContext)
}

func (s *Thf_type_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_type_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_type_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_type_formula(s)
	}
}

func (s *Thf_type_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_type_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_type_formula() (localctx IThf_type_formulaContext) {
	localctx = NewThf_type_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, tptp_v7_0_0_0ParserRULE_thf_type_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Thf_typeable_formula()
	}
	{
		p.SetState(660)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(661)
		p.Thf_top_level_type()
	}

	return localctx
}

// IThf_typeable_formulaContext is an interface to support dynamic dispatch.
type IThf_typeable_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_typeable_formulaContext differentiates from other interfaces.
	IsThf_typeable_formulaContext()
}

type Thf_typeable_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_typeable_formulaContext() *Thf_typeable_formulaContext {
	var p = new(Thf_typeable_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_typeable_formula
	return p
}

func (*Thf_typeable_formulaContext) IsThf_typeable_formulaContext() {}

func NewThf_typeable_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_typeable_formulaContext {
	var p = new(Thf_typeable_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_typeable_formula

	return p
}

func (s *Thf_typeable_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_typeable_formulaContext) Thf_atom() IThf_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_atomContext)
}

func (s *Thf_typeable_formulaContext) Thf_logic_formula() IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Thf_typeable_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_typeable_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_typeable_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_typeable_formula(s)
	}
}

func (s *Thf_typeable_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_typeable_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_typeable_formula() (localctx IThf_typeable_formulaContext) {
	localctx = NewThf_typeable_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, tptp_v7_0_0_0ParserRULE_thf_typeable_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(668)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserOr, tptp_v7_0_0_0ParserAnd, tptp_v7_0_0_0ParserIff, tptp_v7_0_0_0ParserImpl, tptp_v7_0_0_0ParserIf, tptp_v7_0_0_0ParserNiff, tptp_v7_0_0_0ParserNor, tptp_v7_0_0_0ParserNand, tptp_v7_0_0_0ParserNot, tptp_v7_0_0_0ParserForallComb, tptp_v7_0_0_0ParserInfix_inequality, tptp_v7_0_0_0ParserInfix_equality, tptp_v7_0_0_0ParserExistsComb, tptp_v7_0_0_0ParserChoiceComb, tptp_v7_0_0_0ParserDescriptionComb, tptp_v7_0_0_0ParserEqComb, tptp_v7_0_0_0ParserAssignment, tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(663)
			p.Thf_atom()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(664)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(665)
			p.Thf_logic_formula()
		}
		{
			p.SetState(666)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IThf_subtypeContext is an interface to support dynamic dispatch.
type IThf_subtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_subtypeContext differentiates from other interfaces.
	IsThf_subtypeContext()
}

type Thf_subtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_subtypeContext() *Thf_subtypeContext {
	var p = new(Thf_subtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_subtype
	return p
}

func (*Thf_subtypeContext) IsThf_subtypeContext() {}

func NewThf_subtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_subtypeContext {
	var p = new(Thf_subtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_subtype

	return p
}

func (s *Thf_subtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_subtypeContext) AllThf_atom() []IThf_atomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_atomContext)(nil)).Elem())
	var tst = make([]IThf_atomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_atomContext)
		}
	}

	return tst
}

func (s *Thf_subtypeContext) Thf_atom(i int) IThf_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_atomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_atomContext)
}

func (s *Thf_subtypeContext) Subtype_sign() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserSubtype_sign, 0)
}

func (s *Thf_subtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_subtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_subtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_subtype(s)
	}
}

func (s *Thf_subtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_subtype(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_subtype() (localctx IThf_subtypeContext) {
	localctx = NewThf_subtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, tptp_v7_0_0_0ParserRULE_thf_subtype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Thf_atom()
	}
	{
		p.SetState(671)
		p.Match(tptp_v7_0_0_0ParserSubtype_sign)
	}
	{
		p.SetState(672)
		p.Thf_atom()
	}

	return localctx
}

// IThf_top_level_typeContext is an interface to support dynamic dispatch.
type IThf_top_level_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_top_level_typeContext differentiates from other interfaces.
	IsThf_top_level_typeContext()
}

type Thf_top_level_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_top_level_typeContext() *Thf_top_level_typeContext {
	var p = new(Thf_top_level_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_top_level_type
	return p
}

func (*Thf_top_level_typeContext) IsThf_top_level_typeContext() {}

func NewThf_top_level_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_top_level_typeContext {
	var p = new(Thf_top_level_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_top_level_type

	return p
}

func (s *Thf_top_level_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_top_level_typeContext) Thf_unitary_type() IThf_unitary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_typeContext)
}

func (s *Thf_top_level_typeContext) Thf_mapping_type() IThf_mapping_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_mapping_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_mapping_typeContext)
}

func (s *Thf_top_level_typeContext) Thf_apply_type() IThf_apply_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_apply_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_apply_typeContext)
}

func (s *Thf_top_level_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_top_level_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_top_level_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_top_level_type(s)
	}
}

func (s *Thf_top_level_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_top_level_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_top_level_type() (localctx IThf_top_level_typeContext) {
	localctx = NewThf_top_level_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, tptp_v7_0_0_0ParserRULE_thf_top_level_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(674)
			p.Thf_unitary_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(675)
			p.Thf_mapping_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(676)
			p.Thf_apply_type()
		}

	}

	return localctx
}

// IThf_unitary_typeContext is an interface to support dynamic dispatch.
type IThf_unitary_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_unitary_typeContext differentiates from other interfaces.
	IsThf_unitary_typeContext()
}

type Thf_unitary_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_unitary_typeContext() *Thf_unitary_typeContext {
	var p = new(Thf_unitary_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unitary_type
	return p
}

func (*Thf_unitary_typeContext) IsThf_unitary_typeContext() {}

func NewThf_unitary_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_unitary_typeContext {
	var p = new(Thf_unitary_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unitary_type

	return p
}

func (s *Thf_unitary_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_unitary_typeContext) Thf_unitary_formula() IThf_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_formulaContext)
}

func (s *Thf_unitary_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_unitary_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_unitary_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_unitary_type(s)
	}
}

func (s *Thf_unitary_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_unitary_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_unitary_type() (localctx IThf_unitary_typeContext) {
	localctx = NewThf_unitary_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, tptp_v7_0_0_0ParserRULE_thf_unitary_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Thf_unitary_formula()
	}

	return localctx
}

// IThf_apply_typeContext is an interface to support dynamic dispatch.
type IThf_apply_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_apply_typeContext differentiates from other interfaces.
	IsThf_apply_typeContext()
}

type Thf_apply_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_apply_typeContext() *Thf_apply_typeContext {
	var p = new(Thf_apply_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_apply_type
	return p
}

func (*Thf_apply_typeContext) IsThf_apply_typeContext() {}

func NewThf_apply_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_apply_typeContext {
	var p = new(Thf_apply_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_apply_type

	return p
}

func (s *Thf_apply_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_apply_typeContext) Thf_apply_formula() IThf_apply_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_apply_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_apply_formulaContext)
}

func (s *Thf_apply_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_apply_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_apply_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_apply_type(s)
	}
}

func (s *Thf_apply_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_apply_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_apply_type() (localctx IThf_apply_typeContext) {
	localctx = NewThf_apply_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, tptp_v7_0_0_0ParserRULE_thf_apply_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.thf_apply_formula(0)
	}

	return localctx
}

// IThf_binary_typeContext is an interface to support dynamic dispatch.
type IThf_binary_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_binary_typeContext differentiates from other interfaces.
	IsThf_binary_typeContext()
}

type Thf_binary_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_binary_typeContext() *Thf_binary_typeContext {
	var p = new(Thf_binary_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_type
	return p
}

func (*Thf_binary_typeContext) IsThf_binary_typeContext() {}

func NewThf_binary_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_binary_typeContext {
	var p = new(Thf_binary_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_binary_type

	return p
}

func (s *Thf_binary_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_binary_typeContext) Thf_mapping_type() IThf_mapping_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_mapping_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_mapping_typeContext)
}

func (s *Thf_binary_typeContext) Thf_xprod_type() IThf_xprod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_xprod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_xprod_typeContext)
}

func (s *Thf_binary_typeContext) Thf_union_type() IThf_union_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_union_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_union_typeContext)
}

func (s *Thf_binary_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_binary_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_binary_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_binary_type(s)
	}
}

func (s *Thf_binary_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_binary_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_binary_type() (localctx IThf_binary_typeContext) {
	localctx = NewThf_binary_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, tptp_v7_0_0_0ParserRULE_thf_binary_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(683)
			p.Thf_mapping_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(684)
			p.thf_xprod_type(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(685)
			p.thf_union_type(0)
		}

	}

	return localctx
}

// IThf_mapping_typeContext is an interface to support dynamic dispatch.
type IThf_mapping_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_mapping_typeContext differentiates from other interfaces.
	IsThf_mapping_typeContext()
}

type Thf_mapping_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_mapping_typeContext() *Thf_mapping_typeContext {
	var p = new(Thf_mapping_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_mapping_type
	return p
}

func (*Thf_mapping_typeContext) IsThf_mapping_typeContext() {}

func NewThf_mapping_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_mapping_typeContext {
	var p = new(Thf_mapping_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_mapping_type

	return p
}

func (s *Thf_mapping_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_mapping_typeContext) AllThf_unitary_type() []IThf_unitary_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem())
	var tst = make([]IThf_unitary_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_typeContext)
		}
	}

	return tst
}

func (s *Thf_mapping_typeContext) Thf_unitary_type(i int) IThf_unitary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_typeContext)
}

func (s *Thf_mapping_typeContext) Arrow() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserArrow, 0)
}

func (s *Thf_mapping_typeContext) Thf_mapping_type() IThf_mapping_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_mapping_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_mapping_typeContext)
}

func (s *Thf_mapping_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_mapping_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_mapping_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_mapping_type(s)
	}
}

func (s *Thf_mapping_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_mapping_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_mapping_type() (localctx IThf_mapping_typeContext) {
	localctx = NewThf_mapping_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, tptp_v7_0_0_0ParserRULE_thf_mapping_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(688)
			p.Thf_unitary_type()
		}
		{
			p.SetState(689)
			p.Match(tptp_v7_0_0_0ParserArrow)
		}
		{
			p.SetState(690)
			p.Thf_unitary_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(692)
			p.Thf_unitary_type()
		}
		{
			p.SetState(693)
			p.Match(tptp_v7_0_0_0ParserArrow)
		}
		{
			p.SetState(694)
			p.Thf_mapping_type()
		}

	}

	return localctx
}

// IThf_xprod_typeContext is an interface to support dynamic dispatch.
type IThf_xprod_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_xprod_typeContext differentiates from other interfaces.
	IsThf_xprod_typeContext()
}

type Thf_xprod_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_xprod_typeContext() *Thf_xprod_typeContext {
	var p = new(Thf_xprod_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_xprod_type
	return p
}

func (*Thf_xprod_typeContext) IsThf_xprod_typeContext() {}

func NewThf_xprod_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_xprod_typeContext {
	var p = new(Thf_xprod_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_xprod_type

	return p
}

func (s *Thf_xprod_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_xprod_typeContext) AllThf_unitary_type() []IThf_unitary_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem())
	var tst = make([]IThf_unitary_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_typeContext)
		}
	}

	return tst
}

func (s *Thf_xprod_typeContext) Thf_unitary_type(i int) IThf_unitary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_typeContext)
}

func (s *Thf_xprod_typeContext) Star() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserStar, 0)
}

func (s *Thf_xprod_typeContext) Thf_xprod_type() IThf_xprod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_xprod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_xprod_typeContext)
}

func (s *Thf_xprod_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_xprod_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_xprod_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_xprod_type(s)
	}
}

func (s *Thf_xprod_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_xprod_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_xprod_type() (localctx IThf_xprod_typeContext) {
	return p.thf_xprod_type(0)
}

func (p *tptp_v7_0_0_0Parser) thf_xprod_type(_p int) (localctx IThf_xprod_typeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewThf_xprod_typeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IThf_xprod_typeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 84
	p.EnterRecursionRule(localctx, 84, tptp_v7_0_0_0ParserRULE_thf_xprod_type, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Thf_unitary_type()
	}
	{
		p.SetState(700)
		p.Match(tptp_v7_0_0_0ParserStar)
	}
	{
		p.SetState(701)
		p.Thf_unitary_type()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewThf_xprod_typeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_thf_xprod_type)
			p.SetState(703)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(704)
				p.Match(tptp_v7_0_0_0ParserStar)
			}
			{
				p.SetState(705)
				p.Thf_unitary_type()
			}

		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IThf_union_typeContext is an interface to support dynamic dispatch.
type IThf_union_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_union_typeContext differentiates from other interfaces.
	IsThf_union_typeContext()
}

type Thf_union_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_union_typeContext() *Thf_union_typeContext {
	var p = new(Thf_union_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_union_type
	return p
}

func (*Thf_union_typeContext) IsThf_union_typeContext() {}

func NewThf_union_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_union_typeContext {
	var p = new(Thf_union_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_union_type

	return p
}

func (s *Thf_union_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_union_typeContext) AllThf_unitary_type() []IThf_unitary_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem())
	var tst = make([]IThf_unitary_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_unitary_typeContext)
		}
	}

	return tst
}

func (s *Thf_union_typeContext) Thf_unitary_type(i int) IThf_unitary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_unitary_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_unitary_typeContext)
}

func (s *Thf_union_typeContext) Plus() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserPlus, 0)
}

func (s *Thf_union_typeContext) Thf_union_type() IThf_union_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_union_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_union_typeContext)
}

func (s *Thf_union_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_union_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_union_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_union_type(s)
	}
}

func (s *Thf_union_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_union_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_union_type() (localctx IThf_union_typeContext) {
	return p.thf_union_type(0)
}

func (p *tptp_v7_0_0_0Parser) thf_union_type(_p int) (localctx IThf_union_typeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewThf_union_typeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IThf_union_typeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, tptp_v7_0_0_0ParserRULE_thf_union_type, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Thf_unitary_type()
	}
	{
		p.SetState(713)
		p.Match(tptp_v7_0_0_0ParserPlus)
	}
	{
		p.SetState(714)
		p.Thf_unitary_type()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewThf_union_typeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_thf_union_type)
			p.SetState(716)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(717)
				p.Match(tptp_v7_0_0_0ParserPlus)
			}
			{
				p.SetState(718)
				p.Thf_unitary_type()
			}

		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}

	return localctx
}

// IThf_sequentContext is an interface to support dynamic dispatch.
type IThf_sequentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_sequentContext differentiates from other interfaces.
	IsThf_sequentContext()
}

type Thf_sequentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_sequentContext() *Thf_sequentContext {
	var p = new(Thf_sequentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_sequent
	return p
}

func (*Thf_sequentContext) IsThf_sequentContext() {}

func NewThf_sequentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_sequentContext {
	var p = new(Thf_sequentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_sequent

	return p
}

func (s *Thf_sequentContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_sequentContext) AllThf_tuple() []IThf_tupleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_tupleContext)(nil)).Elem())
	var tst = make([]IThf_tupleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_tupleContext)
		}
	}

	return tst
}

func (s *Thf_sequentContext) Thf_tuple(i int) IThf_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_tupleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_tupleContext)
}

func (s *Thf_sequentContext) Gentzen_arrow() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserGentzen_arrow, 0)
}

func (s *Thf_sequentContext) Thf_sequent() IThf_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_sequentContext)
}

func (s *Thf_sequentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_sequentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_sequentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_sequent(s)
	}
}

func (s *Thf_sequentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_sequent(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_sequent() (localctx IThf_sequentContext) {
	localctx = NewThf_sequentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, tptp_v7_0_0_0ParserRULE_thf_sequent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__11, tptp_v7_0_0_0ParserT__16, tptp_v7_0_0_0ParserT__17, tptp_v7_0_0_0ParserT__18:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(724)
			p.Thf_tuple()
		}
		{
			p.SetState(725)
			p.Match(tptp_v7_0_0_0ParserGentzen_arrow)
		}
		{
			p.SetState(726)
			p.Thf_tuple()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(729)
			p.Thf_sequent()
		}
		{
			p.SetState(730)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IThf_tupleContext is an interface to support dynamic dispatch.
type IThf_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_tupleContext differentiates from other interfaces.
	IsThf_tupleContext()
}

type Thf_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_tupleContext() *Thf_tupleContext {
	var p = new(Thf_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_tuple
	return p
}

func (*Thf_tupleContext) IsThf_tupleContext() {}

func NewThf_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_tupleContext {
	var p = new(Thf_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_tuple

	return p
}

func (s *Thf_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_tupleContext) Thf_formula_list() IThf_formula_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_formula_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_formula_listContext)
}

func (s *Thf_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_tuple(s)
	}
}

func (s *Thf_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_tuple(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_tuple() (localctx IThf_tupleContext) {
	localctx = NewThf_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, tptp_v7_0_0_0ParserRULE_thf_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			p.Match(tptp_v7_0_0_0ParserT__16)
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(736)
			p.Thf_formula_list()
		}
		{
			p.SetState(737)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	case tptp_v7_0_0_0ParserT__17:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(739)
			p.Match(tptp_v7_0_0_0ParserT__17)
		}

	case tptp_v7_0_0_0ParserT__18:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(740)
			p.Match(tptp_v7_0_0_0ParserT__18)
		}
		{
			p.SetState(741)
			p.Thf_formula_list()
		}
		{
			p.SetState(742)
			p.Match(tptp_v7_0_0_0ParserT__19)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IThf_formula_listContext is an interface to support dynamic dispatch.
type IThf_formula_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_formula_listContext differentiates from other interfaces.
	IsThf_formula_listContext()
}

type Thf_formula_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_formula_listContext() *Thf_formula_listContext {
	var p = new(Thf_formula_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_formula_list
	return p
}

func (*Thf_formula_listContext) IsThf_formula_listContext() {}

func NewThf_formula_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_formula_listContext {
	var p = new(Thf_formula_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_formula_list

	return p
}

func (s *Thf_formula_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_formula_listContext) AllThf_logic_formula() []IThf_logic_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem())
	var tst = make([]IThf_logic_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IThf_logic_formulaContext)
		}
	}

	return tst
}

func (s *Thf_formula_listContext) Thf_logic_formula(i int) IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Thf_formula_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_formula_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_formula_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_formula_list(s)
	}
}

func (s *Thf_formula_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_formula_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_formula_list() (localctx IThf_formula_listContext) {
	localctx = NewThf_formula_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, tptp_v7_0_0_0ParserRULE_thf_formula_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Thf_logic_formula()
	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(747)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(748)
			p.Thf_logic_formula()
		}

		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITfx_formulaContext is an interface to support dynamic dispatch.
type ITfx_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfx_formulaContext differentiates from other interfaces.
	IsTfx_formulaContext()
}

type Tfx_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfx_formulaContext() *Tfx_formulaContext {
	var p = new(Tfx_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tfx_formula
	return p
}

func (*Tfx_formulaContext) IsTfx_formulaContext() {}

func NewTfx_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfx_formulaContext {
	var p = new(Tfx_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tfx_formula

	return p
}

func (s *Tfx_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfx_formulaContext) Tfx_logic_formula() ITfx_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfx_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfx_logic_formulaContext)
}

func (s *Tfx_formulaContext) Thf_sequent() IThf_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_sequentContext)
}

func (s *Tfx_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfx_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfx_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTfx_formula(s)
	}
}

func (s *Tfx_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTfx_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tfx_formula() (localctx ITfx_formulaContext) {
	localctx = NewTfx_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, tptp_v7_0_0_0ParserRULE_tfx_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(754)
			p.Tfx_logic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(755)
			p.Thf_sequent()
		}

	}

	return localctx
}

// ITfx_logic_formulaContext is an interface to support dynamic dispatch.
type ITfx_logic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfx_logic_formulaContext differentiates from other interfaces.
	IsTfx_logic_formulaContext()
}

type Tfx_logic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfx_logic_formulaContext() *Tfx_logic_formulaContext {
	var p = new(Tfx_logic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tfx_logic_formula
	return p
}

func (*Tfx_logic_formulaContext) IsTfx_logic_formulaContext() {}

func NewTfx_logic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfx_logic_formulaContext {
	var p = new(Tfx_logic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tfx_logic_formula

	return p
}

func (s *Tfx_logic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfx_logic_formulaContext) Thf_logic_formula() IThf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_logic_formulaContext)
}

func (s *Tfx_logic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfx_logic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfx_logic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTfx_logic_formula(s)
	}
}

func (s *Tfx_logic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTfx_logic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tfx_logic_formula() (localctx ITfx_logic_formulaContext) {
	localctx = NewTfx_logic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, tptp_v7_0_0_0ParserRULE_tfx_logic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Thf_logic_formula()
	}

	return localctx
}

// ITff_formulaContext is an interface to support dynamic dispatch.
type ITff_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_formulaContext differentiates from other interfaces.
	IsTff_formulaContext()
}

type Tff_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_formulaContext() *Tff_formulaContext {
	var p = new(Tff_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_formula
	return p
}

func (*Tff_formulaContext) IsTff_formulaContext() {}

func NewTff_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_formulaContext {
	var p = new(Tff_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_formula

	return p
}

func (s *Tff_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_formulaContext) Tff_logic_formula() ITff_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_logic_formulaContext)
}

func (s *Tff_formulaContext) Tff_typed_atom() ITff_typed_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_typed_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_typed_atomContext)
}

func (s *Tff_formulaContext) Tff_sequent() ITff_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_sequentContext)
}

func (s *Tff_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_formula(s)
	}
}

func (s *Tff_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_formula() (localctx ITff_formulaContext) {
	localctx = NewTff_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, tptp_v7_0_0_0ParserRULE_tff_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(760)
			p.Tff_logic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)
			p.Tff_typed_atom()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(762)
			p.Tff_sequent()
		}

	}

	return localctx
}

// ITff_logic_formulaContext is an interface to support dynamic dispatch.
type ITff_logic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_logic_formulaContext differentiates from other interfaces.
	IsTff_logic_formulaContext()
}

type Tff_logic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_logic_formulaContext() *Tff_logic_formulaContext {
	var p = new(Tff_logic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_logic_formula
	return p
}

func (*Tff_logic_formulaContext) IsTff_logic_formulaContext() {}

func NewTff_logic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_logic_formulaContext {
	var p = new(Tff_logic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_logic_formula

	return p
}

func (s *Tff_logic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_logic_formulaContext) Tff_binary_formula() ITff_binary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_binary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_binary_formulaContext)
}

func (s *Tff_logic_formulaContext) Tff_unitary_formula() ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_logic_formulaContext) Tff_subtype() ITff_subtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_subtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_subtypeContext)
}

func (s *Tff_logic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_logic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_logic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_logic_formula(s)
	}
}

func (s *Tff_logic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_logic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_logic_formula() (localctx ITff_logic_formulaContext) {
	localctx = NewTff_logic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, tptp_v7_0_0_0ParserRULE_tff_logic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(765)
			p.Tff_binary_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(766)
			p.Tff_unitary_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(767)
			p.Tff_subtype()
		}

	}

	return localctx
}

// ITff_binary_formulaContext is an interface to support dynamic dispatch.
type ITff_binary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_binary_formulaContext differentiates from other interfaces.
	IsTff_binary_formulaContext()
}

type Tff_binary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_binary_formulaContext() *Tff_binary_formulaContext {
	var p = new(Tff_binary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_binary_formula
	return p
}

func (*Tff_binary_formulaContext) IsTff_binary_formulaContext() {}

func NewTff_binary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_binary_formulaContext {
	var p = new(Tff_binary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_binary_formula

	return p
}

func (s *Tff_binary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_binary_formulaContext) Tff_binary_nonassoc() ITff_binary_nonassocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_binary_nonassocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_binary_nonassocContext)
}

func (s *Tff_binary_formulaContext) Tff_binary_assoc() ITff_binary_assocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_binary_assocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_binary_assocContext)
}

func (s *Tff_binary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_binary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_binary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_binary_formula(s)
	}
}

func (s *Tff_binary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_binary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_binary_formula() (localctx ITff_binary_formulaContext) {
	localctx = NewTff_binary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, tptp_v7_0_0_0ParserRULE_tff_binary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(770)
			p.Tff_binary_nonassoc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(771)
			p.Tff_binary_assoc()
		}

	}

	return localctx
}

// ITff_binary_nonassocContext is an interface to support dynamic dispatch.
type ITff_binary_nonassocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_binary_nonassocContext differentiates from other interfaces.
	IsTff_binary_nonassocContext()
}

type Tff_binary_nonassocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_binary_nonassocContext() *Tff_binary_nonassocContext {
	var p = new(Tff_binary_nonassocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_binary_nonassoc
	return p
}

func (*Tff_binary_nonassocContext) IsTff_binary_nonassocContext() {}

func NewTff_binary_nonassocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_binary_nonassocContext {
	var p = new(Tff_binary_nonassocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_binary_nonassoc

	return p
}

func (s *Tff_binary_nonassocContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_binary_nonassocContext) AllTff_unitary_formula() []ITff_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem())
	var tst = make([]ITff_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Tff_binary_nonassocContext) Tff_unitary_formula(i int) ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_binary_nonassocContext) Binary_connective() IBinary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_connectiveContext)
}

func (s *Tff_binary_nonassocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_binary_nonassocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_binary_nonassocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_binary_nonassoc(s)
	}
}

func (s *Tff_binary_nonassocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_binary_nonassoc(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_binary_nonassoc() (localctx ITff_binary_nonassocContext) {
	localctx = NewTff_binary_nonassocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, tptp_v7_0_0_0ParserRULE_tff_binary_nonassoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Tff_unitary_formula()
	}
	{
		p.SetState(775)
		p.Binary_connective()
	}
	{
		p.SetState(776)
		p.Tff_unitary_formula()
	}

	return localctx
}

// ITff_binary_assocContext is an interface to support dynamic dispatch.
type ITff_binary_assocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_binary_assocContext differentiates from other interfaces.
	IsTff_binary_assocContext()
}

type Tff_binary_assocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_binary_assocContext() *Tff_binary_assocContext {
	var p = new(Tff_binary_assocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_binary_assoc
	return p
}

func (*Tff_binary_assocContext) IsTff_binary_assocContext() {}

func NewTff_binary_assocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_binary_assocContext {
	var p = new(Tff_binary_assocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_binary_assoc

	return p
}

func (s *Tff_binary_assocContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_binary_assocContext) Tff_or_formula() ITff_or_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_or_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_or_formulaContext)
}

func (s *Tff_binary_assocContext) Tff_and_formula() ITff_and_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_and_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_and_formulaContext)
}

func (s *Tff_binary_assocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_binary_assocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_binary_assocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_binary_assoc(s)
	}
}

func (s *Tff_binary_assocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_binary_assoc(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_binary_assoc() (localctx ITff_binary_assocContext) {
	localctx = NewTff_binary_assocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, tptp_v7_0_0_0ParserRULE_tff_binary_assoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(778)
			p.tff_or_formula(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(779)
			p.tff_and_formula(0)
		}

	}

	return localctx
}

// ITff_or_formulaContext is an interface to support dynamic dispatch.
type ITff_or_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_or_formulaContext differentiates from other interfaces.
	IsTff_or_formulaContext()
}

type Tff_or_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_or_formulaContext() *Tff_or_formulaContext {
	var p = new(Tff_or_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_or_formula
	return p
}

func (*Tff_or_formulaContext) IsTff_or_formulaContext() {}

func NewTff_or_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_or_formulaContext {
	var p = new(Tff_or_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_or_formula

	return p
}

func (s *Tff_or_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_or_formulaContext) AllTff_unitary_formula() []ITff_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem())
	var tst = make([]ITff_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Tff_or_formulaContext) Tff_unitary_formula(i int) ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_or_formulaContext) Or() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserOr, 0)
}

func (s *Tff_or_formulaContext) Tff_or_formula() ITff_or_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_or_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_or_formulaContext)
}

func (s *Tff_or_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_or_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_or_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_or_formula(s)
	}
}

func (s *Tff_or_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_or_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_or_formula() (localctx ITff_or_formulaContext) {
	return p.tff_or_formula(0)
}

func (p *tptp_v7_0_0_0Parser) tff_or_formula(_p int) (localctx ITff_or_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTff_or_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITff_or_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 108
	p.EnterRecursionRule(localctx, 108, tptp_v7_0_0_0ParserRULE_tff_or_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Tff_unitary_formula()
	}
	{
		p.SetState(784)
		p.Match(tptp_v7_0_0_0ParserOr)
	}
	{
		p.SetState(785)
		p.Tff_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTff_or_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_tff_or_formula)
			p.SetState(787)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(788)
				p.Match(tptp_v7_0_0_0ParserOr)
			}
			{
				p.SetState(789)
				p.Tff_unitary_formula()
			}

		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())
	}

	return localctx
}

// ITff_and_formulaContext is an interface to support dynamic dispatch.
type ITff_and_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_and_formulaContext differentiates from other interfaces.
	IsTff_and_formulaContext()
}

type Tff_and_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_and_formulaContext() *Tff_and_formulaContext {
	var p = new(Tff_and_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_and_formula
	return p
}

func (*Tff_and_formulaContext) IsTff_and_formulaContext() {}

func NewTff_and_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_and_formulaContext {
	var p = new(Tff_and_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_and_formula

	return p
}

func (s *Tff_and_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_and_formulaContext) AllTff_unitary_formula() []ITff_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem())
	var tst = make([]ITff_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Tff_and_formulaContext) Tff_unitary_formula(i int) ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_and_formulaContext) And() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAnd, 0)
}

func (s *Tff_and_formulaContext) Tff_and_formula() ITff_and_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_and_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_and_formulaContext)
}

func (s *Tff_and_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_and_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_and_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_and_formula(s)
	}
}

func (s *Tff_and_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_and_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_and_formula() (localctx ITff_and_formulaContext) {
	return p.tff_and_formula(0)
}

func (p *tptp_v7_0_0_0Parser) tff_and_formula(_p int) (localctx ITff_and_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTff_and_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITff_and_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 110
	p.EnterRecursionRule(localctx, 110, tptp_v7_0_0_0ParserRULE_tff_and_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Tff_unitary_formula()
	}
	{
		p.SetState(797)
		p.Match(tptp_v7_0_0_0ParserAnd)
	}
	{
		p.SetState(798)
		p.Tff_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTff_and_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_tff_and_formula)
			p.SetState(800)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(801)
				p.Match(tptp_v7_0_0_0ParserAnd)
			}
			{
				p.SetState(802)
				p.Tff_unitary_formula()
			}

		}
		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// ITff_unitary_formulaContext is an interface to support dynamic dispatch.
type ITff_unitary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_unitary_formulaContext differentiates from other interfaces.
	IsTff_unitary_formulaContext()
}

type Tff_unitary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_unitary_formulaContext() *Tff_unitary_formulaContext {
	var p = new(Tff_unitary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_unitary_formula
	return p
}

func (*Tff_unitary_formulaContext) IsTff_unitary_formulaContext() {}

func NewTff_unitary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_unitary_formulaContext {
	var p = new(Tff_unitary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_unitary_formula

	return p
}

func (s *Tff_unitary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_unitary_formulaContext) Tff_quantified_formula() ITff_quantified_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_quantified_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_quantified_formulaContext)
}

func (s *Tff_unitary_formulaContext) Tff_unary_formula() ITff_unary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unary_formulaContext)
}

func (s *Tff_unitary_formulaContext) Tff_atomic_formula() ITff_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_formulaContext)
}

func (s *Tff_unitary_formulaContext) Tff_conditional() ITff_conditionalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_conditionalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_conditionalContext)
}

func (s *Tff_unitary_formulaContext) Tff_let() ITff_letContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_letContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_letContext)
}

func (s *Tff_unitary_formulaContext) Tff_logic_formula() ITff_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_logic_formulaContext)
}

func (s *Tff_unitary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_unitary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_unitary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_unitary_formula(s)
	}
}

func (s *Tff_unitary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_unitary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_unitary_formula() (localctx ITff_unitary_formulaContext) {
	localctx = NewTff_unitary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, tptp_v7_0_0_0ParserRULE_tff_unitary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(808)
			p.Tff_quantified_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(809)
			p.Tff_unary_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(810)
			p.Tff_atomic_formula()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(811)
			p.Tff_conditional()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(812)
			p.Tff_let()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(813)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(814)
			p.Tff_logic_formula()
		}
		{
			p.SetState(815)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// ITff_quantified_formulaContext is an interface to support dynamic dispatch.
type ITff_quantified_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_quantified_formulaContext differentiates from other interfaces.
	IsTff_quantified_formulaContext()
}

type Tff_quantified_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_quantified_formulaContext() *Tff_quantified_formulaContext {
	var p = new(Tff_quantified_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_quantified_formula
	return p
}

func (*Tff_quantified_formulaContext) IsTff_quantified_formulaContext() {}

func NewTff_quantified_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_quantified_formulaContext {
	var p = new(Tff_quantified_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_quantified_formula

	return p
}

func (s *Tff_quantified_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_quantified_formulaContext) Fof_quantifier() IFof_quantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_quantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_quantifierContext)
}

func (s *Tff_quantified_formulaContext) Tff_variable_list() ITff_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_variable_listContext)
}

func (s *Tff_quantified_formulaContext) Tff_unitary_formula() ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_quantified_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_quantified_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_quantified_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_quantified_formula(s)
	}
}

func (s *Tff_quantified_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_quantified_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_quantified_formula() (localctx ITff_quantified_formulaContext) {
	localctx = NewTff_quantified_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, tptp_v7_0_0_0ParserRULE_tff_quantified_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Fof_quantifier()
	}
	{
		p.SetState(820)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(821)
		p.Tff_variable_list()
	}
	{
		p.SetState(822)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(823)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(824)
		p.Tff_unitary_formula()
	}

	return localctx
}

// ITff_variable_listContext is an interface to support dynamic dispatch.
type ITff_variable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_variable_listContext differentiates from other interfaces.
	IsTff_variable_listContext()
}

type Tff_variable_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_variable_listContext() *Tff_variable_listContext {
	var p = new(Tff_variable_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_variable_list
	return p
}

func (*Tff_variable_listContext) IsTff_variable_listContext() {}

func NewTff_variable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_variable_listContext {
	var p = new(Tff_variable_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_variable_list

	return p
}

func (s *Tff_variable_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_variable_listContext) AllTff_variable() []ITff_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_variableContext)(nil)).Elem())
	var tst = make([]ITff_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_variableContext)
		}
	}

	return tst
}

func (s *Tff_variable_listContext) Tff_variable(i int) ITff_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_variableContext)
}

func (s *Tff_variable_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_variable_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_variable_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_variable_list(s)
	}
}

func (s *Tff_variable_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_variable_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_variable_list() (localctx ITff_variable_listContext) {
	localctx = NewTff_variable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, tptp_v7_0_0_0ParserRULE_tff_variable_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		p.Tff_variable()
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(827)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(828)
			p.Tff_variable()
		}

		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITff_variableContext is an interface to support dynamic dispatch.
type ITff_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_variableContext differentiates from other interfaces.
	IsTff_variableContext()
}

type Tff_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_variableContext() *Tff_variableContext {
	var p = new(Tff_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_variable
	return p
}

func (*Tff_variableContext) IsTff_variableContext() {}

func NewTff_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_variableContext {
	var p = new(Tff_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_variable

	return p
}

func (s *Tff_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_variableContext) Tff_typed_variable() ITff_typed_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_typed_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_typed_variableContext)
}

func (s *Tff_variableContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Tff_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_variable(s)
	}
}

func (s *Tff_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_variable(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_variable() (localctx ITff_variableContext) {
	localctx = NewTff_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, tptp_v7_0_0_0ParserRULE_tff_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(834)
			p.Tff_typed_variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(835)
			p.Variable()
		}

	}

	return localctx
}

// ITff_typed_variableContext is an interface to support dynamic dispatch.
type ITff_typed_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_typed_variableContext differentiates from other interfaces.
	IsTff_typed_variableContext()
}

type Tff_typed_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_typed_variableContext() *Tff_typed_variableContext {
	var p = new(Tff_typed_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_typed_variable
	return p
}

func (*Tff_typed_variableContext) IsTff_typed_variableContext() {}

func NewTff_typed_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_typed_variableContext {
	var p = new(Tff_typed_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_typed_variable

	return p
}

func (s *Tff_typed_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_typed_variableContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Tff_typed_variableContext) Tff_atomic_type() ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_typed_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_typed_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_typed_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_typed_variable(s)
	}
}

func (s *Tff_typed_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_typed_variable(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_typed_variable() (localctx ITff_typed_variableContext) {
	localctx = NewTff_typed_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, tptp_v7_0_0_0ParserRULE_tff_typed_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(838)
		p.Variable()
	}
	{
		p.SetState(839)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(840)
		p.Tff_atomic_type()
	}

	return localctx
}

// ITff_unary_formulaContext is an interface to support dynamic dispatch.
type ITff_unary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_unary_formulaContext differentiates from other interfaces.
	IsTff_unary_formulaContext()
}

type Tff_unary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_unary_formulaContext() *Tff_unary_formulaContext {
	var p = new(Tff_unary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_unary_formula
	return p
}

func (*Tff_unary_formulaContext) IsTff_unary_formulaContext() {}

func NewTff_unary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_unary_formulaContext {
	var p = new(Tff_unary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_unary_formula

	return p
}

func (s *Tff_unary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_unary_formulaContext) Unary_connective() IUnary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_connectiveContext)
}

func (s *Tff_unary_formulaContext) Tff_unitary_formula() ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_unary_formulaContext) Fof_infix_unary() IFof_infix_unaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_infix_unaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_infix_unaryContext)
}

func (s *Tff_unary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_unary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_unary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_unary_formula(s)
	}
}

func (s *Tff_unary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_unary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_unary_formula() (localctx ITff_unary_formulaContext) {
	localctx = NewTff_unary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, tptp_v7_0_0_0ParserRULE_tff_unary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(846)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserNot:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(842)
			p.Unary_connective()
		}
		{
			p.SetState(843)
			p.Tff_unitary_formula()
		}

	case tptp_v7_0_0_0ParserT__17, tptp_v7_0_0_0ParserT__18, tptp_v7_0_0_0ParserT__23, tptp_v7_0_0_0ParserT__24, tptp_v7_0_0_0ParserT__25, tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(845)
			p.Fof_infix_unary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_atomic_formulaContext is an interface to support dynamic dispatch.
type ITff_atomic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_atomic_formulaContext differentiates from other interfaces.
	IsTff_atomic_formulaContext()
}

type Tff_atomic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_atomic_formulaContext() *Tff_atomic_formulaContext {
	var p = new(Tff_atomic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_atomic_formula
	return p
}

func (*Tff_atomic_formulaContext) IsTff_atomic_formulaContext() {}

func NewTff_atomic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_atomic_formulaContext {
	var p = new(Tff_atomic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_atomic_formula

	return p
}

func (s *Tff_atomic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_atomic_formulaContext) Fof_atomic_formula() IFof_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_atomic_formulaContext)
}

func (s *Tff_atomic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_atomic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_atomic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_atomic_formula(s)
	}
}

func (s *Tff_atomic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_atomic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_atomic_formula() (localctx ITff_atomic_formulaContext) {
	localctx = NewTff_atomic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, tptp_v7_0_0_0ParserRULE_tff_atomic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Fof_atomic_formula()
	}

	return localctx
}

// ITff_conditionalContext is an interface to support dynamic dispatch.
type ITff_conditionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_conditionalContext differentiates from other interfaces.
	IsTff_conditionalContext()
}

type Tff_conditionalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_conditionalContext() *Tff_conditionalContext {
	var p = new(Tff_conditionalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_conditional
	return p
}

func (*Tff_conditionalContext) IsTff_conditionalContext() {}

func NewTff_conditionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_conditionalContext {
	var p = new(Tff_conditionalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_conditional

	return p
}

func (s *Tff_conditionalContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_conditionalContext) AllTff_logic_formula() []ITff_logic_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem())
	var tst = make([]ITff_logic_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_logic_formulaContext)
		}
	}

	return tst
}

func (s *Tff_conditionalContext) Tff_logic_formula(i int) ITff_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_logic_formulaContext)
}

func (s *Tff_conditionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_conditionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_conditionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_conditional(s)
	}
}

func (s *Tff_conditionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_conditional(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_conditional() (localctx ITff_conditionalContext) {
	localctx = NewTff_conditionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, tptp_v7_0_0_0ParserRULE_tff_conditional)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(tptp_v7_0_0_0ParserT__20)
	}
	{
		p.SetState(851)
		p.Tff_logic_formula()
	}
	{
		p.SetState(852)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(853)
		p.Tff_logic_formula()
	}
	{
		p.SetState(854)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(855)
		p.Tff_logic_formula()
	}
	{
		p.SetState(856)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// ITff_letContext is an interface to support dynamic dispatch.
type ITff_letContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_letContext differentiates from other interfaces.
	IsTff_letContext()
}

type Tff_letContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_letContext() *Tff_letContext {
	var p = new(Tff_letContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let
	return p
}

func (*Tff_letContext) IsTff_letContext() {}

func NewTff_letContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_letContext {
	var p = new(Tff_letContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let

	return p
}

func (s *Tff_letContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_letContext) Tff_let_term_defns() ITff_let_term_defnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_defnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_defnsContext)
}

func (s *Tff_letContext) Tff_formula() ITff_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_formulaContext)
}

func (s *Tff_letContext) Tff_let_formula_defns() ITff_let_formula_defnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_defnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_defnsContext)
}

func (s *Tff_letContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_letContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_letContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let(s)
	}
}

func (s *Tff_letContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let() (localctx ITff_letContext) {
	localctx = NewTff_letContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, tptp_v7_0_0_0ParserRULE_tff_let)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(870)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__21:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(858)
			p.Match(tptp_v7_0_0_0ParserT__21)
		}
		{
			p.SetState(859)
			p.Tff_let_term_defns()
		}
		{
			p.SetState(860)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(861)
			p.Tff_formula()
		}
		{
			p.SetState(862)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserT__22:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.Match(tptp_v7_0_0_0ParserT__22)
		}
		{
			p.SetState(865)
			p.Tff_let_formula_defns()
		}
		{
			p.SetState(866)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(867)
			p.Tff_formula()
		}
		{
			p.SetState(868)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_let_term_defnsContext is an interface to support dynamic dispatch.
type ITff_let_term_defnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_term_defnsContext differentiates from other interfaces.
	IsTff_let_term_defnsContext()
}

type Tff_let_term_defnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_term_defnsContext() *Tff_let_term_defnsContext {
	var p = new(Tff_let_term_defnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_defns
	return p
}

func (*Tff_let_term_defnsContext) IsTff_let_term_defnsContext() {}

func NewTff_let_term_defnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_term_defnsContext {
	var p = new(Tff_let_term_defnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_defns

	return p
}

func (s *Tff_let_term_defnsContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_term_defnsContext) Tff_let_term_defn() ITff_let_term_defnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_defnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_defnContext)
}

func (s *Tff_let_term_defnsContext) Tff_let_term_list() ITff_let_term_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_listContext)
}

func (s *Tff_let_term_defnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_term_defnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_term_defnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_term_defns(s)
	}
}

func (s *Tff_let_term_defnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_term_defns(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_term_defns() (localctx ITff_let_term_defnsContext) {
	localctx = NewTff_let_term_defnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, tptp_v7_0_0_0ParserRULE_tff_let_term_defns)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(877)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__9, tptp_v7_0_0_0ParserForall, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Tff_let_term_defn()
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(874)
			p.Tff_let_term_list()
		}
		{
			p.SetState(875)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_let_term_listContext is an interface to support dynamic dispatch.
type ITff_let_term_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_term_listContext differentiates from other interfaces.
	IsTff_let_term_listContext()
}

type Tff_let_term_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_term_listContext() *Tff_let_term_listContext {
	var p = new(Tff_let_term_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_list
	return p
}

func (*Tff_let_term_listContext) IsTff_let_term_listContext() {}

func NewTff_let_term_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_term_listContext {
	var p = new(Tff_let_term_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_list

	return p
}

func (s *Tff_let_term_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_term_listContext) AllTff_let_term_defn() []ITff_let_term_defnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_let_term_defnContext)(nil)).Elem())
	var tst = make([]ITff_let_term_defnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_let_term_defnContext)
		}
	}

	return tst
}

func (s *Tff_let_term_listContext) Tff_let_term_defn(i int) ITff_let_term_defnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_defnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_defnContext)
}

func (s *Tff_let_term_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_term_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_term_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_term_list(s)
	}
}

func (s *Tff_let_term_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_term_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_term_list() (localctx ITff_let_term_listContext) {
	localctx = NewTff_let_term_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, tptp_v7_0_0_0ParserRULE_tff_let_term_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Tff_let_term_defn()
	}
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(880)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(881)
			p.Tff_let_term_defn()
		}

		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITff_let_term_defnContext is an interface to support dynamic dispatch.
type ITff_let_term_defnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_term_defnContext differentiates from other interfaces.
	IsTff_let_term_defnContext()
}

type Tff_let_term_defnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_term_defnContext() *Tff_let_term_defnContext {
	var p = new(Tff_let_term_defnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_defn
	return p
}

func (*Tff_let_term_defnContext) IsTff_let_term_defnContext() {}

func NewTff_let_term_defnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_term_defnContext {
	var p = new(Tff_let_term_defnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_defn

	return p
}

func (s *Tff_let_term_defnContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_term_defnContext) Forall() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserForall, 0)
}

func (s *Tff_let_term_defnContext) Tff_variable_list() ITff_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_variable_listContext)
}

func (s *Tff_let_term_defnContext) Tff_let_term_defn() ITff_let_term_defnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_defnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_defnContext)
}

func (s *Tff_let_term_defnContext) Tff_let_term_binding() ITff_let_term_bindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_bindingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_bindingContext)
}

func (s *Tff_let_term_defnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_term_defnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_term_defnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_term_defn(s)
	}
}

func (s *Tff_let_term_defnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_term_defn(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_term_defn() (localctx ITff_let_term_defnContext) {
	localctx = NewTff_let_term_defnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, tptp_v7_0_0_0ParserRULE_tff_let_term_defn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(895)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserForall:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(887)
			p.Match(tptp_v7_0_0_0ParserForall)
		}
		{
			p.SetState(888)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(889)
			p.Tff_variable_list()
		}
		{
			p.SetState(890)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}
		{
			p.SetState(891)
			p.Match(tptp_v7_0_0_0ParserT__13)
		}
		{
			p.SetState(892)
			p.Tff_let_term_defn()
		}

	case tptp_v7_0_0_0ParserT__9, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)
			p.Tff_let_term_binding()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_let_term_bindingContext is an interface to support dynamic dispatch.
type ITff_let_term_bindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_term_bindingContext differentiates from other interfaces.
	IsTff_let_term_bindingContext()
}

type Tff_let_term_bindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_term_bindingContext() *Tff_let_term_bindingContext {
	var p = new(Tff_let_term_bindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_binding
	return p
}

func (*Tff_let_term_bindingContext) IsTff_let_term_bindingContext() {}

func NewTff_let_term_bindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_term_bindingContext {
	var p = new(Tff_let_term_bindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term_binding

	return p
}

func (s *Tff_let_term_bindingContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_term_bindingContext) Fof_plain_term() IFof_plain_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_plain_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_plain_termContext)
}

func (s *Tff_let_term_bindingContext) Infix_equality() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInfix_equality, 0)
}

func (s *Tff_let_term_bindingContext) Fof_term() IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Tff_let_term_bindingContext) Tff_let_term_binding() ITff_let_term_bindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_bindingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_bindingContext)
}

func (s *Tff_let_term_bindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_term_bindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_term_bindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_term_binding(s)
	}
}

func (s *Tff_let_term_bindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_term_binding(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_term_binding() (localctx ITff_let_term_bindingContext) {
	localctx = NewTff_let_term_bindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, tptp_v7_0_0_0ParserRULE_tff_let_term_binding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(905)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(897)
			p.Fof_plain_term()
		}
		{
			p.SetState(898)
			p.Match(tptp_v7_0_0_0ParserInfix_equality)
		}
		{
			p.SetState(899)
			p.Fof_term()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(901)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(902)
			p.Tff_let_term_binding()
		}
		{
			p.SetState(903)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_let_formula_defnsContext is an interface to support dynamic dispatch.
type ITff_let_formula_defnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_formula_defnsContext differentiates from other interfaces.
	IsTff_let_formula_defnsContext()
}

type Tff_let_formula_defnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_formula_defnsContext() *Tff_let_formula_defnsContext {
	var p = new(Tff_let_formula_defnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_defns
	return p
}

func (*Tff_let_formula_defnsContext) IsTff_let_formula_defnsContext() {}

func NewTff_let_formula_defnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_formula_defnsContext {
	var p = new(Tff_let_formula_defnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_defns

	return p
}

func (s *Tff_let_formula_defnsContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_formula_defnsContext) Tff_let_formula_defn() ITff_let_formula_defnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_defnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_defnContext)
}

func (s *Tff_let_formula_defnsContext) Tff_let_formula_list() ITff_let_formula_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_listContext)
}

func (s *Tff_let_formula_defnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_formula_defnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_formula_defnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_formula_defns(s)
	}
}

func (s *Tff_let_formula_defnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_formula_defns(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_formula_defns() (localctx ITff_let_formula_defnsContext) {
	localctx = NewTff_let_formula_defnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, tptp_v7_0_0_0ParserRULE_tff_let_formula_defns)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(912)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__9, tptp_v7_0_0_0ParserForall, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(907)
			p.Tff_let_formula_defn()
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(908)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(909)
			p.Tff_let_formula_list()
		}
		{
			p.SetState(910)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_let_formula_listContext is an interface to support dynamic dispatch.
type ITff_let_formula_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_formula_listContext differentiates from other interfaces.
	IsTff_let_formula_listContext()
}

type Tff_let_formula_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_formula_listContext() *Tff_let_formula_listContext {
	var p = new(Tff_let_formula_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_list
	return p
}

func (*Tff_let_formula_listContext) IsTff_let_formula_listContext() {}

func NewTff_let_formula_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_formula_listContext {
	var p = new(Tff_let_formula_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_list

	return p
}

func (s *Tff_let_formula_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_formula_listContext) AllTff_let_formula_defn() []ITff_let_formula_defnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_let_formula_defnContext)(nil)).Elem())
	var tst = make([]ITff_let_formula_defnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_let_formula_defnContext)
		}
	}

	return tst
}

func (s *Tff_let_formula_listContext) Tff_let_formula_defn(i int) ITff_let_formula_defnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_defnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_defnContext)
}

func (s *Tff_let_formula_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_formula_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_formula_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_formula_list(s)
	}
}

func (s *Tff_let_formula_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_formula_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_formula_list() (localctx ITff_let_formula_listContext) {
	localctx = NewTff_let_formula_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, tptp_v7_0_0_0ParserRULE_tff_let_formula_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Tff_let_formula_defn()
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(915)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(916)
			p.Tff_let_formula_defn()
		}

		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITff_let_formula_defnContext is an interface to support dynamic dispatch.
type ITff_let_formula_defnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_formula_defnContext differentiates from other interfaces.
	IsTff_let_formula_defnContext()
}

type Tff_let_formula_defnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_formula_defnContext() *Tff_let_formula_defnContext {
	var p = new(Tff_let_formula_defnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_defn
	return p
}

func (*Tff_let_formula_defnContext) IsTff_let_formula_defnContext() {}

func NewTff_let_formula_defnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_formula_defnContext {
	var p = new(Tff_let_formula_defnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_defn

	return p
}

func (s *Tff_let_formula_defnContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_formula_defnContext) Forall() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserForall, 0)
}

func (s *Tff_let_formula_defnContext) Tff_variable_list() ITff_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_variable_listContext)
}

func (s *Tff_let_formula_defnContext) Tff_let_formula_defn() ITff_let_formula_defnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_defnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_defnContext)
}

func (s *Tff_let_formula_defnContext) Tff_let_formula_binding() ITff_let_formula_bindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_bindingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_bindingContext)
}

func (s *Tff_let_formula_defnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_formula_defnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_formula_defnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_formula_defn(s)
	}
}

func (s *Tff_let_formula_defnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_formula_defn(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_formula_defn() (localctx ITff_let_formula_defnContext) {
	localctx = NewTff_let_formula_defnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, tptp_v7_0_0_0ParserRULE_tff_let_formula_defn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(930)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserForall:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(922)
			p.Match(tptp_v7_0_0_0ParserForall)
		}
		{
			p.SetState(923)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(924)
			p.Tff_variable_list()
		}
		{
			p.SetState(925)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}
		{
			p.SetState(926)
			p.Match(tptp_v7_0_0_0ParserT__13)
		}
		{
			p.SetState(927)
			p.Tff_let_formula_defn()
		}

	case tptp_v7_0_0_0ParserT__9, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(929)
			p.Tff_let_formula_binding()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_let_formula_bindingContext is an interface to support dynamic dispatch.
type ITff_let_formula_bindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_formula_bindingContext differentiates from other interfaces.
	IsTff_let_formula_bindingContext()
}

type Tff_let_formula_bindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_formula_bindingContext() *Tff_let_formula_bindingContext {
	var p = new(Tff_let_formula_bindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_binding
	return p
}

func (*Tff_let_formula_bindingContext) IsTff_let_formula_bindingContext() {}

func NewTff_let_formula_bindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_formula_bindingContext {
	var p = new(Tff_let_formula_bindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_formula_binding

	return p
}

func (s *Tff_let_formula_bindingContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_formula_bindingContext) Fof_plain_atomic_formula() IFof_plain_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_plain_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_plain_atomic_formulaContext)
}

func (s *Tff_let_formula_bindingContext) Iff() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserIff, 0)
}

func (s *Tff_let_formula_bindingContext) Tff_unitary_formula() ITff_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_formulaContext)
}

func (s *Tff_let_formula_bindingContext) Tff_let_formula_binding() ITff_let_formula_bindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_bindingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_bindingContext)
}

func (s *Tff_let_formula_bindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_formula_bindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_formula_bindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_formula_binding(s)
	}
}

func (s *Tff_let_formula_bindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_formula_binding(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_formula_binding() (localctx ITff_let_formula_bindingContext) {
	localctx = NewTff_let_formula_bindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, tptp_v7_0_0_0ParserRULE_tff_let_formula_binding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(940)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Fof_plain_atomic_formula()
		}
		{
			p.SetState(933)
			p.Match(tptp_v7_0_0_0ParserIff)
		}
		{
			p.SetState(934)
			p.Tff_unitary_formula()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(936)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(937)
			p.Tff_let_formula_binding()
		}
		{
			p.SetState(938)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_sequentContext is an interface to support dynamic dispatch.
type ITff_sequentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_sequentContext differentiates from other interfaces.
	IsTff_sequentContext()
}

type Tff_sequentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_sequentContext() *Tff_sequentContext {
	var p = new(Tff_sequentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_sequent
	return p
}

func (*Tff_sequentContext) IsTff_sequentContext() {}

func NewTff_sequentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_sequentContext {
	var p = new(Tff_sequentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_sequent

	return p
}

func (s *Tff_sequentContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_sequentContext) AllTff_formula_tuple() []ITff_formula_tupleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_formula_tupleContext)(nil)).Elem())
	var tst = make([]ITff_formula_tupleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_formula_tupleContext)
		}
	}

	return tst
}

func (s *Tff_sequentContext) Tff_formula_tuple(i int) ITff_formula_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_formula_tupleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_formula_tupleContext)
}

func (s *Tff_sequentContext) Gentzen_arrow() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserGentzen_arrow, 0)
}

func (s *Tff_sequentContext) Tff_sequent() ITff_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_sequentContext)
}

func (s *Tff_sequentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_sequentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_sequentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_sequent(s)
	}
}

func (s *Tff_sequentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_sequent(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_sequent() (localctx ITff_sequentContext) {
	localctx = NewTff_sequentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, tptp_v7_0_0_0ParserRULE_tff_sequent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(950)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__11, tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(942)
			p.Tff_formula_tuple()
		}
		{
			p.SetState(943)
			p.Match(tptp_v7_0_0_0ParserGentzen_arrow)
		}
		{
			p.SetState(944)
			p.Tff_formula_tuple()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(946)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(947)
			p.Tff_sequent()
		}
		{
			p.SetState(948)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_formula_tupleContext is an interface to support dynamic dispatch.
type ITff_formula_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_formula_tupleContext differentiates from other interfaces.
	IsTff_formula_tupleContext()
}

type Tff_formula_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_formula_tupleContext() *Tff_formula_tupleContext {
	var p = new(Tff_formula_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_formula_tuple
	return p
}

func (*Tff_formula_tupleContext) IsTff_formula_tupleContext() {}

func NewTff_formula_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_formula_tupleContext {
	var p = new(Tff_formula_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_formula_tuple

	return p
}

func (s *Tff_formula_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_formula_tupleContext) Tff_formula_tuple_list() ITff_formula_tuple_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_formula_tuple_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_formula_tuple_listContext)
}

func (s *Tff_formula_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_formula_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_formula_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_formula_tuple(s)
	}
}

func (s *Tff_formula_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_formula_tuple(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_formula_tuple() (localctx ITff_formula_tupleContext) {
	localctx = NewTff_formula_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, tptp_v7_0_0_0ParserRULE_tff_formula_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(957)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(952)
			p.Match(tptp_v7_0_0_0ParserT__16)
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(953)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(954)
			p.Tff_formula_tuple_list()
		}
		{
			p.SetState(955)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_formula_tuple_listContext is an interface to support dynamic dispatch.
type ITff_formula_tuple_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_formula_tuple_listContext differentiates from other interfaces.
	IsTff_formula_tuple_listContext()
}

type Tff_formula_tuple_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_formula_tuple_listContext() *Tff_formula_tuple_listContext {
	var p = new(Tff_formula_tuple_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_formula_tuple_list
	return p
}

func (*Tff_formula_tuple_listContext) IsTff_formula_tuple_listContext() {}

func NewTff_formula_tuple_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_formula_tuple_listContext {
	var p = new(Tff_formula_tuple_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_formula_tuple_list

	return p
}

func (s *Tff_formula_tuple_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_formula_tuple_listContext) AllTff_logic_formula() []ITff_logic_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem())
	var tst = make([]ITff_logic_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_logic_formulaContext)
		}
	}

	return tst
}

func (s *Tff_formula_tuple_listContext) Tff_logic_formula(i int) ITff_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_logic_formulaContext)
}

func (s *Tff_formula_tuple_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_formula_tuple_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_formula_tuple_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_formula_tuple_list(s)
	}
}

func (s *Tff_formula_tuple_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_formula_tuple_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_formula_tuple_list() (localctx ITff_formula_tuple_listContext) {
	localctx = NewTff_formula_tuple_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, tptp_v7_0_0_0ParserRULE_tff_formula_tuple_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(959)
		p.Tff_logic_formula()
	}
	p.SetState(964)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(960)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(961)
			p.Tff_logic_formula()
		}

		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITff_typed_atomContext is an interface to support dynamic dispatch.
type ITff_typed_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_typed_atomContext differentiates from other interfaces.
	IsTff_typed_atomContext()
}

type Tff_typed_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_typed_atomContext() *Tff_typed_atomContext {
	var p = new(Tff_typed_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_typed_atom
	return p
}

func (*Tff_typed_atomContext) IsTff_typed_atomContext() {}

func NewTff_typed_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_typed_atomContext {
	var p = new(Tff_typed_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_typed_atom

	return p
}

func (s *Tff_typed_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_typed_atomContext) Untyped_atom() IUntyped_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUntyped_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUntyped_atomContext)
}

func (s *Tff_typed_atomContext) Tff_top_level_type() ITff_top_level_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_top_level_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_top_level_typeContext)
}

func (s *Tff_typed_atomContext) Tff_typed_atom() ITff_typed_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_typed_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_typed_atomContext)
}

func (s *Tff_typed_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_typed_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_typed_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_typed_atom(s)
	}
}

func (s *Tff_typed_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_typed_atom(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_typed_atom() (localctx ITff_typed_atomContext) {
	localctx = NewTff_typed_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, tptp_v7_0_0_0ParserRULE_tff_typed_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(967)
			p.Untyped_atom()
		}
		{
			p.SetState(968)
			p.Match(tptp_v7_0_0_0ParserT__13)
		}
		{
			p.SetState(969)
			p.Tff_top_level_type()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(971)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(972)
			p.Tff_typed_atom()
		}
		{
			p.SetState(973)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_subtypeContext is an interface to support dynamic dispatch.
type ITff_subtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_subtypeContext differentiates from other interfaces.
	IsTff_subtypeContext()
}

type Tff_subtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_subtypeContext() *Tff_subtypeContext {
	var p = new(Tff_subtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_subtype
	return p
}

func (*Tff_subtypeContext) IsTff_subtypeContext() {}

func NewTff_subtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_subtypeContext {
	var p = new(Tff_subtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_subtype

	return p
}

func (s *Tff_subtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_subtypeContext) Untyped_atom() IUntyped_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUntyped_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUntyped_atomContext)
}

func (s *Tff_subtypeContext) Subtype_sign() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserSubtype_sign, 0)
}

func (s *Tff_subtypeContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Tff_subtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_subtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_subtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_subtype(s)
	}
}

func (s *Tff_subtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_subtype(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_subtype() (localctx ITff_subtypeContext) {
	localctx = NewTff_subtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, tptp_v7_0_0_0ParserRULE_tff_subtype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.Untyped_atom()
	}
	{
		p.SetState(978)
		p.Match(tptp_v7_0_0_0ParserSubtype_sign)
	}
	{
		p.SetState(979)
		p.Atom()
	}

	return localctx
}

// ITff_top_level_typeContext is an interface to support dynamic dispatch.
type ITff_top_level_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_top_level_typeContext differentiates from other interfaces.
	IsTff_top_level_typeContext()
}

type Tff_top_level_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_top_level_typeContext() *Tff_top_level_typeContext {
	var p = new(Tff_top_level_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_top_level_type
	return p
}

func (*Tff_top_level_typeContext) IsTff_top_level_typeContext() {}

func NewTff_top_level_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_top_level_typeContext {
	var p = new(Tff_top_level_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_top_level_type

	return p
}

func (s *Tff_top_level_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_top_level_typeContext) Tff_atomic_type() ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_top_level_typeContext) Tff_mapping_type() ITff_mapping_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_mapping_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_mapping_typeContext)
}

func (s *Tff_top_level_typeContext) Tf1_quantified_type() ITf1_quantified_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf1_quantified_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf1_quantified_typeContext)
}

func (s *Tff_top_level_typeContext) Tff_top_level_type() ITff_top_level_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_top_level_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_top_level_typeContext)
}

func (s *Tff_top_level_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_top_level_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_top_level_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_top_level_type(s)
	}
}

func (s *Tff_top_level_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_top_level_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_top_level_type() (localctx ITff_top_level_typeContext) {
	localctx = NewTff_top_level_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, tptp_v7_0_0_0ParserRULE_tff_top_level_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(981)
			p.Tff_atomic_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(982)
			p.Tff_mapping_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(983)
			p.Tf1_quantified_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(984)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(985)
			p.Tff_top_level_type()
		}
		{
			p.SetState(986)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// ITf1_quantified_typeContext is an interface to support dynamic dispatch.
type ITf1_quantified_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf1_quantified_typeContext differentiates from other interfaces.
	IsTf1_quantified_typeContext()
}

type Tf1_quantified_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf1_quantified_typeContext() *Tf1_quantified_typeContext {
	var p = new(Tf1_quantified_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tf1_quantified_type
	return p
}

func (*Tf1_quantified_typeContext) IsTf1_quantified_typeContext() {}

func NewTf1_quantified_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf1_quantified_typeContext {
	var p = new(Tf1_quantified_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tf1_quantified_type

	return p
}

func (s *Tf1_quantified_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf1_quantified_typeContext) Tff_variable_list() ITff_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_variable_listContext)
}

func (s *Tf1_quantified_typeContext) Tff_monotype() ITff_monotypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_monotypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_monotypeContext)
}

func (s *Tf1_quantified_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf1_quantified_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf1_quantified_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTf1_quantified_type(s)
	}
}

func (s *Tf1_quantified_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTf1_quantified_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tf1_quantified_type() (localctx ITf1_quantified_typeContext) {
	localctx = NewTf1_quantified_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, tptp_v7_0_0_0ParserRULE_tf1_quantified_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.Match(tptp_v7_0_0_0ParserTyForall)
	}
	{
		p.SetState(991)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(992)
		p.Tff_variable_list()
	}
	{
		p.SetState(993)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(994)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(995)
		p.Tff_monotype()
	}

	return localctx
}

// ITff_monotypeContext is an interface to support dynamic dispatch.
type ITff_monotypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_monotypeContext differentiates from other interfaces.
	IsTff_monotypeContext()
}

type Tff_monotypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_monotypeContext() *Tff_monotypeContext {
	var p = new(Tff_monotypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_monotype
	return p
}

func (*Tff_monotypeContext) IsTff_monotypeContext() {}

func NewTff_monotypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_monotypeContext {
	var p = new(Tff_monotypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_monotype

	return p
}

func (s *Tff_monotypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_monotypeContext) Tff_atomic_type() ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_monotypeContext) Tff_mapping_type() ITff_mapping_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_mapping_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_mapping_typeContext)
}

func (s *Tff_monotypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_monotypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_monotypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_monotype(s)
	}
}

func (s *Tff_monotypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_monotype(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_monotype() (localctx ITff_monotypeContext) {
	localctx = NewTff_monotypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, tptp_v7_0_0_0ParserRULE_tff_monotype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1002)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(997)
			p.Tff_atomic_type()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(998)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(999)
			p.Tff_mapping_type()
		}
		{
			p.SetState(1000)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_unitary_typeContext is an interface to support dynamic dispatch.
type ITff_unitary_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_unitary_typeContext differentiates from other interfaces.
	IsTff_unitary_typeContext()
}

type Tff_unitary_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_unitary_typeContext() *Tff_unitary_typeContext {
	var p = new(Tff_unitary_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_unitary_type
	return p
}

func (*Tff_unitary_typeContext) IsTff_unitary_typeContext() {}

func NewTff_unitary_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_unitary_typeContext {
	var p = new(Tff_unitary_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_unitary_type

	return p
}

func (s *Tff_unitary_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_unitary_typeContext) Tff_atomic_type() ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_unitary_typeContext) Tff_xprod_type() ITff_xprod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_xprod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_xprod_typeContext)
}

func (s *Tff_unitary_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_unitary_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_unitary_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_unitary_type(s)
	}
}

func (s *Tff_unitary_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_unitary_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_unitary_type() (localctx ITff_unitary_typeContext) {
	localctx = NewTff_unitary_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, tptp_v7_0_0_0ParserRULE_tff_unitary_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1009)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1004)
			p.Tff_atomic_type()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1005)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1006)
			p.tff_xprod_type(0)
		}
		{
			p.SetState(1007)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_atomic_typeContext is an interface to support dynamic dispatch.
type ITff_atomic_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_atomic_typeContext differentiates from other interfaces.
	IsTff_atomic_typeContext()
}

type Tff_atomic_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_atomic_typeContext() *Tff_atomic_typeContext {
	var p = new(Tff_atomic_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_atomic_type
	return p
}

func (*Tff_atomic_typeContext) IsTff_atomic_typeContext() {}

func NewTff_atomic_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_atomic_typeContext {
	var p = new(Tff_atomic_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_atomic_type

	return p
}

func (s *Tff_atomic_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_atomic_typeContext) Type_constant() IType_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_constantContext)
}

func (s *Tff_atomic_typeContext) Defined_type() IDefined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_typeContext)
}

func (s *Tff_atomic_typeContext) Type_functor() IType_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_functorContext)
}

func (s *Tff_atomic_typeContext) Tff_type_arguments() ITff_type_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_type_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_type_argumentsContext)
}

func (s *Tff_atomic_typeContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Tff_atomic_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_atomic_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_atomic_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_atomic_type(s)
	}
}

func (s *Tff_atomic_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_atomic_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_atomic_type() (localctx ITff_atomic_typeContext) {
	localctx = NewTff_atomic_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, tptp_v7_0_0_0ParserRULE_tff_atomic_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1011)
			p.Type_constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1012)
			p.Defined_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1013)
			p.Type_functor()
		}
		{
			p.SetState(1014)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1015)
			p.Tff_type_arguments()
		}
		{
			p.SetState(1016)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1018)
			p.Variable()
		}

	}

	return localctx
}

// ITff_type_argumentsContext is an interface to support dynamic dispatch.
type ITff_type_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_type_argumentsContext differentiates from other interfaces.
	IsTff_type_argumentsContext()
}

type Tff_type_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_type_argumentsContext() *Tff_type_argumentsContext {
	var p = new(Tff_type_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_type_arguments
	return p
}

func (*Tff_type_argumentsContext) IsTff_type_argumentsContext() {}

func NewTff_type_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_type_argumentsContext {
	var p = new(Tff_type_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_type_arguments

	return p
}

func (s *Tff_type_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_type_argumentsContext) AllTff_atomic_type() []ITff_atomic_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem())
	var tst = make([]ITff_atomic_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITff_atomic_typeContext)
		}
	}

	return tst
}

func (s *Tff_type_argumentsContext) Tff_atomic_type(i int) ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_type_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_type_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_type_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_type_arguments(s)
	}
}

func (s *Tff_type_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_type_arguments(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_type_arguments() (localctx ITff_type_argumentsContext) {
	localctx = NewTff_type_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, tptp_v7_0_0_0ParserRULE_tff_type_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.Tff_atomic_type()
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1022)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1023)
			p.Tff_atomic_type()
		}

		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITff_mapping_typeContext is an interface to support dynamic dispatch.
type ITff_mapping_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_mapping_typeContext differentiates from other interfaces.
	IsTff_mapping_typeContext()
}

type Tff_mapping_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_mapping_typeContext() *Tff_mapping_typeContext {
	var p = new(Tff_mapping_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_mapping_type
	return p
}

func (*Tff_mapping_typeContext) IsTff_mapping_typeContext() {}

func NewTff_mapping_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_mapping_typeContext {
	var p = new(Tff_mapping_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_mapping_type

	return p
}

func (s *Tff_mapping_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_mapping_typeContext) Tff_unitary_type() ITff_unitary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_typeContext)
}

func (s *Tff_mapping_typeContext) Arrow() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserArrow, 0)
}

func (s *Tff_mapping_typeContext) Tff_atomic_type() ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_mapping_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_mapping_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_mapping_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_mapping_type(s)
	}
}

func (s *Tff_mapping_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_mapping_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_mapping_type() (localctx ITff_mapping_typeContext) {
	localctx = NewTff_mapping_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, tptp_v7_0_0_0ParserRULE_tff_mapping_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Tff_unitary_type()
	}
	{
		p.SetState(1030)
		p.Match(tptp_v7_0_0_0ParserArrow)
	}
	{
		p.SetState(1031)
		p.Tff_atomic_type()
	}

	return localctx
}

// ITff_xprod_typeContext is an interface to support dynamic dispatch.
type ITff_xprod_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_xprod_typeContext differentiates from other interfaces.
	IsTff_xprod_typeContext()
}

type Tff_xprod_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_xprod_typeContext() *Tff_xprod_typeContext {
	var p = new(Tff_xprod_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_xprod_type
	return p
}

func (*Tff_xprod_typeContext) IsTff_xprod_typeContext() {}

func NewTff_xprod_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_xprod_typeContext {
	var p = new(Tff_xprod_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_xprod_type

	return p
}

func (s *Tff_xprod_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_xprod_typeContext) Tff_unitary_type() ITff_unitary_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_unitary_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_unitary_typeContext)
}

func (s *Tff_xprod_typeContext) Star() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserStar, 0)
}

func (s *Tff_xprod_typeContext) Tff_atomic_type() ITff_atomic_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_atomic_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_atomic_typeContext)
}

func (s *Tff_xprod_typeContext) Tff_xprod_type() ITff_xprod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_xprod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_xprod_typeContext)
}

func (s *Tff_xprod_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_xprod_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_xprod_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_xprod_type(s)
	}
}

func (s *Tff_xprod_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_xprod_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_xprod_type() (localctx ITff_xprod_typeContext) {
	return p.tff_xprod_type(0)
}

func (p *tptp_v7_0_0_0Parser) tff_xprod_type(_p int) (localctx ITff_xprod_typeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTff_xprod_typeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITff_xprod_typeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 170
	p.EnterRecursionRule(localctx, 170, tptp_v7_0_0_0ParserRULE_tff_xprod_type, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.Tff_unitary_type()
	}
	{
		p.SetState(1035)
		p.Match(tptp_v7_0_0_0ParserStar)
	}
	{
		p.SetState(1036)
		p.Tff_atomic_type()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTff_xprod_typeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_tff_xprod_type)
			p.SetState(1038)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1039)
				p.Match(tptp_v7_0_0_0ParserStar)
			}
			{
				p.SetState(1040)
				p.Tff_atomic_type()
			}

		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// ITcf_formulaContext is an interface to support dynamic dispatch.
type ITcf_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTcf_formulaContext differentiates from other interfaces.
	IsTcf_formulaContext()
}

type Tcf_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTcf_formulaContext() *Tcf_formulaContext {
	var p = new(Tcf_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_formula
	return p
}

func (*Tcf_formulaContext) IsTcf_formulaContext() {}

func NewTcf_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tcf_formulaContext {
	var p = new(Tcf_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_formula

	return p
}

func (s *Tcf_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tcf_formulaContext) Tcf_logic_formula() ITcf_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITcf_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITcf_logic_formulaContext)
}

func (s *Tcf_formulaContext) Tff_typed_atom() ITff_typed_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_typed_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_typed_atomContext)
}

func (s *Tcf_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tcf_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tcf_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTcf_formula(s)
	}
}

func (s *Tcf_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTcf_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tcf_formula() (localctx ITcf_formulaContext) {
	localctx = NewTcf_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, tptp_v7_0_0_0ParserRULE_tcf_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1046)
			p.Tcf_logic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1047)
			p.Tff_typed_atom()
		}

	}

	return localctx
}

// ITcf_logic_formulaContext is an interface to support dynamic dispatch.
type ITcf_logic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTcf_logic_formulaContext differentiates from other interfaces.
	IsTcf_logic_formulaContext()
}

type Tcf_logic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTcf_logic_formulaContext() *Tcf_logic_formulaContext {
	var p = new(Tcf_logic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_logic_formula
	return p
}

func (*Tcf_logic_formulaContext) IsTcf_logic_formulaContext() {}

func NewTcf_logic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tcf_logic_formulaContext {
	var p = new(Tcf_logic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_logic_formula

	return p
}

func (s *Tcf_logic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tcf_logic_formulaContext) Tcf_quantified_formula() ITcf_quantified_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITcf_quantified_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITcf_quantified_formulaContext)
}

func (s *Tcf_logic_formulaContext) Cnf_formula() ICnf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_formulaContext)
}

func (s *Tcf_logic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tcf_logic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tcf_logic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTcf_logic_formula(s)
	}
}

func (s *Tcf_logic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTcf_logic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tcf_logic_formula() (localctx ITcf_logic_formulaContext) {
	localctx = NewTcf_logic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, tptp_v7_0_0_0ParserRULE_tcf_logic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1052)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserForall:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1050)
			p.Tcf_quantified_formula()
		}

	case tptp_v7_0_0_0ParserT__9, tptp_v7_0_0_0ParserT__17, tptp_v7_0_0_0ParserT__18, tptp_v7_0_0_0ParserT__23, tptp_v7_0_0_0ParserT__24, tptp_v7_0_0_0ParserT__25, tptp_v7_0_0_0ParserNot, tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1051)
			p.Cnf_formula()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITcf_quantified_formulaContext is an interface to support dynamic dispatch.
type ITcf_quantified_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTcf_quantified_formulaContext differentiates from other interfaces.
	IsTcf_quantified_formulaContext()
}

type Tcf_quantified_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTcf_quantified_formulaContext() *Tcf_quantified_formulaContext {
	var p = new(Tcf_quantified_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_quantified_formula
	return p
}

func (*Tcf_quantified_formulaContext) IsTcf_quantified_formulaContext() {}

func NewTcf_quantified_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tcf_quantified_formulaContext {
	var p = new(Tcf_quantified_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tcf_quantified_formula

	return p
}

func (s *Tcf_quantified_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Tcf_quantified_formulaContext) Forall() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserForall, 0)
}

func (s *Tcf_quantified_formulaContext) Tff_variable_list() ITff_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_variable_listContext)
}

func (s *Tcf_quantified_formulaContext) Cnf_formula() ICnf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_formulaContext)
}

func (s *Tcf_quantified_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tcf_quantified_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tcf_quantified_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTcf_quantified_formula(s)
	}
}

func (s *Tcf_quantified_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTcf_quantified_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tcf_quantified_formula() (localctx ITcf_quantified_formulaContext) {
	localctx = NewTcf_quantified_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, tptp_v7_0_0_0ParserRULE_tcf_quantified_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Match(tptp_v7_0_0_0ParserForall)
	}
	{
		p.SetState(1055)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(1056)
		p.Tff_variable_list()
	}
	{
		p.SetState(1057)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(1058)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(1059)
		p.Cnf_formula()
	}

	return localctx
}

// IFof_formulaContext is an interface to support dynamic dispatch.
type IFof_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_formulaContext differentiates from other interfaces.
	IsFof_formulaContext()
}

type Fof_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_formulaContext() *Fof_formulaContext {
	var p = new(Fof_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_formula
	return p
}

func (*Fof_formulaContext) IsFof_formulaContext() {}

func NewFof_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_formulaContext {
	var p = new(Fof_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_formula

	return p
}

func (s *Fof_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_formulaContext) Fof_logic_formula() IFof_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_logic_formulaContext)
}

func (s *Fof_formulaContext) Fof_sequent() IFof_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_sequentContext)
}

func (s *Fof_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_formula(s)
	}
}

func (s *Fof_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_formula() (localctx IFof_formulaContext) {
	localctx = NewFof_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, tptp_v7_0_0_0ParserRULE_fof_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1061)
			p.Fof_logic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1062)
			p.Fof_sequent()
		}

	}

	return localctx
}

// IFof_logic_formulaContext is an interface to support dynamic dispatch.
type IFof_logic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_logic_formulaContext differentiates from other interfaces.
	IsFof_logic_formulaContext()
}

type Fof_logic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_logic_formulaContext() *Fof_logic_formulaContext {
	var p = new(Fof_logic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_logic_formula
	return p
}

func (*Fof_logic_formulaContext) IsFof_logic_formulaContext() {}

func NewFof_logic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_logic_formulaContext {
	var p = new(Fof_logic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_logic_formula

	return p
}

func (s *Fof_logic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_logic_formulaContext) Fof_binary_formula() IFof_binary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_binary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_binary_formulaContext)
}

func (s *Fof_logic_formulaContext) Fof_unitary_formula() IFof_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_unitary_formulaContext)
}

func (s *Fof_logic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_logic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_logic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_logic_formula(s)
	}
}

func (s *Fof_logic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_logic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_logic_formula() (localctx IFof_logic_formulaContext) {
	localctx = NewFof_logic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, tptp_v7_0_0_0ParserRULE_fof_logic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1065)
			p.Fof_binary_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1066)
			p.Fof_unitary_formula()
		}

	}

	return localctx
}

// IFof_binary_formulaContext is an interface to support dynamic dispatch.
type IFof_binary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_binary_formulaContext differentiates from other interfaces.
	IsFof_binary_formulaContext()
}

type Fof_binary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_binary_formulaContext() *Fof_binary_formulaContext {
	var p = new(Fof_binary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_binary_formula
	return p
}

func (*Fof_binary_formulaContext) IsFof_binary_formulaContext() {}

func NewFof_binary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_binary_formulaContext {
	var p = new(Fof_binary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_binary_formula

	return p
}

func (s *Fof_binary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_binary_formulaContext) Fof_binary_nonassoc() IFof_binary_nonassocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_binary_nonassocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_binary_nonassocContext)
}

func (s *Fof_binary_formulaContext) Fof_binary_assoc() IFof_binary_assocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_binary_assocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_binary_assocContext)
}

func (s *Fof_binary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_binary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_binary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_binary_formula(s)
	}
}

func (s *Fof_binary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_binary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_binary_formula() (localctx IFof_binary_formulaContext) {
	localctx = NewFof_binary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, tptp_v7_0_0_0ParserRULE_fof_binary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1069)
			p.Fof_binary_nonassoc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1070)
			p.Fof_binary_assoc()
		}

	}

	return localctx
}

// IFof_binary_nonassocContext is an interface to support dynamic dispatch.
type IFof_binary_nonassocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_binary_nonassocContext differentiates from other interfaces.
	IsFof_binary_nonassocContext()
}

type Fof_binary_nonassocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_binary_nonassocContext() *Fof_binary_nonassocContext {
	var p = new(Fof_binary_nonassocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_binary_nonassoc
	return p
}

func (*Fof_binary_nonassocContext) IsFof_binary_nonassocContext() {}

func NewFof_binary_nonassocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_binary_nonassocContext {
	var p = new(Fof_binary_nonassocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_binary_nonassoc

	return p
}

func (s *Fof_binary_nonassocContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_binary_nonassocContext) AllFof_unitary_formula() []IFof_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IFof_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Fof_binary_nonassocContext) Fof_unitary_formula(i int) IFof_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_unitary_formulaContext)
}

func (s *Fof_binary_nonassocContext) Binary_connective() IBinary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_connectiveContext)
}

func (s *Fof_binary_nonassocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_binary_nonassocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_binary_nonassocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_binary_nonassoc(s)
	}
}

func (s *Fof_binary_nonassocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_binary_nonassoc(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_binary_nonassoc() (localctx IFof_binary_nonassocContext) {
	localctx = NewFof_binary_nonassocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, tptp_v7_0_0_0ParserRULE_fof_binary_nonassoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Fof_unitary_formula()
	}
	{
		p.SetState(1074)
		p.Binary_connective()
	}
	{
		p.SetState(1075)
		p.Fof_unitary_formula()
	}

	return localctx
}

// IFof_binary_assocContext is an interface to support dynamic dispatch.
type IFof_binary_assocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_binary_assocContext differentiates from other interfaces.
	IsFof_binary_assocContext()
}

type Fof_binary_assocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_binary_assocContext() *Fof_binary_assocContext {
	var p = new(Fof_binary_assocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_binary_assoc
	return p
}

func (*Fof_binary_assocContext) IsFof_binary_assocContext() {}

func NewFof_binary_assocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_binary_assocContext {
	var p = new(Fof_binary_assocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_binary_assoc

	return p
}

func (s *Fof_binary_assocContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_binary_assocContext) Fof_or_formula() IFof_or_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_or_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_or_formulaContext)
}

func (s *Fof_binary_assocContext) Fof_and_formula() IFof_and_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_and_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_and_formulaContext)
}

func (s *Fof_binary_assocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_binary_assocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_binary_assocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_binary_assoc(s)
	}
}

func (s *Fof_binary_assocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_binary_assoc(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_binary_assoc() (localctx IFof_binary_assocContext) {
	localctx = NewFof_binary_assocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, tptp_v7_0_0_0ParserRULE_fof_binary_assoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1079)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1077)
			p.fof_or_formula(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.fof_and_formula(0)
		}

	}

	return localctx
}

// IFof_or_formulaContext is an interface to support dynamic dispatch.
type IFof_or_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_or_formulaContext differentiates from other interfaces.
	IsFof_or_formulaContext()
}

type Fof_or_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_or_formulaContext() *Fof_or_formulaContext {
	var p = new(Fof_or_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_or_formula
	return p
}

func (*Fof_or_formulaContext) IsFof_or_formulaContext() {}

func NewFof_or_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_or_formulaContext {
	var p = new(Fof_or_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_or_formula

	return p
}

func (s *Fof_or_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_or_formulaContext) AllFof_unitary_formula() []IFof_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IFof_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Fof_or_formulaContext) Fof_unitary_formula(i int) IFof_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_unitary_formulaContext)
}

func (s *Fof_or_formulaContext) Or() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserOr, 0)
}

func (s *Fof_or_formulaContext) Fof_or_formula() IFof_or_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_or_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_or_formulaContext)
}

func (s *Fof_or_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_or_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_or_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_or_formula(s)
	}
}

func (s *Fof_or_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_or_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_or_formula() (localctx IFof_or_formulaContext) {
	return p.fof_or_formula(0)
}

func (p *tptp_v7_0_0_0Parser) fof_or_formula(_p int) (localctx IFof_or_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFof_or_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFof_or_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 188
	p.EnterRecursionRule(localctx, 188, tptp_v7_0_0_0ParserRULE_fof_or_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1082)
		p.Fof_unitary_formula()
	}
	{
		p.SetState(1083)
		p.Match(tptp_v7_0_0_0ParserOr)
	}
	{
		p.SetState(1084)
		p.Fof_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFof_or_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_fof_or_formula)
			p.SetState(1086)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1087)
				p.Match(tptp_v7_0_0_0ParserOr)
			}
			{
				p.SetState(1088)
				p.Fof_unitary_formula()
			}

		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}

	return localctx
}

// IFof_and_formulaContext is an interface to support dynamic dispatch.
type IFof_and_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_and_formulaContext differentiates from other interfaces.
	IsFof_and_formulaContext()
}

type Fof_and_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_and_formulaContext() *Fof_and_formulaContext {
	var p = new(Fof_and_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_and_formula
	return p
}

func (*Fof_and_formulaContext) IsFof_and_formulaContext() {}

func NewFof_and_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_and_formulaContext {
	var p = new(Fof_and_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_and_formula

	return p
}

func (s *Fof_and_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_and_formulaContext) AllFof_unitary_formula() []IFof_unitary_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem())
	var tst = make([]IFof_unitary_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_unitary_formulaContext)
		}
	}

	return tst
}

func (s *Fof_and_formulaContext) Fof_unitary_formula(i int) IFof_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_unitary_formulaContext)
}

func (s *Fof_and_formulaContext) And() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAnd, 0)
}

func (s *Fof_and_formulaContext) Fof_and_formula() IFof_and_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_and_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_and_formulaContext)
}

func (s *Fof_and_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_and_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_and_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_and_formula(s)
	}
}

func (s *Fof_and_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_and_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_and_formula() (localctx IFof_and_formulaContext) {
	return p.fof_and_formula(0)
}

func (p *tptp_v7_0_0_0Parser) fof_and_formula(_p int) (localctx IFof_and_formulaContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFof_and_formulaContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFof_and_formulaContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 190
	p.EnterRecursionRule(localctx, 190, tptp_v7_0_0_0ParserRULE_fof_and_formula, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		p.Fof_unitary_formula()
	}
	{
		p.SetState(1096)
		p.Match(tptp_v7_0_0_0ParserAnd)
	}
	{
		p.SetState(1097)
		p.Fof_unitary_formula()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFof_and_formulaContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_fof_and_formula)
			p.SetState(1099)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1100)
				p.Match(tptp_v7_0_0_0ParserAnd)
			}
			{
				p.SetState(1101)
				p.Fof_unitary_formula()
			}

		}
		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}

	return localctx
}

// IFof_unitary_formulaContext is an interface to support dynamic dispatch.
type IFof_unitary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_unitary_formulaContext differentiates from other interfaces.
	IsFof_unitary_formulaContext()
}

type Fof_unitary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_unitary_formulaContext() *Fof_unitary_formulaContext {
	var p = new(Fof_unitary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_unitary_formula
	return p
}

func (*Fof_unitary_formulaContext) IsFof_unitary_formulaContext() {}

func NewFof_unitary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_unitary_formulaContext {
	var p = new(Fof_unitary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_unitary_formula

	return p
}

func (s *Fof_unitary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_unitary_formulaContext) Fof_quantified_formula() IFof_quantified_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_quantified_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_quantified_formulaContext)
}

func (s *Fof_unitary_formulaContext) Fof_unary_formula() IFof_unary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_unary_formulaContext)
}

func (s *Fof_unitary_formulaContext) Fof_atomic_formula() IFof_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_atomic_formulaContext)
}

func (s *Fof_unitary_formulaContext) Fof_logic_formula() IFof_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_logic_formulaContext)
}

func (s *Fof_unitary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_unitary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_unitary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_unitary_formula(s)
	}
}

func (s *Fof_unitary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_unitary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_unitary_formula() (localctx IFof_unitary_formulaContext) {
	localctx = NewFof_unitary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, tptp_v7_0_0_0ParserRULE_fof_unitary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)
			p.Fof_quantified_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.Fof_unary_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1109)
			p.Fof_atomic_formula()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1110)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1111)
			p.Fof_logic_formula()
		}
		{
			p.SetState(1112)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// IFof_quantified_formulaContext is an interface to support dynamic dispatch.
type IFof_quantified_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_quantified_formulaContext differentiates from other interfaces.
	IsFof_quantified_formulaContext()
}

type Fof_quantified_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_quantified_formulaContext() *Fof_quantified_formulaContext {
	var p = new(Fof_quantified_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_quantified_formula
	return p
}

func (*Fof_quantified_formulaContext) IsFof_quantified_formulaContext() {}

func NewFof_quantified_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_quantified_formulaContext {
	var p = new(Fof_quantified_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_quantified_formula

	return p
}

func (s *Fof_quantified_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_quantified_formulaContext) Fof_quantifier() IFof_quantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_quantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_quantifierContext)
}

func (s *Fof_quantified_formulaContext) Fof_variable_list() IFof_variable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_variable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_variable_listContext)
}

func (s *Fof_quantified_formulaContext) Fof_unitary_formula() IFof_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_unitary_formulaContext)
}

func (s *Fof_quantified_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_quantified_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_quantified_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_quantified_formula(s)
	}
}

func (s *Fof_quantified_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_quantified_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_quantified_formula() (localctx IFof_quantified_formulaContext) {
	localctx = NewFof_quantified_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, tptp_v7_0_0_0ParserRULE_fof_quantified_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1116)
		p.Fof_quantifier()
	}
	{
		p.SetState(1117)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(1118)
		p.Fof_variable_list()
	}
	{
		p.SetState(1119)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(1120)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(1121)
		p.Fof_unitary_formula()
	}

	return localctx
}

// IFof_variable_listContext is an interface to support dynamic dispatch.
type IFof_variable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_variable_listContext differentiates from other interfaces.
	IsFof_variable_listContext()
}

type Fof_variable_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_variable_listContext() *Fof_variable_listContext {
	var p = new(Fof_variable_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_variable_list
	return p
}

func (*Fof_variable_listContext) IsFof_variable_listContext() {}

func NewFof_variable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_variable_listContext {
	var p = new(Fof_variable_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_variable_list

	return p
}

func (s *Fof_variable_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_variable_listContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Fof_variable_listContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fof_variable_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_variable_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_variable_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_variable_list(s)
	}
}

func (s *Fof_variable_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_variable_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_variable_list() (localctx IFof_variable_listContext) {
	localctx = NewFof_variable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, tptp_v7_0_0_0ParserRULE_fof_variable_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1123)
		p.Variable()
	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1124)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1125)
			p.Variable()
		}

		p.SetState(1130)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFof_unary_formulaContext is an interface to support dynamic dispatch.
type IFof_unary_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_unary_formulaContext differentiates from other interfaces.
	IsFof_unary_formulaContext()
}

type Fof_unary_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_unary_formulaContext() *Fof_unary_formulaContext {
	var p = new(Fof_unary_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_unary_formula
	return p
}

func (*Fof_unary_formulaContext) IsFof_unary_formulaContext() {}

func NewFof_unary_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_unary_formulaContext {
	var p = new(Fof_unary_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_unary_formula

	return p
}

func (s *Fof_unary_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_unary_formulaContext) Unary_connective() IUnary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_connectiveContext)
}

func (s *Fof_unary_formulaContext) Fof_unitary_formula() IFof_unitary_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_unitary_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_unitary_formulaContext)
}

func (s *Fof_unary_formulaContext) Fof_infix_unary() IFof_infix_unaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_infix_unaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_infix_unaryContext)
}

func (s *Fof_unary_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_unary_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_unary_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_unary_formula(s)
	}
}

func (s *Fof_unary_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_unary_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_unary_formula() (localctx IFof_unary_formulaContext) {
	localctx = NewFof_unary_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, tptp_v7_0_0_0ParserRULE_fof_unary_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1135)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserNot:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1131)
			p.Unary_connective()
		}
		{
			p.SetState(1132)
			p.Fof_unitary_formula()
		}

	case tptp_v7_0_0_0ParserT__17, tptp_v7_0_0_0ParserT__18, tptp_v7_0_0_0ParserT__23, tptp_v7_0_0_0ParserT__24, tptp_v7_0_0_0ParserT__25, tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1134)
			p.Fof_infix_unary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_infix_unaryContext is an interface to support dynamic dispatch.
type IFof_infix_unaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_infix_unaryContext differentiates from other interfaces.
	IsFof_infix_unaryContext()
}

type Fof_infix_unaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_infix_unaryContext() *Fof_infix_unaryContext {
	var p = new(Fof_infix_unaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_infix_unary
	return p
}

func (*Fof_infix_unaryContext) IsFof_infix_unaryContext() {}

func NewFof_infix_unaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_infix_unaryContext {
	var p = new(Fof_infix_unaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_infix_unary

	return p
}

func (s *Fof_infix_unaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_infix_unaryContext) AllFof_term() []IFof_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_termContext)(nil)).Elem())
	var tst = make([]IFof_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_termContext)
		}
	}

	return tst
}

func (s *Fof_infix_unaryContext) Fof_term(i int) IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Fof_infix_unaryContext) Infix_inequality() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInfix_inequality, 0)
}

func (s *Fof_infix_unaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_infix_unaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_infix_unaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_infix_unary(s)
	}
}

func (s *Fof_infix_unaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_infix_unary(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_infix_unary() (localctx IFof_infix_unaryContext) {
	localctx = NewFof_infix_unaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, tptp_v7_0_0_0ParserRULE_fof_infix_unary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Fof_term()
	}
	{
		p.SetState(1138)
		p.Match(tptp_v7_0_0_0ParserInfix_inequality)
	}
	{
		p.SetState(1139)
		p.Fof_term()
	}

	return localctx
}

// IFof_atomic_formulaContext is an interface to support dynamic dispatch.
type IFof_atomic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_atomic_formulaContext differentiates from other interfaces.
	IsFof_atomic_formulaContext()
}

type Fof_atomic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_atomic_formulaContext() *Fof_atomic_formulaContext {
	var p = new(Fof_atomic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_atomic_formula
	return p
}

func (*Fof_atomic_formulaContext) IsFof_atomic_formulaContext() {}

func NewFof_atomic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_atomic_formulaContext {
	var p = new(Fof_atomic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_atomic_formula

	return p
}

func (s *Fof_atomic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_atomic_formulaContext) Fof_plain_atomic_formula() IFof_plain_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_plain_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_plain_atomic_formulaContext)
}

func (s *Fof_atomic_formulaContext) Fof_defined_atomic_formula() IFof_defined_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_atomic_formulaContext)
}

func (s *Fof_atomic_formulaContext) Fof_system_atomic_formula() IFof_system_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_system_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_system_atomic_formulaContext)
}

func (s *Fof_atomic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_atomic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_atomic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_atomic_formula(s)
	}
}

func (s *Fof_atomic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_atomic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_atomic_formula() (localctx IFof_atomic_formulaContext) {
	localctx = NewFof_atomic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, tptp_v7_0_0_0ParserRULE_fof_atomic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1141)
			p.Fof_plain_atomic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1142)
			p.Fof_defined_atomic_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1143)
			p.Fof_system_atomic_formula()
		}

	}

	return localctx
}

// IFof_plain_atomic_formulaContext is an interface to support dynamic dispatch.
type IFof_plain_atomic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_plain_atomic_formulaContext differentiates from other interfaces.
	IsFof_plain_atomic_formulaContext()
}

type Fof_plain_atomic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_plain_atomic_formulaContext() *Fof_plain_atomic_formulaContext {
	var p = new(Fof_plain_atomic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_plain_atomic_formula
	return p
}

func (*Fof_plain_atomic_formulaContext) IsFof_plain_atomic_formulaContext() {}

func NewFof_plain_atomic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_plain_atomic_formulaContext {
	var p = new(Fof_plain_atomic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_plain_atomic_formula

	return p
}

func (s *Fof_plain_atomic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_plain_atomic_formulaContext) Fof_plain_term() IFof_plain_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_plain_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_plain_termContext)
}

func (s *Fof_plain_atomic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_plain_atomic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_plain_atomic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_plain_atomic_formula(s)
	}
}

func (s *Fof_plain_atomic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_plain_atomic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_plain_atomic_formula() (localctx IFof_plain_atomic_formulaContext) {
	localctx = NewFof_plain_atomic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, tptp_v7_0_0_0ParserRULE_fof_plain_atomic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Fof_plain_term()
	}

	return localctx
}

// IFof_defined_atomic_formulaContext is an interface to support dynamic dispatch.
type IFof_defined_atomic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_defined_atomic_formulaContext differentiates from other interfaces.
	IsFof_defined_atomic_formulaContext()
}

type Fof_defined_atomic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_defined_atomic_formulaContext() *Fof_defined_atomic_formulaContext {
	var p = new(Fof_defined_atomic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_atomic_formula
	return p
}

func (*Fof_defined_atomic_formulaContext) IsFof_defined_atomic_formulaContext() {}

func NewFof_defined_atomic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_defined_atomic_formulaContext {
	var p = new(Fof_defined_atomic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_atomic_formula

	return p
}

func (s *Fof_defined_atomic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_defined_atomic_formulaContext) Fof_defined_plain_formula() IFof_defined_plain_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_plain_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_plain_formulaContext)
}

func (s *Fof_defined_atomic_formulaContext) Fof_defined_infix_formula() IFof_defined_infix_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_infix_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_infix_formulaContext)
}

func (s *Fof_defined_atomic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_defined_atomic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_defined_atomic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_defined_atomic_formula(s)
	}
}

func (s *Fof_defined_atomic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_defined_atomic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_defined_atomic_formula() (localctx IFof_defined_atomic_formulaContext) {
	localctx = NewFof_defined_atomic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, tptp_v7_0_0_0ParserRULE_fof_defined_atomic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1148)
			p.Fof_defined_plain_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1149)
			p.Fof_defined_infix_formula()
		}

	}

	return localctx
}

// IFof_defined_plain_formulaContext is an interface to support dynamic dispatch.
type IFof_defined_plain_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_defined_plain_formulaContext differentiates from other interfaces.
	IsFof_defined_plain_formulaContext()
}

type Fof_defined_plain_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_defined_plain_formulaContext() *Fof_defined_plain_formulaContext {
	var p = new(Fof_defined_plain_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_plain_formula
	return p
}

func (*Fof_defined_plain_formulaContext) IsFof_defined_plain_formulaContext() {}

func NewFof_defined_plain_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_defined_plain_formulaContext {
	var p = new(Fof_defined_plain_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_plain_formula

	return p
}

func (s *Fof_defined_plain_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_defined_plain_formulaContext) Fof_defined_term() IFof_defined_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_termContext)
}

func (s *Fof_defined_plain_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_defined_plain_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_defined_plain_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_defined_plain_formula(s)
	}
}

func (s *Fof_defined_plain_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_defined_plain_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_defined_plain_formula() (localctx IFof_defined_plain_formulaContext) {
	localctx = NewFof_defined_plain_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, tptp_v7_0_0_0ParserRULE_fof_defined_plain_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)
		p.Fof_defined_term()
	}

	return localctx
}

// IFof_defined_infix_formulaContext is an interface to support dynamic dispatch.
type IFof_defined_infix_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_defined_infix_formulaContext differentiates from other interfaces.
	IsFof_defined_infix_formulaContext()
}

type Fof_defined_infix_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_defined_infix_formulaContext() *Fof_defined_infix_formulaContext {
	var p = new(Fof_defined_infix_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_infix_formula
	return p
}

func (*Fof_defined_infix_formulaContext) IsFof_defined_infix_formulaContext() {}

func NewFof_defined_infix_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_defined_infix_formulaContext {
	var p = new(Fof_defined_infix_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_infix_formula

	return p
}

func (s *Fof_defined_infix_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_defined_infix_formulaContext) AllFof_term() []IFof_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_termContext)(nil)).Elem())
	var tst = make([]IFof_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_termContext)
		}
	}

	return tst
}

func (s *Fof_defined_infix_formulaContext) Fof_term(i int) IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Fof_defined_infix_formulaContext) Defined_infix_pred() IDefined_infix_predContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_infix_predContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_infix_predContext)
}

func (s *Fof_defined_infix_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_defined_infix_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_defined_infix_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_defined_infix_formula(s)
	}
}

func (s *Fof_defined_infix_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_defined_infix_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_defined_infix_formula() (localctx IFof_defined_infix_formulaContext) {
	localctx = NewFof_defined_infix_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, tptp_v7_0_0_0ParserRULE_fof_defined_infix_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Fof_term()
	}
	{
		p.SetState(1155)
		p.Defined_infix_pred()
	}
	{
		p.SetState(1156)
		p.Fof_term()
	}

	return localctx
}

// IFof_system_atomic_formulaContext is an interface to support dynamic dispatch.
type IFof_system_atomic_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_system_atomic_formulaContext differentiates from other interfaces.
	IsFof_system_atomic_formulaContext()
}

type Fof_system_atomic_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_system_atomic_formulaContext() *Fof_system_atomic_formulaContext {
	var p = new(Fof_system_atomic_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_system_atomic_formula
	return p
}

func (*Fof_system_atomic_formulaContext) IsFof_system_atomic_formulaContext() {}

func NewFof_system_atomic_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_system_atomic_formulaContext {
	var p = new(Fof_system_atomic_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_system_atomic_formula

	return p
}

func (s *Fof_system_atomic_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_system_atomic_formulaContext) Fof_system_term() IFof_system_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_system_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_system_termContext)
}

func (s *Fof_system_atomic_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_system_atomic_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_system_atomic_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_system_atomic_formula(s)
	}
}

func (s *Fof_system_atomic_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_system_atomic_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_system_atomic_formula() (localctx IFof_system_atomic_formulaContext) {
	localctx = NewFof_system_atomic_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, tptp_v7_0_0_0ParserRULE_fof_system_atomic_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1158)
		p.Fof_system_term()
	}

	return localctx
}

// IFof_plain_termContext is an interface to support dynamic dispatch.
type IFof_plain_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_plain_termContext differentiates from other interfaces.
	IsFof_plain_termContext()
}

type Fof_plain_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_plain_termContext() *Fof_plain_termContext {
	var p = new(Fof_plain_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_plain_term
	return p
}

func (*Fof_plain_termContext) IsFof_plain_termContext() {}

func NewFof_plain_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_plain_termContext {
	var p = new(Fof_plain_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_plain_term

	return p
}

func (s *Fof_plain_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_plain_termContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Fof_plain_termContext) Functor() IFunctorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctorContext)
}

func (s *Fof_plain_termContext) Fof_arguments() IFof_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_argumentsContext)
}

func (s *Fof_plain_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_plain_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_plain_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_plain_term(s)
	}
}

func (s *Fof_plain_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_plain_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_plain_term() (localctx IFof_plain_termContext) {
	localctx = NewFof_plain_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, tptp_v7_0_0_0ParserRULE_fof_plain_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1160)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1161)
			p.Functor()
		}
		{
			p.SetState(1162)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1163)
			p.Fof_arguments()
		}
		{
			p.SetState(1164)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// IFof_defined_termContext is an interface to support dynamic dispatch.
type IFof_defined_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_defined_termContext differentiates from other interfaces.
	IsFof_defined_termContext()
}

type Fof_defined_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_defined_termContext() *Fof_defined_termContext {
	var p = new(Fof_defined_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_term
	return p
}

func (*Fof_defined_termContext) IsFof_defined_termContext() {}

func NewFof_defined_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_defined_termContext {
	var p = new(Fof_defined_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_term

	return p
}

func (s *Fof_defined_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_defined_termContext) Defined_term() IDefined_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_termContext)
}

func (s *Fof_defined_termContext) Fof_defined_atomic_term() IFof_defined_atomic_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_atomic_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_atomic_termContext)
}

func (s *Fof_defined_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_defined_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_defined_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_defined_term(s)
	}
}

func (s *Fof_defined_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_defined_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_defined_term() (localctx IFof_defined_termContext) {
	localctx = NewFof_defined_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, tptp_v7_0_0_0ParserRULE_fof_defined_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1170)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1168)
			p.Defined_term()
		}

	case tptp_v7_0_0_0ParserDollar_word:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1169)
			p.Fof_defined_atomic_term()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_defined_atomic_termContext is an interface to support dynamic dispatch.
type IFof_defined_atomic_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_defined_atomic_termContext differentiates from other interfaces.
	IsFof_defined_atomic_termContext()
}

type Fof_defined_atomic_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_defined_atomic_termContext() *Fof_defined_atomic_termContext {
	var p = new(Fof_defined_atomic_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_atomic_term
	return p
}

func (*Fof_defined_atomic_termContext) IsFof_defined_atomic_termContext() {}

func NewFof_defined_atomic_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_defined_atomic_termContext {
	var p = new(Fof_defined_atomic_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_atomic_term

	return p
}

func (s *Fof_defined_atomic_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_defined_atomic_termContext) Fof_defined_plain_term() IFof_defined_plain_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_plain_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_plain_termContext)
}

func (s *Fof_defined_atomic_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_defined_atomic_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_defined_atomic_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_defined_atomic_term(s)
	}
}

func (s *Fof_defined_atomic_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_defined_atomic_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_defined_atomic_term() (localctx IFof_defined_atomic_termContext) {
	localctx = NewFof_defined_atomic_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, tptp_v7_0_0_0ParserRULE_fof_defined_atomic_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1172)
		p.Fof_defined_plain_term()
	}

	return localctx
}

// IFof_defined_plain_termContext is an interface to support dynamic dispatch.
type IFof_defined_plain_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_defined_plain_termContext differentiates from other interfaces.
	IsFof_defined_plain_termContext()
}

type Fof_defined_plain_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_defined_plain_termContext() *Fof_defined_plain_termContext {
	var p = new(Fof_defined_plain_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_plain_term
	return p
}

func (*Fof_defined_plain_termContext) IsFof_defined_plain_termContext() {}

func NewFof_defined_plain_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_defined_plain_termContext {
	var p = new(Fof_defined_plain_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_defined_plain_term

	return p
}

func (s *Fof_defined_plain_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_defined_plain_termContext) Defined_constant() IDefined_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_constantContext)
}

func (s *Fof_defined_plain_termContext) Defined_functor() IDefined_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_functorContext)
}

func (s *Fof_defined_plain_termContext) Fof_arguments() IFof_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_argumentsContext)
}

func (s *Fof_defined_plain_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_defined_plain_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_defined_plain_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_defined_plain_term(s)
	}
}

func (s *Fof_defined_plain_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_defined_plain_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_defined_plain_term() (localctx IFof_defined_plain_termContext) {
	localctx = NewFof_defined_plain_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, tptp_v7_0_0_0ParserRULE_fof_defined_plain_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1174)
			p.Defined_constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1175)
			p.Defined_functor()
		}
		{
			p.SetState(1176)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1177)
			p.Fof_arguments()
		}
		{
			p.SetState(1178)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// IFof_system_termContext is an interface to support dynamic dispatch.
type IFof_system_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_system_termContext differentiates from other interfaces.
	IsFof_system_termContext()
}

type Fof_system_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_system_termContext() *Fof_system_termContext {
	var p = new(Fof_system_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_system_term
	return p
}

func (*Fof_system_termContext) IsFof_system_termContext() {}

func NewFof_system_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_system_termContext {
	var p = new(Fof_system_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_system_term

	return p
}

func (s *Fof_system_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_system_termContext) System_constant() ISystem_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_constantContext)
}

func (s *Fof_system_termContext) System_functor() ISystem_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_functorContext)
}

func (s *Fof_system_termContext) Fof_arguments() IFof_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_argumentsContext)
}

func (s *Fof_system_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_system_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_system_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_system_term(s)
	}
}

func (s *Fof_system_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_system_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_system_term() (localctx IFof_system_termContext) {
	localctx = NewFof_system_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, tptp_v7_0_0_0ParserRULE_fof_system_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1182)
			p.System_constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1183)
			p.System_functor()
		}
		{
			p.SetState(1184)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1185)
			p.Fof_arguments()
		}
		{
			p.SetState(1186)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	}

	return localctx
}

// IFof_argumentsContext is an interface to support dynamic dispatch.
type IFof_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_argumentsContext differentiates from other interfaces.
	IsFof_argumentsContext()
}

type Fof_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_argumentsContext() *Fof_argumentsContext {
	var p = new(Fof_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_arguments
	return p
}

func (*Fof_argumentsContext) IsFof_argumentsContext() {}

func NewFof_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_argumentsContext {
	var p = new(Fof_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_arguments

	return p
}

func (s *Fof_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_argumentsContext) AllFof_term() []IFof_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_termContext)(nil)).Elem())
	var tst = make([]IFof_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_termContext)
		}
	}

	return tst
}

func (s *Fof_argumentsContext) Fof_term(i int) IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Fof_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_arguments(s)
	}
}

func (s *Fof_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_arguments(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_arguments() (localctx IFof_argumentsContext) {
	localctx = NewFof_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, tptp_v7_0_0_0ParserRULE_fof_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)
		p.Fof_term()
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1191)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1192)
			p.Fof_term()
		}

		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFof_termContext is an interface to support dynamic dispatch.
type IFof_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_termContext differentiates from other interfaces.
	IsFof_termContext()
}

type Fof_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_termContext() *Fof_termContext {
	var p = new(Fof_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_term
	return p
}

func (*Fof_termContext) IsFof_termContext() {}

func NewFof_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_termContext {
	var p = new(Fof_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_term

	return p
}

func (s *Fof_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_termContext) Fof_function_term() IFof_function_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_function_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_function_termContext)
}

func (s *Fof_termContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fof_termContext) Tff_conditional_term() ITff_conditional_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_conditional_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_conditional_termContext)
}

func (s *Fof_termContext) Tff_let_term() ITff_let_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_termContext)
}

func (s *Fof_termContext) Tff_tuple_term() ITff_tuple_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_tuple_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_tuple_termContext)
}

func (s *Fof_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_term(s)
	}
}

func (s *Fof_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_term() (localctx IFof_termContext) {
	localctx = NewFof_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, tptp_v7_0_0_0ParserRULE_fof_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1203)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1198)
			p.Fof_function_term()
		}

	case tptp_v7_0_0_0ParserUpper_word:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1199)
			p.Variable()
		}

	case tptp_v7_0_0_0ParserT__23:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1200)
			p.Tff_conditional_term()
		}

	case tptp_v7_0_0_0ParserT__24, tptp_v7_0_0_0ParserT__25:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1201)
			p.Tff_let_term()
		}

	case tptp_v7_0_0_0ParserT__17, tptp_v7_0_0_0ParserT__18:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1202)
			p.Tff_tuple_term()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_function_termContext is an interface to support dynamic dispatch.
type IFof_function_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_function_termContext differentiates from other interfaces.
	IsFof_function_termContext()
}

type Fof_function_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_function_termContext() *Fof_function_termContext {
	var p = new(Fof_function_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_function_term
	return p
}

func (*Fof_function_termContext) IsFof_function_termContext() {}

func NewFof_function_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_function_termContext {
	var p = new(Fof_function_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_function_term

	return p
}

func (s *Fof_function_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_function_termContext) Fof_plain_term() IFof_plain_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_plain_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_plain_termContext)
}

func (s *Fof_function_termContext) Fof_defined_term() IFof_defined_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_defined_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_defined_termContext)
}

func (s *Fof_function_termContext) Fof_system_term() IFof_system_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_system_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_system_termContext)
}

func (s *Fof_function_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_function_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_function_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_function_term(s)
	}
}

func (s *Fof_function_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_function_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_function_term() (localctx IFof_function_termContext) {
	localctx = NewFof_function_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, tptp_v7_0_0_0ParserRULE_fof_function_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1208)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1205)
			p.Fof_plain_term()
		}

	case tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1206)
			p.Fof_defined_term()
		}

	case tptp_v7_0_0_0ParserDollar_dollar_word:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1207)
			p.Fof_system_term()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_conditional_termContext is an interface to support dynamic dispatch.
type ITff_conditional_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_conditional_termContext differentiates from other interfaces.
	IsTff_conditional_termContext()
}

type Tff_conditional_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_conditional_termContext() *Tff_conditional_termContext {
	var p = new(Tff_conditional_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_conditional_term
	return p
}

func (*Tff_conditional_termContext) IsTff_conditional_termContext() {}

func NewTff_conditional_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_conditional_termContext {
	var p = new(Tff_conditional_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_conditional_term

	return p
}

func (s *Tff_conditional_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_conditional_termContext) Tff_logic_formula() ITff_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_logic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_logic_formulaContext)
}

func (s *Tff_conditional_termContext) AllFof_term() []IFof_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_termContext)(nil)).Elem())
	var tst = make([]IFof_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_termContext)
		}
	}

	return tst
}

func (s *Tff_conditional_termContext) Fof_term(i int) IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Tff_conditional_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_conditional_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_conditional_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_conditional_term(s)
	}
}

func (s *Tff_conditional_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_conditional_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_conditional_term() (localctx ITff_conditional_termContext) {
	localctx = NewTff_conditional_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, tptp_v7_0_0_0ParserRULE_tff_conditional_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Match(tptp_v7_0_0_0ParserT__23)
	}
	{
		p.SetState(1211)
		p.Tff_logic_formula()
	}
	{
		p.SetState(1212)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1213)
		p.Fof_term()
	}
	{
		p.SetState(1214)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1215)
		p.Fof_term()
	}
	{
		p.SetState(1216)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// ITff_let_termContext is an interface to support dynamic dispatch.
type ITff_let_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_let_termContext differentiates from other interfaces.
	IsTff_let_termContext()
}

type Tff_let_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_let_termContext() *Tff_let_termContext {
	var p = new(Tff_let_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term
	return p
}

func (*Tff_let_termContext) IsTff_let_termContext() {}

func NewTff_let_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_let_termContext {
	var p = new(Tff_let_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_let_term

	return p
}

func (s *Tff_let_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_let_termContext) Tff_let_formula_defns() ITff_let_formula_defnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_formula_defnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_formula_defnsContext)
}

func (s *Tff_let_termContext) Fof_term() IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Tff_let_termContext) Tff_let_term_defns() ITff_let_term_defnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_let_term_defnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_let_term_defnsContext)
}

func (s *Tff_let_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_let_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_let_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_let_term(s)
	}
}

func (s *Tff_let_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_let_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_let_term() (localctx ITff_let_termContext) {
	localctx = NewTff_let_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, tptp_v7_0_0_0ParserRULE_tff_let_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1230)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__24:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1218)
			p.Match(tptp_v7_0_0_0ParserT__24)
		}
		{
			p.SetState(1219)
			p.Tff_let_formula_defns()
		}
		{
			p.SetState(1220)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1221)
			p.Fof_term()
		}
		{
			p.SetState(1222)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1224)
			p.Match(tptp_v7_0_0_0ParserT__25)
		}
		{
			p.SetState(1225)
			p.Tff_let_term_defns()
		}
		{
			p.SetState(1226)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1227)
			p.Fof_term()
		}
		{
			p.SetState(1228)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITff_tuple_termContext is an interface to support dynamic dispatch.
type ITff_tuple_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_tuple_termContext differentiates from other interfaces.
	IsTff_tuple_termContext()
}

type Tff_tuple_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_tuple_termContext() *Tff_tuple_termContext {
	var p = new(Tff_tuple_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_tuple_term
	return p
}

func (*Tff_tuple_termContext) IsTff_tuple_termContext() {}

func NewTff_tuple_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_tuple_termContext {
	var p = new(Tff_tuple_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_tuple_term

	return p
}

func (s *Tff_tuple_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_tuple_termContext) Fof_arguments() IFof_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_argumentsContext)
}

func (s *Tff_tuple_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_tuple_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_tuple_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_tuple_term(s)
	}
}

func (s *Tff_tuple_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_tuple_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_tuple_term() (localctx ITff_tuple_termContext) {
	localctx = NewTff_tuple_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, tptp_v7_0_0_0ParserRULE_tff_tuple_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1237)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1232)
			p.Match(tptp_v7_0_0_0ParserT__17)
		}

	case tptp_v7_0_0_0ParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1233)
			p.Match(tptp_v7_0_0_0ParserT__18)
		}
		{
			p.SetState(1234)
			p.Fof_arguments()
		}
		{
			p.SetState(1235)
			p.Match(tptp_v7_0_0_0ParserT__19)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_sequentContext is an interface to support dynamic dispatch.
type IFof_sequentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_sequentContext differentiates from other interfaces.
	IsFof_sequentContext()
}

type Fof_sequentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_sequentContext() *Fof_sequentContext {
	var p = new(Fof_sequentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_sequent
	return p
}

func (*Fof_sequentContext) IsFof_sequentContext() {}

func NewFof_sequentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_sequentContext {
	var p = new(Fof_sequentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_sequent

	return p
}

func (s *Fof_sequentContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_sequentContext) AllFof_formula_tuple() []IFof_formula_tupleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_formula_tupleContext)(nil)).Elem())
	var tst = make([]IFof_formula_tupleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_formula_tupleContext)
		}
	}

	return tst
}

func (s *Fof_sequentContext) Fof_formula_tuple(i int) IFof_formula_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_formula_tupleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_formula_tupleContext)
}

func (s *Fof_sequentContext) Gentzen_arrow() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserGentzen_arrow, 0)
}

func (s *Fof_sequentContext) Fof_sequent() IFof_sequentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_sequentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_sequentContext)
}

func (s *Fof_sequentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_sequentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_sequentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_sequent(s)
	}
}

func (s *Fof_sequentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_sequent(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_sequent() (localctx IFof_sequentContext) {
	localctx = NewFof_sequentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, tptp_v7_0_0_0ParserRULE_fof_sequent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1247)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__11, tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1239)
			p.Fof_formula_tuple()
		}
		{
			p.SetState(1240)
			p.Match(tptp_v7_0_0_0ParserGentzen_arrow)
		}
		{
			p.SetState(1241)
			p.Fof_formula_tuple()
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1243)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1244)
			p.Fof_sequent()
		}
		{
			p.SetState(1245)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_formula_tupleContext is an interface to support dynamic dispatch.
type IFof_formula_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_formula_tupleContext differentiates from other interfaces.
	IsFof_formula_tupleContext()
}

type Fof_formula_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_formula_tupleContext() *Fof_formula_tupleContext {
	var p = new(Fof_formula_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_formula_tuple
	return p
}

func (*Fof_formula_tupleContext) IsFof_formula_tupleContext() {}

func NewFof_formula_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_formula_tupleContext {
	var p = new(Fof_formula_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_formula_tuple

	return p
}

func (s *Fof_formula_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_formula_tupleContext) Fof_formula_tuple_list() IFof_formula_tuple_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_formula_tuple_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_formula_tuple_listContext)
}

func (s *Fof_formula_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_formula_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_formula_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_formula_tuple(s)
	}
}

func (s *Fof_formula_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_formula_tuple(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_formula_tuple() (localctx IFof_formula_tupleContext) {
	localctx = NewFof_formula_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, tptp_v7_0_0_0ParserRULE_fof_formula_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1254)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1249)
			p.Match(tptp_v7_0_0_0ParserT__16)
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1250)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(1251)
			p.Fof_formula_tuple_list()
		}
		{
			p.SetState(1252)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_formula_tuple_listContext is an interface to support dynamic dispatch.
type IFof_formula_tuple_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_formula_tuple_listContext differentiates from other interfaces.
	IsFof_formula_tuple_listContext()
}

type Fof_formula_tuple_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_formula_tuple_listContext() *Fof_formula_tuple_listContext {
	var p = new(Fof_formula_tuple_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_formula_tuple_list
	return p
}

func (*Fof_formula_tuple_listContext) IsFof_formula_tuple_listContext() {}

func NewFof_formula_tuple_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_formula_tuple_listContext {
	var p = new(Fof_formula_tuple_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_formula_tuple_list

	return p
}

func (s *Fof_formula_tuple_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_formula_tuple_listContext) AllFof_logic_formula() []IFof_logic_formulaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFof_logic_formulaContext)(nil)).Elem())
	var tst = make([]IFof_logic_formulaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFof_logic_formulaContext)
		}
	}

	return tst
}

func (s *Fof_formula_tuple_listContext) Fof_logic_formula(i int) IFof_logic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_logic_formulaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFof_logic_formulaContext)
}

func (s *Fof_formula_tuple_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_formula_tuple_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_formula_tuple_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_formula_tuple_list(s)
	}
}

func (s *Fof_formula_tuple_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_formula_tuple_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_formula_tuple_list() (localctx IFof_formula_tuple_listContext) {
	localctx = NewFof_formula_tuple_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, tptp_v7_0_0_0ParserRULE_fof_formula_tuple_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.Fof_logic_formula()
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1257)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1258)
			p.Fof_logic_formula()
		}

		p.SetState(1263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICnf_formulaContext is an interface to support dynamic dispatch.
type ICnf_formulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCnf_formulaContext differentiates from other interfaces.
	IsCnf_formulaContext()
}

type Cnf_formulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCnf_formulaContext() *Cnf_formulaContext {
	var p = new(Cnf_formulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_formula
	return p
}

func (*Cnf_formulaContext) IsCnf_formulaContext() {}

func NewCnf_formulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cnf_formulaContext {
	var p = new(Cnf_formulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_formula

	return p
}

func (s *Cnf_formulaContext) GetParser() antlr.Parser { return s.parser }

func (s *Cnf_formulaContext) Cnf_disjunction() ICnf_disjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_disjunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_disjunctionContext)
}

func (s *Cnf_formulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cnf_formulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cnf_formulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterCnf_formula(s)
	}
}

func (s *Cnf_formulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitCnf_formula(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Cnf_formula() (localctx ICnf_formulaContext) {
	localctx = NewCnf_formulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, tptp_v7_0_0_0ParserRULE_cnf_formula)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1269)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__17, tptp_v7_0_0_0ParserT__18, tptp_v7_0_0_0ParserT__23, tptp_v7_0_0_0ParserT__24, tptp_v7_0_0_0ParserT__25, tptp_v7_0_0_0ParserNot, tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserDollar_word, tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserUpper_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted, tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1264)
			p.cnf_disjunction(0)
		}

	case tptp_v7_0_0_0ParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1265)
			p.Match(tptp_v7_0_0_0ParserT__9)
		}
		{
			p.SetState(1266)
			p.cnf_disjunction(0)
		}
		{
			p.SetState(1267)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICnf_disjunctionContext is an interface to support dynamic dispatch.
type ICnf_disjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCnf_disjunctionContext differentiates from other interfaces.
	IsCnf_disjunctionContext()
}

type Cnf_disjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCnf_disjunctionContext() *Cnf_disjunctionContext {
	var p = new(Cnf_disjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_disjunction
	return p
}

func (*Cnf_disjunctionContext) IsCnf_disjunctionContext() {}

func NewCnf_disjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cnf_disjunctionContext {
	var p = new(Cnf_disjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_disjunction

	return p
}

func (s *Cnf_disjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cnf_disjunctionContext) Cnf_literal() ICnf_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_literalContext)
}

func (s *Cnf_disjunctionContext) Cnf_disjunction() ICnf_disjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_disjunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_disjunctionContext)
}

func (s *Cnf_disjunctionContext) Or() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserOr, 0)
}

func (s *Cnf_disjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cnf_disjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cnf_disjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterCnf_disjunction(s)
	}
}

func (s *Cnf_disjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitCnf_disjunction(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Cnf_disjunction() (localctx ICnf_disjunctionContext) {
	return p.cnf_disjunction(0)
}

func (p *tptp_v7_0_0_0Parser) cnf_disjunction(_p int) (localctx ICnf_disjunctionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewCnf_disjunctionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ICnf_disjunctionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 244
	p.EnterRecursionRule(localctx, 244, tptp_v7_0_0_0ParserRULE_cnf_disjunction, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1272)
		p.Cnf_literal()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1279)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewCnf_disjunctionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, tptp_v7_0_0_0ParserRULE_cnf_disjunction)
			p.SetState(1274)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1275)
				p.Match(tptp_v7_0_0_0ParserOr)
			}
			{
				p.SetState(1276)
				p.Cnf_literal()
			}

		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}

	return localctx
}

// ICnf_literalContext is an interface to support dynamic dispatch.
type ICnf_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCnf_literalContext differentiates from other interfaces.
	IsCnf_literalContext()
}

type Cnf_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCnf_literalContext() *Cnf_literalContext {
	var p = new(Cnf_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_literal
	return p
}

func (*Cnf_literalContext) IsCnf_literalContext() {}

func NewCnf_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cnf_literalContext {
	var p = new(Cnf_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_cnf_literal

	return p
}

func (s *Cnf_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Cnf_literalContext) Fof_atomic_formula() IFof_atomic_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_atomic_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_atomic_formulaContext)
}

func (s *Cnf_literalContext) Not() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserNot, 0)
}

func (s *Cnf_literalContext) Fof_infix_unary() IFof_infix_unaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_infix_unaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_infix_unaryContext)
}

func (s *Cnf_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cnf_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cnf_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterCnf_literal(s)
	}
}

func (s *Cnf_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitCnf_literal(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Cnf_literal() (localctx ICnf_literalContext) {
	localctx = NewCnf_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, tptp_v7_0_0_0ParserRULE_cnf_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1282)
			p.Fof_atomic_formula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1283)
			p.Match(tptp_v7_0_0_0ParserNot)
		}
		{
			p.SetState(1284)
			p.Fof_atomic_formula()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1285)
			p.Fof_infix_unary()
		}

	}

	return localctx
}

// IThf_quantifierContext is an interface to support dynamic dispatch.
type IThf_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_quantifierContext differentiates from other interfaces.
	IsThf_quantifierContext()
}

type Thf_quantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_quantifierContext() *Thf_quantifierContext {
	var p = new(Thf_quantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_quantifier
	return p
}

func (*Thf_quantifierContext) IsThf_quantifierContext() {}

func NewThf_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_quantifierContext {
	var p = new(Thf_quantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_quantifier

	return p
}

func (s *Thf_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_quantifierContext) Fof_quantifier() IFof_quantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_quantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_quantifierContext)
}

func (s *Thf_quantifierContext) Th0_quantifier() ITh0_quantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITh0_quantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITh0_quantifierContext)
}

func (s *Thf_quantifierContext) Th1_quantifier() ITh1_quantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITh1_quantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITh1_quantifierContext)
}

func (s *Thf_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_quantifier(s)
	}
}

func (s *Thf_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_quantifier(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_quantifier() (localctx IThf_quantifierContext) {
	localctx = NewThf_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, tptp_v7_0_0_0ParserRULE_thf_quantifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1291)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserForall, tptp_v7_0_0_0ParserExists:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1288)
			p.Fof_quantifier()
		}

	case tptp_v7_0_0_0ParserLambda, tptp_v7_0_0_0ParserChoice, tptp_v7_0_0_0ParserDescription:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1289)
			p.Th0_quantifier()
		}

	case tptp_v7_0_0_0ParserTyForall, tptp_v7_0_0_0ParserTyExists:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1290)
			p.Th1_quantifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITh0_quantifierContext is an interface to support dynamic dispatch.
type ITh0_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTh0_quantifierContext differentiates from other interfaces.
	IsTh0_quantifierContext()
}

type Th0_quantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTh0_quantifierContext() *Th0_quantifierContext {
	var p = new(Th0_quantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_th0_quantifier
	return p
}

func (*Th0_quantifierContext) IsTh0_quantifierContext() {}

func NewTh0_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Th0_quantifierContext {
	var p = new(Th0_quantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_th0_quantifier

	return p
}

func (s *Th0_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Th0_quantifierContext) Lambda() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLambda, 0)
}

func (s *Th0_quantifierContext) Choice() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserChoice, 0)
}

func (s *Th0_quantifierContext) Description() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDescription, 0)
}

func (s *Th0_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Th0_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Th0_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTh0_quantifier(s)
	}
}

func (s *Th0_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTh0_quantifier(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Th0_quantifier() (localctx ITh0_quantifierContext) {
	localctx = NewTh0_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, tptp_v7_0_0_0ParserRULE_th0_quantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1293)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(tptp_v7_0_0_0ParserLambda-61))|(1<<(tptp_v7_0_0_0ParserChoice-61))|(1<<(tptp_v7_0_0_0ParserDescription-61)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITh1_quantifierContext is an interface to support dynamic dispatch.
type ITh1_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTh1_quantifierContext differentiates from other interfaces.
	IsTh1_quantifierContext()
}

type Th1_quantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTh1_quantifierContext() *Th1_quantifierContext {
	var p = new(Th1_quantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_th1_quantifier
	return p
}

func (*Th1_quantifierContext) IsTh1_quantifierContext() {}

func NewTh1_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Th1_quantifierContext {
	var p = new(Th1_quantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_th1_quantifier

	return p
}

func (s *Th1_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Th1_quantifierContext) TyForall() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserTyForall, 0)
}

func (s *Th1_quantifierContext) TyExists() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserTyExists, 0)
}

func (s *Th1_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Th1_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Th1_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTh1_quantifier(s)
	}
}

func (s *Th1_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTh1_quantifier(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Th1_quantifier() (localctx ITh1_quantifierContext) {
	localctx = NewTh1_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, tptp_v7_0_0_0ParserRULE_th1_quantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		_la = p.GetTokenStream().LA(1)

		if !(_la == tptp_v7_0_0_0ParserTyForall || _la == tptp_v7_0_0_0ParserTyExists) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IThf_pair_connectiveContext is an interface to support dynamic dispatch.
type IThf_pair_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_pair_connectiveContext differentiates from other interfaces.
	IsThf_pair_connectiveContext()
}

type Thf_pair_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_pair_connectiveContext() *Thf_pair_connectiveContext {
	var p = new(Thf_pair_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_pair_connective
	return p
}

func (*Thf_pair_connectiveContext) IsThf_pair_connectiveContext() {}

func NewThf_pair_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_pair_connectiveContext {
	var p = new(Thf_pair_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_pair_connective

	return p
}

func (s *Thf_pair_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_pair_connectiveContext) Infix_equality() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInfix_equality, 0)
}

func (s *Thf_pair_connectiveContext) Infix_inequality() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInfix_inequality, 0)
}

func (s *Thf_pair_connectiveContext) Binary_connective() IBinary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_connectiveContext)
}

func (s *Thf_pair_connectiveContext) Assignment() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAssignment, 0)
}

func (s *Thf_pair_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_pair_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_pair_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_pair_connective(s)
	}
}

func (s *Thf_pair_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_pair_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_pair_connective() (localctx IThf_pair_connectiveContext) {
	localctx = NewThf_pair_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, tptp_v7_0_0_0ParserRULE_thf_pair_connective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1301)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserInfix_equality:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1297)
			p.Match(tptp_v7_0_0_0ParserInfix_equality)
		}

	case tptp_v7_0_0_0ParserInfix_inequality:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1298)
			p.Match(tptp_v7_0_0_0ParserInfix_inequality)
		}

	case tptp_v7_0_0_0ParserIff, tptp_v7_0_0_0ParserImpl, tptp_v7_0_0_0ParserIf, tptp_v7_0_0_0ParserNiff, tptp_v7_0_0_0ParserNor, tptp_v7_0_0_0ParserNand:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1299)
			p.Binary_connective()
		}

	case tptp_v7_0_0_0ParserAssignment:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1300)
			p.Match(tptp_v7_0_0_0ParserAssignment)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IThf_unary_connectiveContext is an interface to support dynamic dispatch.
type IThf_unary_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThf_unary_connectiveContext differentiates from other interfaces.
	IsThf_unary_connectiveContext()
}

type Thf_unary_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThf_unary_connectiveContext() *Thf_unary_connectiveContext {
	var p = new(Thf_unary_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unary_connective
	return p
}

func (*Thf_unary_connectiveContext) IsThf_unary_connectiveContext() {}

func NewThf_unary_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Thf_unary_connectiveContext {
	var p = new(Thf_unary_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_thf_unary_connective

	return p
}

func (s *Thf_unary_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Thf_unary_connectiveContext) Unary_connective() IUnary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_connectiveContext)
}

func (s *Thf_unary_connectiveContext) Th1_unary_connective() ITh1_unary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITh1_unary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITh1_unary_connectiveContext)
}

func (s *Thf_unary_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Thf_unary_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Thf_unary_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterThf_unary_connective(s)
	}
}

func (s *Thf_unary_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitThf_unary_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_unary_connective() (localctx IThf_unary_connectiveContext) {
	localctx = NewThf_unary_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, tptp_v7_0_0_0ParserRULE_thf_unary_connective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1305)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserNot:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1303)
			p.Unary_connective()
		}

	case tptp_v7_0_0_0ParserForallComb, tptp_v7_0_0_0ParserExistsComb, tptp_v7_0_0_0ParserChoiceComb, tptp_v7_0_0_0ParserDescriptionComb, tptp_v7_0_0_0ParserEqComb:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1304)
			p.Th1_unary_connective()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITh1_unary_connectiveContext is an interface to support dynamic dispatch.
type ITh1_unary_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTh1_unary_connectiveContext differentiates from other interfaces.
	IsTh1_unary_connectiveContext()
}

type Th1_unary_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTh1_unary_connectiveContext() *Th1_unary_connectiveContext {
	var p = new(Th1_unary_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_th1_unary_connective
	return p
}

func (*Th1_unary_connectiveContext) IsTh1_unary_connectiveContext() {}

func NewTh1_unary_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Th1_unary_connectiveContext {
	var p = new(Th1_unary_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_th1_unary_connective

	return p
}

func (s *Th1_unary_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Th1_unary_connectiveContext) ForallComb() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserForallComb, 0)
}

func (s *Th1_unary_connectiveContext) ExistsComb() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserExistsComb, 0)
}

func (s *Th1_unary_connectiveContext) ChoiceComb() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserChoiceComb, 0)
}

func (s *Th1_unary_connectiveContext) DescriptionComb() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDescriptionComb, 0)
}

func (s *Th1_unary_connectiveContext) EqComb() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserEqComb, 0)
}

func (s *Th1_unary_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Th1_unary_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Th1_unary_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTh1_unary_connective(s)
	}
}

func (s *Th1_unary_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTh1_unary_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Th1_unary_connective() (localctx ITh1_unary_connectiveContext) {
	localctx = NewTh1_unary_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, tptp_v7_0_0_0ParserRULE_th1_unary_connective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1307)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(tptp_v7_0_0_0ParserForallComb-53))|(1<<(tptp_v7_0_0_0ParserExistsComb-53))|(1<<(tptp_v7_0_0_0ParserChoiceComb-53))|(1<<(tptp_v7_0_0_0ParserDescriptionComb-53))|(1<<(tptp_v7_0_0_0ParserEqComb-53)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITff_pair_connectiveContext is an interface to support dynamic dispatch.
type ITff_pair_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTff_pair_connectiveContext differentiates from other interfaces.
	IsTff_pair_connectiveContext()
}

type Tff_pair_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTff_pair_connectiveContext() *Tff_pair_connectiveContext {
	var p = new(Tff_pair_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_pair_connective
	return p
}

func (*Tff_pair_connectiveContext) IsTff_pair_connectiveContext() {}

func NewTff_pair_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tff_pair_connectiveContext {
	var p = new(Tff_pair_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_tff_pair_connective

	return p
}

func (s *Tff_pair_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Tff_pair_connectiveContext) Binary_connective() IBinary_connectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_connectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_connectiveContext)
}

func (s *Tff_pair_connectiveContext) Assignment() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAssignment, 0)
}

func (s *Tff_pair_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tff_pair_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tff_pair_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTff_pair_connective(s)
	}
}

func (s *Tff_pair_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTff_pair_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_pair_connective() (localctx ITff_pair_connectiveContext) {
	localctx = NewTff_pair_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, tptp_v7_0_0_0ParserRULE_tff_pair_connective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1311)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserIff, tptp_v7_0_0_0ParserImpl, tptp_v7_0_0_0ParserIf, tptp_v7_0_0_0ParserNiff, tptp_v7_0_0_0ParserNor, tptp_v7_0_0_0ParserNand:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1309)
			p.Binary_connective()
		}

	case tptp_v7_0_0_0ParserAssignment:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1310)
			p.Match(tptp_v7_0_0_0ParserAssignment)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFof_quantifierContext is an interface to support dynamic dispatch.
type IFof_quantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFof_quantifierContext differentiates from other interfaces.
	IsFof_quantifierContext()
}

type Fof_quantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFof_quantifierContext() *Fof_quantifierContext {
	var p = new(Fof_quantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_quantifier
	return p
}

func (*Fof_quantifierContext) IsFof_quantifierContext() {}

func NewFof_quantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fof_quantifierContext {
	var p = new(Fof_quantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_fof_quantifier

	return p
}

func (s *Fof_quantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Fof_quantifierContext) Forall() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserForall, 0)
}

func (s *Fof_quantifierContext) Exists() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserExists, 0)
}

func (s *Fof_quantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fof_quantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fof_quantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFof_quantifier(s)
	}
}

func (s *Fof_quantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFof_quantifier(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_quantifier() (localctx IFof_quantifierContext) {
	localctx = NewFof_quantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, tptp_v7_0_0_0ParserRULE_fof_quantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1313)
		_la = p.GetTokenStream().LA(1)

		if !(_la == tptp_v7_0_0_0ParserForall || _la == tptp_v7_0_0_0ParserExists) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_connectiveContext is an interface to support dynamic dispatch.
type IBinary_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_connectiveContext differentiates from other interfaces.
	IsBinary_connectiveContext()
}

type Binary_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_connectiveContext() *Binary_connectiveContext {
	var p = new(Binary_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_binary_connective
	return p
}

func (*Binary_connectiveContext) IsBinary_connectiveContext() {}

func NewBinary_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_connectiveContext {
	var p = new(Binary_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_binary_connective

	return p
}

func (s *Binary_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_connectiveContext) Iff() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserIff, 0)
}

func (s *Binary_connectiveContext) Impl() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserImpl, 0)
}

func (s *Binary_connectiveContext) If() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserIf, 0)
}

func (s *Binary_connectiveContext) Niff() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserNiff, 0)
}

func (s *Binary_connectiveContext) Nor() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserNor, 0)
}

func (s *Binary_connectiveContext) Nand() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserNand, 0)
}

func (s *Binary_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterBinary_connective(s)
	}
}

func (s *Binary_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitBinary_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Binary_connective() (localctx IBinary_connectiveContext) {
	localctx = NewBinary_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, tptp_v7_0_0_0ParserRULE_binary_connective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(tptp_v7_0_0_0ParserIff-46))|(1<<(tptp_v7_0_0_0ParserImpl-46))|(1<<(tptp_v7_0_0_0ParserIf-46))|(1<<(tptp_v7_0_0_0ParserNiff-46))|(1<<(tptp_v7_0_0_0ParserNor-46))|(1<<(tptp_v7_0_0_0ParserNand-46)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAssoc_connectiveContext is an interface to support dynamic dispatch.
type IAssoc_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssoc_connectiveContext differentiates from other interfaces.
	IsAssoc_connectiveContext()
}

type Assoc_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssoc_connectiveContext() *Assoc_connectiveContext {
	var p = new(Assoc_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_assoc_connective
	return p
}

func (*Assoc_connectiveContext) IsAssoc_connectiveContext() {}

func NewAssoc_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assoc_connectiveContext {
	var p = new(Assoc_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_assoc_connective

	return p
}

func (s *Assoc_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Assoc_connectiveContext) Or() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserOr, 0)
}

func (s *Assoc_connectiveContext) And() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAnd, 0)
}

func (s *Assoc_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assoc_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assoc_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAssoc_connective(s)
	}
}

func (s *Assoc_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAssoc_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Assoc_connective() (localctx IAssoc_connectiveContext) {
	localctx = NewAssoc_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, tptp_v7_0_0_0ParserRULE_assoc_connective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1317)
		_la = p.GetTokenStream().LA(1)

		if !(_la == tptp_v7_0_0_0ParserOr || _la == tptp_v7_0_0_0ParserAnd) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnary_connectiveContext is an interface to support dynamic dispatch.
type IUnary_connectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_connectiveContext differentiates from other interfaces.
	IsUnary_connectiveContext()
}

type Unary_connectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_connectiveContext() *Unary_connectiveContext {
	var p = new(Unary_connectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_unary_connective
	return p
}

func (*Unary_connectiveContext) IsUnary_connectiveContext() {}

func NewUnary_connectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_connectiveContext {
	var p = new(Unary_connectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_unary_connective

	return p
}

func (s *Unary_connectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_connectiveContext) Not() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserNot, 0)
}

func (s *Unary_connectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_connectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_connectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterUnary_connective(s)
	}
}

func (s *Unary_connectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitUnary_connective(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Unary_connective() (localctx IUnary_connectiveContext) {
	localctx = NewUnary_connectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, tptp_v7_0_0_0ParserRULE_unary_connective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1319)
		p.Match(tptp_v7_0_0_0ParserNot)
	}

	return localctx
}

// IType_constantContext is an interface to support dynamic dispatch.
type IType_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_constantContext differentiates from other interfaces.
	IsType_constantContext()
}

type Type_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_constantContext() *Type_constantContext {
	var p = new(Type_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_type_constant
	return p
}

func (*Type_constantContext) IsType_constantContext() {}

func NewType_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_constantContext {
	var p = new(Type_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_type_constant

	return p
}

func (s *Type_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_constantContext) Type_functor() IType_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_functorContext)
}

func (s *Type_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterType_constant(s)
	}
}

func (s *Type_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitType_constant(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Type_constant() (localctx IType_constantContext) {
	localctx = NewType_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, tptp_v7_0_0_0ParserRULE_type_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1321)
		p.Type_functor()
	}

	return localctx
}

// IType_functorContext is an interface to support dynamic dispatch.
type IType_functorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_functorContext differentiates from other interfaces.
	IsType_functorContext()
}

type Type_functorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_functorContext() *Type_functorContext {
	var p = new(Type_functorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_type_functor
	return p
}

func (*Type_functorContext) IsType_functorContext() {}

func NewType_functorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_functorContext {
	var p = new(Type_functorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_type_functor

	return p
}

func (s *Type_functorContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_functorContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *Type_functorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_functorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_functorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterType_functor(s)
	}
}

func (s *Type_functorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitType_functor(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Type_functor() (localctx IType_functorContext) {
	localctx = NewType_functorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, tptp_v7_0_0_0ParserRULE_type_functor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1323)
		p.Atomic_word()
	}

	return localctx
}

// IDefined_typeContext is an interface to support dynamic dispatch.
type IDefined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_typeContext differentiates from other interfaces.
	IsDefined_typeContext()
}

type Defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_typeContext() *Defined_typeContext {
	var p = new(Defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_type
	return p
}

func (*Defined_typeContext) IsDefined_typeContext() {}

func NewDefined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_typeContext {
	var p = new(Defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_type

	return p
}

func (s *Defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_typeContext) Dollar_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDollar_word, 0)
}

func (s *Defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_type(s)
	}
}

func (s *Defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_type() (localctx IDefined_typeContext) {
	localctx = NewDefined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, tptp_v7_0_0_0ParserRULE_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1325)
		p.Match(tptp_v7_0_0_0ParserDollar_word)
	}

	return localctx
}

// ISystem_typeContext is an interface to support dynamic dispatch.
type ISystem_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_typeContext differentiates from other interfaces.
	IsSystem_typeContext()
}

type System_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_typeContext() *System_typeContext {
	var p = new(System_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_system_type
	return p
}

func (*System_typeContext) IsSystem_typeContext() {}

func NewSystem_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_typeContext {
	var p = new(System_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_system_type

	return p
}

func (s *System_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *System_typeContext) Atomic_system_word() IAtomic_system_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_system_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_system_wordContext)
}

func (s *System_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterSystem_type(s)
	}
}

func (s *System_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitSystem_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) System_type() (localctx ISystem_typeContext) {
	localctx = NewSystem_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, tptp_v7_0_0_0ParserRULE_system_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1327)
		p.Atomic_system_word()
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Untyped_atom() IUntyped_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUntyped_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUntyped_atomContext)
}

func (s *AtomContext) Defined_constant() IDefined_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_constantContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, tptp_v7_0_0_0ParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1331)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserDollar_dollar_word, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.Untyped_atom()
		}

	case tptp_v7_0_0_0ParserDollar_word:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)
			p.Defined_constant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUntyped_atomContext is an interface to support dynamic dispatch.
type IUntyped_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUntyped_atomContext differentiates from other interfaces.
	IsUntyped_atomContext()
}

type Untyped_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntyped_atomContext() *Untyped_atomContext {
	var p = new(Untyped_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_untyped_atom
	return p
}

func (*Untyped_atomContext) IsUntyped_atomContext() {}

func NewUntyped_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Untyped_atomContext {
	var p = new(Untyped_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_untyped_atom

	return p
}

func (s *Untyped_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Untyped_atomContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Untyped_atomContext) System_constant() ISystem_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_constantContext)
}

func (s *Untyped_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Untyped_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Untyped_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterUntyped_atom(s)
	}
}

func (s *Untyped_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitUntyped_atom(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Untyped_atom() (localctx IUntyped_atomContext) {
	localctx = NewUntyped_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, tptp_v7_0_0_0ParserRULE_untyped_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1335)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1333)
			p.Constant()
		}

	case tptp_v7_0_0_0ParserDollar_dollar_word:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1334)
			p.System_constant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefined_propositionContext is an interface to support dynamic dispatch.
type IDefined_propositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_propositionContext differentiates from other interfaces.
	IsDefined_propositionContext()
}

type Defined_propositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_propositionContext() *Defined_propositionContext {
	var p = new(Defined_propositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_proposition
	return p
}

func (*Defined_propositionContext) IsDefined_propositionContext() {}

func NewDefined_propositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_propositionContext {
	var p = new(Defined_propositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_proposition

	return p
}

func (s *Defined_propositionContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_propositionContext) Dollar_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDollar_word, 0)
}

func (s *Defined_propositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_propositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_propositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_proposition(s)
	}
}

func (s *Defined_propositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_proposition(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_proposition() (localctx IDefined_propositionContext) {
	localctx = NewDefined_propositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, tptp_v7_0_0_0ParserRULE_defined_proposition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.Match(tptp_v7_0_0_0ParserDollar_word)
	}

	return localctx
}

// IDefined_predicateContext is an interface to support dynamic dispatch.
type IDefined_predicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_predicateContext differentiates from other interfaces.
	IsDefined_predicateContext()
}

type Defined_predicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_predicateContext() *Defined_predicateContext {
	var p = new(Defined_predicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_predicate
	return p
}

func (*Defined_predicateContext) IsDefined_predicateContext() {}

func NewDefined_predicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_predicateContext {
	var p = new(Defined_predicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_predicate

	return p
}

func (s *Defined_predicateContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_predicateContext) Dollar_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDollar_word, 0)
}

func (s *Defined_predicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_predicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_predicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_predicate(s)
	}
}

func (s *Defined_predicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_predicate(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_predicate() (localctx IDefined_predicateContext) {
	localctx = NewDefined_predicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, tptp_v7_0_0_0ParserRULE_defined_predicate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1339)
		p.Match(tptp_v7_0_0_0ParserDollar_word)
	}

	return localctx
}

// IDefined_infix_predContext is an interface to support dynamic dispatch.
type IDefined_infix_predContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_infix_predContext differentiates from other interfaces.
	IsDefined_infix_predContext()
}

type Defined_infix_predContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_infix_predContext() *Defined_infix_predContext {
	var p = new(Defined_infix_predContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_infix_pred
	return p
}

func (*Defined_infix_predContext) IsDefined_infix_predContext() {}

func NewDefined_infix_predContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_infix_predContext {
	var p = new(Defined_infix_predContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_infix_pred

	return p
}

func (s *Defined_infix_predContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_infix_predContext) Infix_equality() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInfix_equality, 0)
}

func (s *Defined_infix_predContext) Assignment() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserAssignment, 0)
}

func (s *Defined_infix_predContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_infix_predContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_infix_predContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_infix_pred(s)
	}
}

func (s *Defined_infix_predContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_infix_pred(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_infix_pred() (localctx IDefined_infix_predContext) {
	localctx = NewDefined_infix_predContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, tptp_v7_0_0_0ParserRULE_defined_infix_pred)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1341)
		_la = p.GetTokenStream().LA(1)

		if !(_la == tptp_v7_0_0_0ParserInfix_equality || _la == tptp_v7_0_0_0ParserAssignment) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) Functor() IFunctorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctorContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, tptp_v7_0_0_0ParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1343)
		p.Functor()
	}

	return localctx
}

// IFunctorContext is an interface to support dynamic dispatch.
type IFunctorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctorContext differentiates from other interfaces.
	IsFunctorContext()
}

type FunctorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctorContext() *FunctorContext {
	var p = new(FunctorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_functor
	return p
}

func (*FunctorContext) IsFunctorContext() {}

func NewFunctorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctorContext {
	var p = new(FunctorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_functor

	return p
}

func (s *FunctorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctorContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *FunctorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFunctor(s)
	}
}

func (s *FunctorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFunctor(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Functor() (localctx IFunctorContext) {
	localctx = NewFunctorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, tptp_v7_0_0_0ParserRULE_functor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1345)
		p.Atomic_word()
	}

	return localctx
}

// ISystem_constantContext is an interface to support dynamic dispatch.
type ISystem_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_constantContext differentiates from other interfaces.
	IsSystem_constantContext()
}

type System_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_constantContext() *System_constantContext {
	var p = new(System_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_system_constant
	return p
}

func (*System_constantContext) IsSystem_constantContext() {}

func NewSystem_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_constantContext {
	var p = new(System_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_system_constant

	return p
}

func (s *System_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *System_constantContext) System_functor() ISystem_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_functorContext)
}

func (s *System_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterSystem_constant(s)
	}
}

func (s *System_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitSystem_constant(s)
	}
}

func (p *tptp_v7_0_0_0Parser) System_constant() (localctx ISystem_constantContext) {
	localctx = NewSystem_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, tptp_v7_0_0_0ParserRULE_system_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.System_functor()
	}

	return localctx
}

// ISystem_functorContext is an interface to support dynamic dispatch.
type ISystem_functorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_functorContext differentiates from other interfaces.
	IsSystem_functorContext()
}

type System_functorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_functorContext() *System_functorContext {
	var p = new(System_functorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_system_functor
	return p
}

func (*System_functorContext) IsSystem_functorContext() {}

func NewSystem_functorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_functorContext {
	var p = new(System_functorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_system_functor

	return p
}

func (s *System_functorContext) GetParser() antlr.Parser { return s.parser }

func (s *System_functorContext) Atomic_system_word() IAtomic_system_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_system_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_system_wordContext)
}

func (s *System_functorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_functorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_functorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterSystem_functor(s)
	}
}

func (s *System_functorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitSystem_functor(s)
	}
}

func (p *tptp_v7_0_0_0Parser) System_functor() (localctx ISystem_functorContext) {
	localctx = NewSystem_functorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, tptp_v7_0_0_0ParserRULE_system_functor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Atomic_system_word()
	}

	return localctx
}

// IDefined_constantContext is an interface to support dynamic dispatch.
type IDefined_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_constantContext differentiates from other interfaces.
	IsDefined_constantContext()
}

type Defined_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_constantContext() *Defined_constantContext {
	var p = new(Defined_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_constant
	return p
}

func (*Defined_constantContext) IsDefined_constantContext() {}

func NewDefined_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_constantContext {
	var p = new(Defined_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_constant

	return p
}

func (s *Defined_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_constantContext) Defined_functor() IDefined_functorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefined_functorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefined_functorContext)
}

func (s *Defined_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_constant(s)
	}
}

func (s *Defined_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_constant(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_constant() (localctx IDefined_constantContext) {
	localctx = NewDefined_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, tptp_v7_0_0_0ParserRULE_defined_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1351)
		p.Defined_functor()
	}

	return localctx
}

// IDefined_functorContext is an interface to support dynamic dispatch.
type IDefined_functorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_functorContext differentiates from other interfaces.
	IsDefined_functorContext()
}

type Defined_functorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_functorContext() *Defined_functorContext {
	var p = new(Defined_functorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_functor
	return p
}

func (*Defined_functorContext) IsDefined_functorContext() {}

func NewDefined_functorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_functorContext {
	var p = new(Defined_functorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_functor

	return p
}

func (s *Defined_functorContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_functorContext) Atomic_defined_word() IAtomic_defined_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_defined_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_defined_wordContext)
}

func (s *Defined_functorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_functorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_functorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_functor(s)
	}
}

func (s *Defined_functorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_functor(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_functor() (localctx IDefined_functorContext) {
	localctx = NewDefined_functorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, tptp_v7_0_0_0ParserRULE_defined_functor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1353)
		p.Atomic_defined_word()
	}

	return localctx
}

// IDefined_termContext is an interface to support dynamic dispatch.
type IDefined_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefined_termContext differentiates from other interfaces.
	IsDefined_termContext()
}

type Defined_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefined_termContext() *Defined_termContext {
	var p = new(Defined_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_term
	return p
}

func (*Defined_termContext) IsDefined_termContext() {}

func NewDefined_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defined_termContext {
	var p = new(Defined_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_defined_term

	return p
}

func (s *Defined_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Defined_termContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Defined_termContext) Distinct_object() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDistinct_object, 0)
}

func (s *Defined_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defined_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defined_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDefined_term(s)
	}
}

func (s *Defined_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDefined_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Defined_term() (localctx IDefined_termContext) {
	localctx = NewDefined_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, tptp_v7_0_0_0ParserRULE_defined_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1357)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserReal, tptp_v7_0_0_0ParserRational, tptp_v7_0_0_0ParserInteger:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1355)
			p.Number()
		}

	case tptp_v7_0_0_0ParserDistinct_object:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1356)
			p.Match(tptp_v7_0_0_0ParserDistinct_object)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) Upper_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserUpper_word, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitVariable(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, tptp_v7_0_0_0ParserRULE_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Match(tptp_v7_0_0_0ParserUpper_word)
	}

	return localctx
}

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_source
	return p
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) Dag_source() IDag_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDag_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDag_sourceContext)
}

func (s *SourceContext) Internal_source() IInternal_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInternal_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInternal_sourceContext)
}

func (s *SourceContext) External_source() IExternal_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternal_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternal_sourceContext)
}

func (s *SourceContext) Lower_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLower_word, 0)
}

func (s *SourceContext) Sources() ISourcesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourcesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourcesContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterSource(s)
	}
}

func (s *SourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitSource(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, tptp_v7_0_0_0ParserRULE_source)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1361)
			p.Dag_source()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1362)
			p.Internal_source()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1363)
			p.External_source()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1364)
			p.Match(tptp_v7_0_0_0ParserLower_word)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1365)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(1366)
			p.Sources()
		}
		{
			p.SetState(1367)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	}

	return localctx
}

// ISourcesContext is an interface to support dynamic dispatch.
type ISourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourcesContext differentiates from other interfaces.
	IsSourcesContext()
}

type SourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourcesContext() *SourcesContext {
	var p = new(SourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_sources
	return p
}

func (*SourcesContext) IsSourcesContext() {}

func NewSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourcesContext {
	var p = new(SourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_sources

	return p
}

func (s *SourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *SourcesContext) AllSource() []ISourceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISourceContext)(nil)).Elem())
	var tst = make([]ISourceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISourceContext)
		}
	}

	return tst
}

func (s *SourcesContext) Source(i int) ISourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISourceContext)
}

func (s *SourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterSources(s)
	}
}

func (s *SourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitSources(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Sources() (localctx ISourcesContext) {
	localctx = NewSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, tptp_v7_0_0_0ParserRULE_sources)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Source()
	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1372)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1373)
			p.Source()
		}

		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDag_sourceContext is an interface to support dynamic dispatch.
type IDag_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDag_sourceContext differentiates from other interfaces.
	IsDag_sourceContext()
}

type Dag_sourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDag_sourceContext() *Dag_sourceContext {
	var p = new(Dag_sourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_dag_source
	return p
}

func (*Dag_sourceContext) IsDag_sourceContext() {}

func NewDag_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dag_sourceContext {
	var p = new(Dag_sourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_dag_source

	return p
}

func (s *Dag_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Dag_sourceContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dag_sourceContext) Inference_record() IInference_recordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_recordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_recordContext)
}

func (s *Dag_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dag_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dag_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDag_source(s)
	}
}

func (s *Dag_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDag_source(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Dag_source() (localctx IDag_sourceContext) {
	localctx = NewDag_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, tptp_v7_0_0_0ParserRULE_dag_source)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1381)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserInteger, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1379)
			p.Name()
		}

	case tptp_v7_0_0_0ParserT__26:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1380)
			p.Inference_record()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInference_recordContext is an interface to support dynamic dispatch.
type IInference_recordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInference_recordContext differentiates from other interfaces.
	IsInference_recordContext()
}

type Inference_recordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInference_recordContext() *Inference_recordContext {
	var p = new(Inference_recordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_record
	return p
}

func (*Inference_recordContext) IsInference_recordContext() {}

func NewInference_recordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inference_recordContext {
	var p = new(Inference_recordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_record

	return p
}

func (s *Inference_recordContext) GetParser() antlr.Parser { return s.parser }

func (s *Inference_recordContext) Inference_rule() IInference_ruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_ruleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_ruleContext)
}

func (s *Inference_recordContext) Useful_info() IUseful_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseful_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseful_infoContext)
}

func (s *Inference_recordContext) Inference_parents() IInference_parentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_parentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_parentsContext)
}

func (s *Inference_recordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inference_recordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inference_recordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInference_record(s)
	}
}

func (s *Inference_recordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInference_record(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Inference_record() (localctx IInference_recordContext) {
	localctx = NewInference_recordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, tptp_v7_0_0_0ParserRULE_inference_record)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1383)
		p.Match(tptp_v7_0_0_0ParserT__26)
	}
	{
		p.SetState(1384)
		p.Inference_rule()
	}
	{
		p.SetState(1385)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1386)
		p.Useful_info()
	}
	{
		p.SetState(1387)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1388)
		p.Inference_parents()
	}
	{
		p.SetState(1389)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IInference_ruleContext is an interface to support dynamic dispatch.
type IInference_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInference_ruleContext differentiates from other interfaces.
	IsInference_ruleContext()
}

type Inference_ruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInference_ruleContext() *Inference_ruleContext {
	var p = new(Inference_ruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_rule
	return p
}

func (*Inference_ruleContext) IsInference_ruleContext() {}

func NewInference_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inference_ruleContext {
	var p = new(Inference_ruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_rule

	return p
}

func (s *Inference_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Inference_ruleContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *Inference_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inference_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inference_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInference_rule(s)
	}
}

func (s *Inference_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInference_rule(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Inference_rule() (localctx IInference_ruleContext) {
	localctx = NewInference_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, tptp_v7_0_0_0ParserRULE_inference_rule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)
		p.Atomic_word()
	}

	return localctx
}

// IInference_parentsContext is an interface to support dynamic dispatch.
type IInference_parentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInference_parentsContext differentiates from other interfaces.
	IsInference_parentsContext()
}

type Inference_parentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInference_parentsContext() *Inference_parentsContext {
	var p = new(Inference_parentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_parents
	return p
}

func (*Inference_parentsContext) IsInference_parentsContext() {}

func NewInference_parentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inference_parentsContext {
	var p = new(Inference_parentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_parents

	return p
}

func (s *Inference_parentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Inference_parentsContext) Parent_list() IParent_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParent_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParent_listContext)
}

func (s *Inference_parentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inference_parentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inference_parentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInference_parents(s)
	}
}

func (s *Inference_parentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInference_parents(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Inference_parents() (localctx IInference_parentsContext) {
	localctx = NewInference_parentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, tptp_v7_0_0_0ParserRULE_inference_parents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1398)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1393)
			p.Match(tptp_v7_0_0_0ParserT__16)
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1394)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(1395)
			p.Parent_list()
		}
		{
			p.SetState(1396)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParent_listContext is an interface to support dynamic dispatch.
type IParent_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParent_listContext differentiates from other interfaces.
	IsParent_listContext()
}

type Parent_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParent_listContext() *Parent_listContext {
	var p = new(Parent_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_parent_list
	return p
}

func (*Parent_listContext) IsParent_listContext() {}

func NewParent_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parent_listContext {
	var p = new(Parent_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_parent_list

	return p
}

func (s *Parent_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parent_listContext) AllParent_info() []IParent_infoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParent_infoContext)(nil)).Elem())
	var tst = make([]IParent_infoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParent_infoContext)
		}
	}

	return tst
}

func (s *Parent_listContext) Parent_info(i int) IParent_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParent_infoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParent_infoContext)
}

func (s *Parent_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parent_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parent_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterParent_list(s)
	}
}

func (s *Parent_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitParent_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Parent_list() (localctx IParent_listContext) {
	localctx = NewParent_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, tptp_v7_0_0_0ParserRULE_parent_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1400)
		p.Parent_info()
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1401)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1402)
			p.Parent_info()
		}

		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParent_infoContext is an interface to support dynamic dispatch.
type IParent_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParent_infoContext differentiates from other interfaces.
	IsParent_infoContext()
}

type Parent_infoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParent_infoContext() *Parent_infoContext {
	var p = new(Parent_infoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_parent_info
	return p
}

func (*Parent_infoContext) IsParent_infoContext() {}

func NewParent_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parent_infoContext {
	var p = new(Parent_infoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_parent_info

	return p
}

func (s *Parent_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Parent_infoContext) Source() ISourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceContext)
}

func (s *Parent_infoContext) Parent_details() IParent_detailsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParent_detailsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParent_detailsContext)
}

func (s *Parent_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parent_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parent_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterParent_info(s)
	}
}

func (s *Parent_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitParent_info(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Parent_info() (localctx IParent_infoContext) {
	localctx = NewParent_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, tptp_v7_0_0_0ParserRULE_parent_info)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1408)
		p.Source()
	}
	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__13 {
		{
			p.SetState(1409)
			p.Parent_details()
		}

	}

	return localctx
}

// IParent_detailsContext is an interface to support dynamic dispatch.
type IParent_detailsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParent_detailsContext differentiates from other interfaces.
	IsParent_detailsContext()
}

type Parent_detailsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParent_detailsContext() *Parent_detailsContext {
	var p = new(Parent_detailsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_parent_details
	return p
}

func (*Parent_detailsContext) IsParent_detailsContext() {}

func NewParent_detailsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parent_detailsContext {
	var p = new(Parent_detailsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_parent_details

	return p
}

func (s *Parent_detailsContext) GetParser() antlr.Parser { return s.parser }

func (s *Parent_detailsContext) General_list() IGeneral_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_listContext)
}

func (s *Parent_detailsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parent_detailsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parent_detailsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterParent_details(s)
	}
}

func (s *Parent_detailsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitParent_details(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Parent_details() (localctx IParent_detailsContext) {
	localctx = NewParent_detailsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, tptp_v7_0_0_0ParserRULE_parent_details)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.Match(tptp_v7_0_0_0ParserT__13)
	}
	{
		p.SetState(1413)
		p.General_list()
	}

	return localctx
}

// IInternal_sourceContext is an interface to support dynamic dispatch.
type IInternal_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInternal_sourceContext differentiates from other interfaces.
	IsInternal_sourceContext()
}

type Internal_sourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInternal_sourceContext() *Internal_sourceContext {
	var p = new(Internal_sourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_internal_source
	return p
}

func (*Internal_sourceContext) IsInternal_sourceContext() {}

func NewInternal_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Internal_sourceContext {
	var p = new(Internal_sourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_internal_source

	return p
}

func (s *Internal_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Internal_sourceContext) Intro_type() IIntro_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntro_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntro_typeContext)
}

func (s *Internal_sourceContext) Optional_info() IOptional_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptional_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptional_infoContext)
}

func (s *Internal_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Internal_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Internal_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInternal_source(s)
	}
}

func (s *Internal_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInternal_source(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Internal_source() (localctx IInternal_sourceContext) {
	localctx = NewInternal_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, tptp_v7_0_0_0ParserRULE_internal_source)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1415)
		p.Match(tptp_v7_0_0_0ParserT__27)
	}
	{
		p.SetState(1416)
		p.Intro_type()
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1417)
			p.Optional_info()
		}

	}
	{
		p.SetState(1420)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IIntro_typeContext is an interface to support dynamic dispatch.
type IIntro_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntro_typeContext differentiates from other interfaces.
	IsIntro_typeContext()
}

type Intro_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntro_typeContext() *Intro_typeContext {
	var p = new(Intro_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_intro_type
	return p
}

func (*Intro_typeContext) IsIntro_typeContext() {}

func NewIntro_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Intro_typeContext {
	var p = new(Intro_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_intro_type

	return p
}

func (s *Intro_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Intro_typeContext) Lower_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLower_word, 0)
}

func (s *Intro_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Intro_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Intro_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterIntro_type(s)
	}
}

func (s *Intro_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitIntro_type(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Intro_type() (localctx IIntro_typeContext) {
	localctx = NewIntro_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, tptp_v7_0_0_0ParserRULE_intro_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		p.Match(tptp_v7_0_0_0ParserLower_word)
	}

	return localctx
}

// IExternal_sourceContext is an interface to support dynamic dispatch.
type IExternal_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternal_sourceContext differentiates from other interfaces.
	IsExternal_sourceContext()
}

type External_sourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_sourceContext() *External_sourceContext {
	var p = new(External_sourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_external_source
	return p
}

func (*External_sourceContext) IsExternal_sourceContext() {}

func NewExternal_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_sourceContext {
	var p = new(External_sourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_external_source

	return p
}

func (s *External_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *External_sourceContext) File_source() IFile_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_sourceContext)
}

func (s *External_sourceContext) Theory() ITheoryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITheoryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITheoryContext)
}

func (s *External_sourceContext) Creator_source() ICreator_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreator_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreator_sourceContext)
}

func (s *External_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *External_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterExternal_source(s)
	}
}

func (s *External_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitExternal_source(s)
	}
}

func (p *tptp_v7_0_0_0Parser) External_source() (localctx IExternal_sourceContext) {
	localctx = NewExternal_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, tptp_v7_0_0_0ParserRULE_external_source)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1427)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__28:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1424)
			p.File_source()
		}

	case tptp_v7_0_0_0ParserT__29:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1425)
			p.Theory()
		}

	case tptp_v7_0_0_0ParserT__30:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1426)
			p.Creator_source()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFile_sourceContext is an interface to support dynamic dispatch.
type IFile_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_sourceContext differentiates from other interfaces.
	IsFile_sourceContext()
}

type File_sourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_sourceContext() *File_sourceContext {
	var p = new(File_sourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_file_source
	return p
}

func (*File_sourceContext) IsFile_sourceContext() {}

func NewFile_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_sourceContext {
	var p = new(File_sourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_file_source

	return p
}

func (s *File_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *File_sourceContext) File_name() IFile_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *File_sourceContext) File_info() IFile_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_infoContext)
}

func (s *File_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFile_source(s)
	}
}

func (s *File_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFile_source(s)
	}
}

func (p *tptp_v7_0_0_0Parser) File_source() (localctx IFile_sourceContext) {
	localctx = NewFile_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, tptp_v7_0_0_0ParserRULE_file_source)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1429)
		p.Match(tptp_v7_0_0_0ParserT__28)
	}
	{
		p.SetState(1430)
		p.File_name()
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1431)
			p.File_info()
		}

	}
	{
		p.SetState(1434)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IFile_infoContext is an interface to support dynamic dispatch.
type IFile_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_infoContext differentiates from other interfaces.
	IsFile_infoContext()
}

type File_infoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_infoContext() *File_infoContext {
	var p = new(File_infoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_file_info
	return p
}

func (*File_infoContext) IsFile_infoContext() {}

func NewFile_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_infoContext {
	var p = new(File_infoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_file_info

	return p
}

func (s *File_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *File_infoContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *File_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFile_info(s)
	}
}

func (s *File_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFile_info(s)
	}
}

func (p *tptp_v7_0_0_0Parser) File_info() (localctx IFile_infoContext) {
	localctx = NewFile_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, tptp_v7_0_0_0ParserRULE_file_info)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1436)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1437)
		p.Name()
	}

	return localctx
}

// ITheoryContext is an interface to support dynamic dispatch.
type ITheoryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTheoryContext differentiates from other interfaces.
	IsTheoryContext()
}

type TheoryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheoryContext() *TheoryContext {
	var p = new(TheoryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_theory
	return p
}

func (*TheoryContext) IsTheoryContext() {}

func NewTheoryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TheoryContext {
	var p = new(TheoryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_theory

	return p
}

func (s *TheoryContext) GetParser() antlr.Parser { return s.parser }

func (s *TheoryContext) Theory_name() ITheory_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITheory_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITheory_nameContext)
}

func (s *TheoryContext) Optional_info() IOptional_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptional_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptional_infoContext)
}

func (s *TheoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TheoryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TheoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTheory(s)
	}
}

func (s *TheoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTheory(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Theory() (localctx ITheoryContext) {
	localctx = NewTheoryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, tptp_v7_0_0_0ParserRULE_theory)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1439)
		p.Match(tptp_v7_0_0_0ParserT__29)
	}
	{
		p.SetState(1440)
		p.Theory_name()
	}
	p.SetState(1442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1441)
			p.Optional_info()
		}

	}
	{
		p.SetState(1444)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// ITheory_nameContext is an interface to support dynamic dispatch.
type ITheory_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTheory_nameContext differentiates from other interfaces.
	IsTheory_nameContext()
}

type Theory_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_nameContext() *Theory_nameContext {
	var p = new(Theory_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_theory_name
	return p
}

func (*Theory_nameContext) IsTheory_nameContext() {}

func NewTheory_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_nameContext {
	var p = new(Theory_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_theory_name

	return p
}

func (s *Theory_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_nameContext) Lower_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLower_word, 0)
}

func (s *Theory_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterTheory_name(s)
	}
}

func (s *Theory_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitTheory_name(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Theory_name() (localctx ITheory_nameContext) {
	localctx = NewTheory_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, tptp_v7_0_0_0ParserRULE_theory_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1446)
		p.Match(tptp_v7_0_0_0ParserLower_word)
	}

	return localctx
}

// ICreator_sourceContext is an interface to support dynamic dispatch.
type ICreator_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreator_sourceContext differentiates from other interfaces.
	IsCreator_sourceContext()
}

type Creator_sourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreator_sourceContext() *Creator_sourceContext {
	var p = new(Creator_sourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_creator_source
	return p
}

func (*Creator_sourceContext) IsCreator_sourceContext() {}

func NewCreator_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Creator_sourceContext {
	var p = new(Creator_sourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_creator_source

	return p
}

func (s *Creator_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Creator_sourceContext) Creator_name() ICreator_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreator_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreator_nameContext)
}

func (s *Creator_sourceContext) Optional_info() IOptional_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptional_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptional_infoContext)
}

func (s *Creator_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Creator_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Creator_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterCreator_source(s)
	}
}

func (s *Creator_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitCreator_source(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Creator_source() (localctx ICreator_sourceContext) {
	localctx = NewCreator_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, tptp_v7_0_0_0ParserRULE_creator_source)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1448)
		p.Match(tptp_v7_0_0_0ParserT__30)
	}
	{
		p.SetState(1449)
		p.Creator_name()
	}
	p.SetState(1451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1450)
			p.Optional_info()
		}

	}
	{
		p.SetState(1453)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// ICreator_nameContext is an interface to support dynamic dispatch.
type ICreator_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreator_nameContext differentiates from other interfaces.
	IsCreator_nameContext()
}

type Creator_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreator_nameContext() *Creator_nameContext {
	var p = new(Creator_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_creator_name
	return p
}

func (*Creator_nameContext) IsCreator_nameContext() {}

func NewCreator_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Creator_nameContext {
	var p = new(Creator_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_creator_name

	return p
}

func (s *Creator_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Creator_nameContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *Creator_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Creator_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Creator_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterCreator_name(s)
	}
}

func (s *Creator_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitCreator_name(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Creator_name() (localctx ICreator_nameContext) {
	localctx = NewCreator_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, tptp_v7_0_0_0ParserRULE_creator_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1455)
		p.Atomic_word()
	}

	return localctx
}

// IOptional_infoContext is an interface to support dynamic dispatch.
type IOptional_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptional_infoContext differentiates from other interfaces.
	IsOptional_infoContext()
}

type Optional_infoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptional_infoContext() *Optional_infoContext {
	var p = new(Optional_infoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_optional_info
	return p
}

func (*Optional_infoContext) IsOptional_infoContext() {}

func NewOptional_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Optional_infoContext {
	var p = new(Optional_infoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_optional_info

	return p
}

func (s *Optional_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Optional_infoContext) Useful_info() IUseful_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseful_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseful_infoContext)
}

func (s *Optional_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Optional_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Optional_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterOptional_info(s)
	}
}

func (s *Optional_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitOptional_info(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Optional_info() (localctx IOptional_infoContext) {
	localctx = NewOptional_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, tptp_v7_0_0_0ParserRULE_optional_info)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1457)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1458)
		p.Useful_info()
	}

	return localctx
}

// IUseful_infoContext is an interface to support dynamic dispatch.
type IUseful_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseful_infoContext differentiates from other interfaces.
	IsUseful_infoContext()
}

type Useful_infoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseful_infoContext() *Useful_infoContext {
	var p = new(Useful_infoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_useful_info
	return p
}

func (*Useful_infoContext) IsUseful_infoContext() {}

func NewUseful_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Useful_infoContext {
	var p = new(Useful_infoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_useful_info

	return p
}

func (s *Useful_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Useful_infoContext) Info_items() IInfo_itemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfo_itemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfo_itemsContext)
}

func (s *Useful_infoContext) General_list() IGeneral_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_listContext)
}

func (s *Useful_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Useful_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Useful_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterUseful_info(s)
	}
}

func (s *Useful_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitUseful_info(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Useful_info() (localctx IUseful_infoContext) {
	localctx = NewUseful_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, tptp_v7_0_0_0ParserRULE_useful_info)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1466)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1460)
			p.Match(tptp_v7_0_0_0ParserT__16)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1461)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(1462)
			p.Info_items()
		}
		{
			p.SetState(1463)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1465)
			p.General_list()
		}

	}

	return localctx
}

// IInfo_itemsContext is an interface to support dynamic dispatch.
type IInfo_itemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfo_itemsContext differentiates from other interfaces.
	IsInfo_itemsContext()
}

type Info_itemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_itemsContext() *Info_itemsContext {
	var p = new(Info_itemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_info_items
	return p
}

func (*Info_itemsContext) IsInfo_itemsContext() {}

func NewInfo_itemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_itemsContext {
	var p = new(Info_itemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_info_items

	return p
}

func (s *Info_itemsContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_itemsContext) AllInfo_item() []IInfo_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInfo_itemContext)(nil)).Elem())
	var tst = make([]IInfo_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInfo_itemContext)
		}
	}

	return tst
}

func (s *Info_itemsContext) Info_item(i int) IInfo_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfo_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInfo_itemContext)
}

func (s *Info_itemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_itemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_itemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInfo_items(s)
	}
}

func (s *Info_itemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInfo_items(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Info_items() (localctx IInfo_itemsContext) {
	localctx = NewInfo_itemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, tptp_v7_0_0_0ParserRULE_info_items)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1468)
		p.Info_item()
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1469)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1470)
			p.Info_item()
		}

		p.SetState(1475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInfo_itemContext is an interface to support dynamic dispatch.
type IInfo_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfo_itemContext differentiates from other interfaces.
	IsInfo_itemContext()
}

type Info_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_itemContext() *Info_itemContext {
	var p = new(Info_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_info_item
	return p
}

func (*Info_itemContext) IsInfo_itemContext() {}

func NewInfo_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_itemContext {
	var p = new(Info_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_info_item

	return p
}

func (s *Info_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_itemContext) Formula_item() IFormula_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_itemContext)
}

func (s *Info_itemContext) Inference_item() IInference_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_itemContext)
}

func (s *Info_itemContext) General_function() IGeneral_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_functionContext)
}

func (s *Info_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInfo_item(s)
	}
}

func (s *Info_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInfo_item(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Info_item() (localctx IInfo_itemContext) {
	localctx = NewInfo_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, tptp_v7_0_0_0ParserRULE_info_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1479)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1476)
			p.Formula_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1477)
			p.Inference_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1478)
			p.General_function()
		}

	}

	return localctx
}

// IFormula_itemContext is an interface to support dynamic dispatch.
type IFormula_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormula_itemContext differentiates from other interfaces.
	IsFormula_itemContext()
}

type Formula_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormula_itemContext() *Formula_itemContext {
	var p = new(Formula_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_item
	return p
}

func (*Formula_itemContext) IsFormula_itemContext() {}

func NewFormula_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formula_itemContext {
	var p = new(Formula_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_item

	return p
}

func (s *Formula_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Formula_itemContext) Description_item() IDescription_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescription_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDescription_itemContext)
}

func (s *Formula_itemContext) Iquote_item() IIquote_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIquote_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIquote_itemContext)
}

func (s *Formula_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formula_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formula_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFormula_item(s)
	}
}

func (s *Formula_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFormula_item(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Formula_item() (localctx IFormula_itemContext) {
	localctx = NewFormula_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, tptp_v7_0_0_0ParserRULE_formula_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1483)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__31:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1481)
			p.Description_item()
		}

	case tptp_v7_0_0_0ParserT__32:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1482)
			p.Iquote_item()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDescription_itemContext is an interface to support dynamic dispatch.
type IDescription_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescription_itemContext differentiates from other interfaces.
	IsDescription_itemContext()
}

type Description_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescription_itemContext() *Description_itemContext {
	var p = new(Description_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_description_item
	return p
}

func (*Description_itemContext) IsDescription_itemContext() {}

func NewDescription_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Description_itemContext {
	var p = new(Description_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_description_item

	return p
}

func (s *Description_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Description_itemContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *Description_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Description_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Description_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterDescription_item(s)
	}
}

func (s *Description_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitDescription_item(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Description_item() (localctx IDescription_itemContext) {
	localctx = NewDescription_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, tptp_v7_0_0_0ParserRULE_description_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1485)
		p.Match(tptp_v7_0_0_0ParserT__31)
	}
	{
		p.SetState(1486)
		p.Atomic_word()
	}
	{
		p.SetState(1487)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IIquote_itemContext is an interface to support dynamic dispatch.
type IIquote_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIquote_itemContext differentiates from other interfaces.
	IsIquote_itemContext()
}

type Iquote_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIquote_itemContext() *Iquote_itemContext {
	var p = new(Iquote_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_iquote_item
	return p
}

func (*Iquote_itemContext) IsIquote_itemContext() {}

func NewIquote_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iquote_itemContext {
	var p = new(Iquote_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_iquote_item

	return p
}

func (s *Iquote_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Iquote_itemContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *Iquote_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iquote_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Iquote_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterIquote_item(s)
	}
}

func (s *Iquote_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitIquote_item(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Iquote_item() (localctx IIquote_itemContext) {
	localctx = NewIquote_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, tptp_v7_0_0_0ParserRULE_iquote_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1489)
		p.Match(tptp_v7_0_0_0ParserT__32)
	}
	{
		p.SetState(1490)
		p.Atomic_word()
	}
	{
		p.SetState(1491)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IInference_itemContext is an interface to support dynamic dispatch.
type IInference_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInference_itemContext differentiates from other interfaces.
	IsInference_itemContext()
}

type Inference_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInference_itemContext() *Inference_itemContext {
	var p = new(Inference_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_item
	return p
}

func (*Inference_itemContext) IsInference_itemContext() {}

func NewInference_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inference_itemContext {
	var p = new(Inference_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_item

	return p
}

func (s *Inference_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Inference_itemContext) Inference_status() IInference_statusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_statusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_statusContext)
}

func (s *Inference_itemContext) Assumptions_record() IAssumptions_recordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssumptions_recordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssumptions_recordContext)
}

func (s *Inference_itemContext) New_symbol_record() INew_symbol_recordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_symbol_recordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_symbol_recordContext)
}

func (s *Inference_itemContext) Refutation() IRefutationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRefutationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRefutationContext)
}

func (s *Inference_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inference_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inference_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInference_item(s)
	}
}

func (s *Inference_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInference_item(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Inference_item() (localctx IInference_itemContext) {
	localctx = NewInference_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, tptp_v7_0_0_0ParserRULE_inference_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1497)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__33, tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1493)
			p.Inference_status()
		}

	case tptp_v7_0_0_0ParserT__34:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1494)
			p.Assumptions_record()
		}

	case tptp_v7_0_0_0ParserT__36:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1495)
			p.New_symbol_record()
		}

	case tptp_v7_0_0_0ParserT__35:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1496)
			p.Refutation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInference_statusContext is an interface to support dynamic dispatch.
type IInference_statusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInference_statusContext differentiates from other interfaces.
	IsInference_statusContext()
}

type Inference_statusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInference_statusContext() *Inference_statusContext {
	var p = new(Inference_statusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_status
	return p
}

func (*Inference_statusContext) IsInference_statusContext() {}

func NewInference_statusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inference_statusContext {
	var p = new(Inference_statusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_status

	return p
}

func (s *Inference_statusContext) GetParser() antlr.Parser { return s.parser }

func (s *Inference_statusContext) Status_value() IStatus_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatus_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatus_valueContext)
}

func (s *Inference_statusContext) Inference_info() IInference_infoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_infoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_infoContext)
}

func (s *Inference_statusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inference_statusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inference_statusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInference_status(s)
	}
}

func (s *Inference_statusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInference_status(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Inference_status() (localctx IInference_statusContext) {
	localctx = NewInference_statusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, tptp_v7_0_0_0ParserRULE_inference_status)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1504)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__33:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Match(tptp_v7_0_0_0ParserT__33)
		}
		{
			p.SetState(1500)
			p.Status_value()
		}
		{
			p.SetState(1501)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1503)
			p.Inference_info()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStatus_valueContext is an interface to support dynamic dispatch.
type IStatus_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatus_valueContext differentiates from other interfaces.
	IsStatus_valueContext()
}

type Status_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatus_valueContext() *Status_valueContext {
	var p = new(Status_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_status_value
	return p
}

func (*Status_valueContext) IsStatus_valueContext() {}

func NewStatus_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Status_valueContext {
	var p = new(Status_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_status_value

	return p
}

func (s *Status_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Status_valueContext) Lower_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLower_word, 0)
}

func (s *Status_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Status_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Status_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterStatus_value(s)
	}
}

func (s *Status_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitStatus_value(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Status_value() (localctx IStatus_valueContext) {
	localctx = NewStatus_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, tptp_v7_0_0_0ParserRULE_status_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.Match(tptp_v7_0_0_0ParserLower_word)
	}

	return localctx
}

// IInference_infoContext is an interface to support dynamic dispatch.
type IInference_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInference_infoContext differentiates from other interfaces.
	IsInference_infoContext()
}

type Inference_infoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInference_infoContext() *Inference_infoContext {
	var p = new(Inference_infoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_info
	return p
}

func (*Inference_infoContext) IsInference_infoContext() {}

func NewInference_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inference_infoContext {
	var p = new(Inference_infoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_inference_info

	return p
}

func (s *Inference_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Inference_infoContext) Inference_rule() IInference_ruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInference_ruleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInference_ruleContext)
}

func (s *Inference_infoContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *Inference_infoContext) General_list() IGeneral_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_listContext)
}

func (s *Inference_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inference_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inference_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInference_info(s)
	}
}

func (s *Inference_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInference_info(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Inference_info() (localctx IInference_infoContext) {
	localctx = NewInference_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, tptp_v7_0_0_0ParserRULE_inference_info)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1508)
		p.Inference_rule()
	}
	{
		p.SetState(1509)
		p.Match(tptp_v7_0_0_0ParserT__9)
	}
	{
		p.SetState(1510)
		p.Atomic_word()
	}
	{
		p.SetState(1511)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1512)
		p.General_list()
	}
	{
		p.SetState(1513)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IAssumptions_recordContext is an interface to support dynamic dispatch.
type IAssumptions_recordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssumptions_recordContext differentiates from other interfaces.
	IsAssumptions_recordContext()
}

type Assumptions_recordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssumptions_recordContext() *Assumptions_recordContext {
	var p = new(Assumptions_recordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_assumptions_record
	return p
}

func (*Assumptions_recordContext) IsAssumptions_recordContext() {}

func NewAssumptions_recordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assumptions_recordContext {
	var p = new(Assumptions_recordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_assumptions_record

	return p
}

func (s *Assumptions_recordContext) GetParser() antlr.Parser { return s.parser }

func (s *Assumptions_recordContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Assumptions_recordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assumptions_recordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assumptions_recordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAssumptions_record(s)
	}
}

func (s *Assumptions_recordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAssumptions_record(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Assumptions_record() (localctx IAssumptions_recordContext) {
	localctx = NewAssumptions_recordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, tptp_v7_0_0_0ParserRULE_assumptions_record)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1515)
		p.Match(tptp_v7_0_0_0ParserT__34)
	}
	{
		p.SetState(1516)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(1517)
		p.Name_list()
	}
	{
		p.SetState(1518)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(1519)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IRefutationContext is an interface to support dynamic dispatch.
type IRefutationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRefutationContext differentiates from other interfaces.
	IsRefutationContext()
}

type RefutationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefutationContext() *RefutationContext {
	var p = new(RefutationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_refutation
	return p
}

func (*RefutationContext) IsRefutationContext() {}

func NewRefutationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefutationContext {
	var p = new(RefutationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_refutation

	return p
}

func (s *RefutationContext) GetParser() antlr.Parser { return s.parser }

func (s *RefutationContext) File_source() IFile_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_sourceContext)
}

func (s *RefutationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefutationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefutationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterRefutation(s)
	}
}

func (s *RefutationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitRefutation(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Refutation() (localctx IRefutationContext) {
	localctx = NewRefutationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, tptp_v7_0_0_0ParserRULE_refutation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Match(tptp_v7_0_0_0ParserT__35)
	}
	{
		p.SetState(1522)
		p.File_source()
	}
	{
		p.SetState(1523)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// INew_symbol_recordContext is an interface to support dynamic dispatch.
type INew_symbol_recordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_symbol_recordContext differentiates from other interfaces.
	IsNew_symbol_recordContext()
}

type New_symbol_recordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_symbol_recordContext() *New_symbol_recordContext {
	var p = new(New_symbol_recordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_new_symbol_record
	return p
}

func (*New_symbol_recordContext) IsNew_symbol_recordContext() {}

func NewNew_symbol_recordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_symbol_recordContext {
	var p = new(New_symbol_recordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_new_symbol_record

	return p
}

func (s *New_symbol_recordContext) GetParser() antlr.Parser { return s.parser }

func (s *New_symbol_recordContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *New_symbol_recordContext) New_symbol_list() INew_symbol_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_symbol_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_symbol_listContext)
}

func (s *New_symbol_recordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_symbol_recordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_symbol_recordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterNew_symbol_record(s)
	}
}

func (s *New_symbol_recordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitNew_symbol_record(s)
	}
}

func (p *tptp_v7_0_0_0Parser) New_symbol_record() (localctx INew_symbol_recordContext) {
	localctx = NewNew_symbol_recordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, tptp_v7_0_0_0ParserRULE_new_symbol_record)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1525)
		p.Match(tptp_v7_0_0_0ParserT__36)
	}
	{
		p.SetState(1526)
		p.Atomic_word()
	}
	{
		p.SetState(1527)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1528)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(1529)
		p.New_symbol_list()
	}
	{
		p.SetState(1530)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}
	{
		p.SetState(1531)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// INew_symbol_listContext is an interface to support dynamic dispatch.
type INew_symbol_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_symbol_listContext differentiates from other interfaces.
	IsNew_symbol_listContext()
}

type New_symbol_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_symbol_listContext() *New_symbol_listContext {
	var p = new(New_symbol_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_new_symbol_list
	return p
}

func (*New_symbol_listContext) IsNew_symbol_listContext() {}

func NewNew_symbol_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_symbol_listContext {
	var p = new(New_symbol_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_new_symbol_list

	return p
}

func (s *New_symbol_listContext) GetParser() antlr.Parser { return s.parser }

func (s *New_symbol_listContext) AllPrincipal_symbol() []IPrincipal_symbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrincipal_symbolContext)(nil)).Elem())
	var tst = make([]IPrincipal_symbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrincipal_symbolContext)
		}
	}

	return tst
}

func (s *New_symbol_listContext) Principal_symbol(i int) IPrincipal_symbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipal_symbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrincipal_symbolContext)
}

func (s *New_symbol_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_symbol_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_symbol_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterNew_symbol_list(s)
	}
}

func (s *New_symbol_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitNew_symbol_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) New_symbol_list() (localctx INew_symbol_listContext) {
	localctx = NewNew_symbol_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, tptp_v7_0_0_0ParserRULE_new_symbol_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1533)
		p.Principal_symbol()
	}
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1534)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1535)
			p.Principal_symbol()
		}

		p.SetState(1540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPrincipal_symbolContext is an interface to support dynamic dispatch.
type IPrincipal_symbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrincipal_symbolContext differentiates from other interfaces.
	IsPrincipal_symbolContext()
}

type Principal_symbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipal_symbolContext() *Principal_symbolContext {
	var p = new(Principal_symbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_principal_symbol
	return p
}

func (*Principal_symbolContext) IsPrincipal_symbolContext() {}

func NewPrincipal_symbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Principal_symbolContext {
	var p = new(Principal_symbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_principal_symbol

	return p
}

func (s *Principal_symbolContext) GetParser() antlr.Parser { return s.parser }

func (s *Principal_symbolContext) Functor() IFunctorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctorContext)
}

func (s *Principal_symbolContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Principal_symbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Principal_symbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Principal_symbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterPrincipal_symbol(s)
	}
}

func (s *Principal_symbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitPrincipal_symbol(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Principal_symbol() (localctx IPrincipal_symbolContext) {
	localctx = NewPrincipal_symbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, tptp_v7_0_0_0ParserRULE_principal_symbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1543)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1541)
			p.Functor()
		}

	case tptp_v7_0_0_0ParserUpper_word:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1542)
			p.Variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIncludeContext is an interface to support dynamic dispatch.
type IIncludeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncludeContext differentiates from other interfaces.
	IsIncludeContext()
}

type IncludeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeContext() *IncludeContext {
	var p = new(IncludeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_include
	return p
}

func (*IncludeContext) IsIncludeContext() {}

func NewIncludeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeContext {
	var p = new(IncludeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_include

	return p
}

func (s *IncludeContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeContext) File_name() IFile_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *IncludeContext) Formula_selection() IFormula_selectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_selectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_selectionContext)
}

func (s *IncludeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterInclude(s)
	}
}

func (s *IncludeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitInclude(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Include() (localctx IIncludeContext) {
	localctx = NewIncludeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, tptp_v7_0_0_0ParserRULE_include)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1545)
		p.Match(tptp_v7_0_0_0ParserT__37)
	}
	{
		p.SetState(1546)
		p.File_name()
	}
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1547)
			p.Formula_selection()
		}

	}
	{
		p.SetState(1550)
		p.Match(tptp_v7_0_0_0ParserT__2)
	}

	return localctx
}

// IFormula_selectionContext is an interface to support dynamic dispatch.
type IFormula_selectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormula_selectionContext differentiates from other interfaces.
	IsFormula_selectionContext()
}

type Formula_selectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormula_selectionContext() *Formula_selectionContext {
	var p = new(Formula_selectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_selection
	return p
}

func (*Formula_selectionContext) IsFormula_selectionContext() {}

func NewFormula_selectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formula_selectionContext {
	var p = new(Formula_selectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_selection

	return p
}

func (s *Formula_selectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Formula_selectionContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Formula_selectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formula_selectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formula_selectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFormula_selection(s)
	}
}

func (s *Formula_selectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFormula_selection(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Formula_selection() (localctx IFormula_selectionContext) {
	localctx = NewFormula_selectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, tptp_v7_0_0_0ParserRULE_formula_selection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.Match(tptp_v7_0_0_0ParserT__1)
	}
	{
		p.SetState(1553)
		p.Match(tptp_v7_0_0_0ParserT__11)
	}
	{
		p.SetState(1554)
		p.Name_list()
	}
	{
		p.SetState(1555)
		p.Match(tptp_v7_0_0_0ParserT__12)
	}

	return localctx
}

// IName_listContext is an interface to support dynamic dispatch.
type IName_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_listContext differentiates from other interfaces.
	IsName_listContext()
}

type Name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_listContext() *Name_listContext {
	var p = new(Name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_name_list
	return p
}

func (*Name_listContext) IsName_listContext() {}

func NewName_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_listContext {
	var p = new(Name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_name_list

	return p
}

func (s *Name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Name_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterName_list(s)
	}
}

func (s *Name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitName_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Name_list() (localctx IName_listContext) {
	localctx = NewName_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, tptp_v7_0_0_0ParserRULE_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		p.Name()
	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1558)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1559)
			p.Name()
		}

		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGeneral_termContext is an interface to support dynamic dispatch.
type IGeneral_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_termContext differentiates from other interfaces.
	IsGeneral_termContext()
}

type General_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_termContext() *General_termContext {
	var p = new(General_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_term
	return p
}

func (*General_termContext) IsGeneral_termContext() {}

func NewGeneral_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_termContext {
	var p = new(General_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_term

	return p
}

func (s *General_termContext) GetParser() antlr.Parser { return s.parser }

func (s *General_termContext) General_data() IGeneral_dataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_dataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_dataContext)
}

func (s *General_termContext) General_term() IGeneral_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_termContext)
}

func (s *General_termContext) General_list() IGeneral_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_listContext)
}

func (s *General_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterGeneral_term(s)
	}
}

func (s *General_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitGeneral_term(s)
	}
}

func (p *tptp_v7_0_0_0Parser) General_term() (localctx IGeneral_termContext) {
	localctx = NewGeneral_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, tptp_v7_0_0_0ParserRULE_general_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1565)
			p.General_data()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1566)
			p.General_data()
		}
		{
			p.SetState(1567)
			p.Match(tptp_v7_0_0_0ParserT__13)
		}
		{
			p.SetState(1568)
			p.General_term()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1570)
			p.General_list()
		}

	}

	return localctx
}

// IGeneral_dataContext is an interface to support dynamic dispatch.
type IGeneral_dataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_dataContext differentiates from other interfaces.
	IsGeneral_dataContext()
}

type General_dataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_dataContext() *General_dataContext {
	var p = new(General_dataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_data
	return p
}

func (*General_dataContext) IsGeneral_dataContext() {}

func NewGeneral_dataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_dataContext {
	var p = new(General_dataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_data

	return p
}

func (s *General_dataContext) GetParser() antlr.Parser { return s.parser }

func (s *General_dataContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *General_dataContext) General_function() IGeneral_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_functionContext)
}

func (s *General_dataContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *General_dataContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *General_dataContext) Distinct_object() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDistinct_object, 0)
}

func (s *General_dataContext) Formula_data() IFormula_dataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormula_dataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormula_dataContext)
}

func (s *General_dataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_dataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_dataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterGeneral_data(s)
	}
}

func (s *General_dataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitGeneral_data(s)
	}
}

func (p *tptp_v7_0_0_0Parser) General_data() (localctx IGeneral_dataContext) {
	localctx = NewGeneral_dataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, tptp_v7_0_0_0ParserRULE_general_data)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1573)
			p.Atomic_word()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1574)
			p.General_function()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1575)
			p.Variable()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1576)
			p.Number()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1577)
			p.Match(tptp_v7_0_0_0ParserDistinct_object)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1578)
			p.Formula_data()
		}

	}

	return localctx
}

// IGeneral_functionContext is an interface to support dynamic dispatch.
type IGeneral_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_functionContext differentiates from other interfaces.
	IsGeneral_functionContext()
}

type General_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_functionContext() *General_functionContext {
	var p = new(General_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_function
	return p
}

func (*General_functionContext) IsGeneral_functionContext() {}

func NewGeneral_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_functionContext {
	var p = new(General_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_function

	return p
}

func (s *General_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *General_functionContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *General_functionContext) General_terms() IGeneral_termsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_termsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_termsContext)
}

func (s *General_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterGeneral_function(s)
	}
}

func (s *General_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitGeneral_function(s)
	}
}

func (p *tptp_v7_0_0_0Parser) General_function() (localctx IGeneral_functionContext) {
	localctx = NewGeneral_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, tptp_v7_0_0_0ParserRULE_general_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1581)
		p.Atomic_word()
	}
	{
		p.SetState(1582)
		p.Match(tptp_v7_0_0_0ParserT__9)
	}
	{
		p.SetState(1583)
		p.General_terms()
	}
	{
		p.SetState(1584)
		p.Match(tptp_v7_0_0_0ParserT__10)
	}

	return localctx
}

// IFormula_dataContext is an interface to support dynamic dispatch.
type IFormula_dataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormula_dataContext differentiates from other interfaces.
	IsFormula_dataContext()
}

type Formula_dataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormula_dataContext() *Formula_dataContext {
	var p = new(Formula_dataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_data
	return p
}

func (*Formula_dataContext) IsFormula_dataContext() {}

func NewFormula_dataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formula_dataContext {
	var p = new(Formula_dataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_formula_data

	return p
}

func (s *Formula_dataContext) GetParser() antlr.Parser { return s.parser }

func (s *Formula_dataContext) Thf_formula() IThf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThf_formulaContext)
}

func (s *Formula_dataContext) Tff_formula() ITff_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITff_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITff_formulaContext)
}

func (s *Formula_dataContext) Fof_formula() IFof_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_formulaContext)
}

func (s *Formula_dataContext) Cnf_formula() ICnf_formulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICnf_formulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICnf_formulaContext)
}

func (s *Formula_dataContext) Fof_term() IFof_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFof_termContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFof_termContext)
}

func (s *Formula_dataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formula_dataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formula_dataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFormula_data(s)
	}
}

func (s *Formula_dataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFormula_data(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Formula_data() (localctx IFormula_dataContext) {
	localctx = NewFormula_dataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, tptp_v7_0_0_0ParserRULE_formula_data)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1606)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__38:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1586)
			p.Match(tptp_v7_0_0_0ParserT__38)
		}
		{
			p.SetState(1587)
			p.Thf_formula()
		}
		{
			p.SetState(1588)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserT__39:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1590)
			p.Match(tptp_v7_0_0_0ParserT__39)
		}
		{
			p.SetState(1591)
			p.Tff_formula()
		}
		{
			p.SetState(1592)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserT__40:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1594)
			p.Match(tptp_v7_0_0_0ParserT__40)
		}
		{
			p.SetState(1595)
			p.Fof_formula()
		}
		{
			p.SetState(1596)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserT__41:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1598)
			p.Match(tptp_v7_0_0_0ParserT__41)
		}
		{
			p.SetState(1599)
			p.Cnf_formula()
		}
		{
			p.SetState(1600)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	case tptp_v7_0_0_0ParserT__42:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1602)
			p.Match(tptp_v7_0_0_0ParserT__42)
		}
		{
			p.SetState(1603)
			p.Fof_term()
		}
		{
			p.SetState(1604)
			p.Match(tptp_v7_0_0_0ParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGeneral_listContext is an interface to support dynamic dispatch.
type IGeneral_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_listContext differentiates from other interfaces.
	IsGeneral_listContext()
}

type General_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_listContext() *General_listContext {
	var p = new(General_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_list
	return p
}

func (*General_listContext) IsGeneral_listContext() {}

func NewGeneral_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_listContext {
	var p = new(General_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_list

	return p
}

func (s *General_listContext) GetParser() antlr.Parser { return s.parser }

func (s *General_listContext) General_terms() IGeneral_termsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_termsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_termsContext)
}

func (s *General_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterGeneral_list(s)
	}
}

func (s *General_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitGeneral_list(s)
	}
}

func (p *tptp_v7_0_0_0Parser) General_list() (localctx IGeneral_listContext) {
	localctx = NewGeneral_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, tptp_v7_0_0_0ParserRULE_general_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1613)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1608)
			p.Match(tptp_v7_0_0_0ParserT__16)
		}

	case tptp_v7_0_0_0ParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1609)
			p.Match(tptp_v7_0_0_0ParserT__11)
		}
		{
			p.SetState(1610)
			p.General_terms()
		}
		{
			p.SetState(1611)
			p.Match(tptp_v7_0_0_0ParserT__12)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGeneral_termsContext is an interface to support dynamic dispatch.
type IGeneral_termsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_termsContext differentiates from other interfaces.
	IsGeneral_termsContext()
}

type General_termsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_termsContext() *General_termsContext {
	var p = new(General_termsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_terms
	return p
}

func (*General_termsContext) IsGeneral_termsContext() {}

func NewGeneral_termsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_termsContext {
	var p = new(General_termsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_general_terms

	return p
}

func (s *General_termsContext) GetParser() antlr.Parser { return s.parser }

func (s *General_termsContext) AllGeneral_term() []IGeneral_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeneral_termContext)(nil)).Elem())
	var tst = make([]IGeneral_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeneral_termContext)
		}
	}

	return tst
}

func (s *General_termsContext) General_term(i int) IGeneral_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeneral_termContext)
}

func (s *General_termsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_termsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_termsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterGeneral_terms(s)
	}
}

func (s *General_termsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitGeneral_terms(s)
	}
}

func (p *tptp_v7_0_0_0Parser) General_terms() (localctx IGeneral_termsContext) {
	localctx = NewGeneral_termsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, tptp_v7_0_0_0ParserRULE_general_terms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.General_term()
	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == tptp_v7_0_0_0ParserT__1 {
		{
			p.SetState(1616)
			p.Match(tptp_v7_0_0_0ParserT__1)
		}
		{
			p.SetState(1617)
			p.General_term()
		}

		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Atomic_word() IAtomic_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomic_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomic_wordContext)
}

func (s *NameContext) Integer() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInteger, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitName(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, tptp_v7_0_0_0ParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1625)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case tptp_v7_0_0_0ParserLower_word, tptp_v7_0_0_0ParserSingle_quoted:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1623)
			p.Atomic_word()
		}

	case tptp_v7_0_0_0ParserInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1624)
			p.Match(tptp_v7_0_0_0ParserInteger)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomic_wordContext is an interface to support dynamic dispatch.
type IAtomic_wordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomic_wordContext differentiates from other interfaces.
	IsAtomic_wordContext()
}

type Atomic_wordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomic_wordContext() *Atomic_wordContext {
	var p = new(Atomic_wordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atomic_word
	return p
}

func (*Atomic_wordContext) IsAtomic_wordContext() {}

func NewAtomic_wordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atomic_wordContext {
	var p = new(Atomic_wordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atomic_word

	return p
}

func (s *Atomic_wordContext) GetParser() antlr.Parser { return s.parser }

func (s *Atomic_wordContext) Lower_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserLower_word, 0)
}

func (s *Atomic_wordContext) Single_quoted() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserSingle_quoted, 0)
}

func (s *Atomic_wordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atomic_wordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atomic_wordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAtomic_word(s)
	}
}

func (s *Atomic_wordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAtomic_word(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Atomic_word() (localctx IAtomic_wordContext) {
	localctx = NewAtomic_wordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, tptp_v7_0_0_0ParserRULE_atomic_word)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		_la = p.GetTokenStream().LA(1)

		if !(_la == tptp_v7_0_0_0ParserLower_word || _la == tptp_v7_0_0_0ParserSingle_quoted) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAtomic_defined_wordContext is an interface to support dynamic dispatch.
type IAtomic_defined_wordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomic_defined_wordContext differentiates from other interfaces.
	IsAtomic_defined_wordContext()
}

type Atomic_defined_wordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomic_defined_wordContext() *Atomic_defined_wordContext {
	var p = new(Atomic_defined_wordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atomic_defined_word
	return p
}

func (*Atomic_defined_wordContext) IsAtomic_defined_wordContext() {}

func NewAtomic_defined_wordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atomic_defined_wordContext {
	var p = new(Atomic_defined_wordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atomic_defined_word

	return p
}

func (s *Atomic_defined_wordContext) GetParser() antlr.Parser { return s.parser }

func (s *Atomic_defined_wordContext) Dollar_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDollar_word, 0)
}

func (s *Atomic_defined_wordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atomic_defined_wordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atomic_defined_wordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAtomic_defined_word(s)
	}
}

func (s *Atomic_defined_wordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAtomic_defined_word(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Atomic_defined_word() (localctx IAtomic_defined_wordContext) {
	localctx = NewAtomic_defined_wordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, tptp_v7_0_0_0ParserRULE_atomic_defined_word)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1629)
		p.Match(tptp_v7_0_0_0ParserDollar_word)
	}

	return localctx
}

// IAtomic_system_wordContext is an interface to support dynamic dispatch.
type IAtomic_system_wordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomic_system_wordContext differentiates from other interfaces.
	IsAtomic_system_wordContext()
}

type Atomic_system_wordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomic_system_wordContext() *Atomic_system_wordContext {
	var p = new(Atomic_system_wordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atomic_system_word
	return p
}

func (*Atomic_system_wordContext) IsAtomic_system_wordContext() {}

func NewAtomic_system_wordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atomic_system_wordContext {
	var p = new(Atomic_system_wordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_atomic_system_word

	return p
}

func (s *Atomic_system_wordContext) GetParser() antlr.Parser { return s.parser }

func (s *Atomic_system_wordContext) Dollar_dollar_word() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserDollar_dollar_word, 0)
}

func (s *Atomic_system_wordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atomic_system_wordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atomic_system_wordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterAtomic_system_word(s)
	}
}

func (s *Atomic_system_wordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitAtomic_system_word(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Atomic_system_word() (localctx IAtomic_system_wordContext) {
	localctx = NewAtomic_system_wordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, tptp_v7_0_0_0ParserRULE_atomic_system_word)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1631)
		p.Match(tptp_v7_0_0_0ParserDollar_dollar_word)
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserInteger, 0)
}

func (s *NumberContext) Rational() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserRational, 0)
}

func (s *NumberContext) Real() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserReal, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *tptp_v7_0_0_0Parser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, tptp_v7_0_0_0ParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1633)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(tptp_v7_0_0_0ParserReal-74))|(1<<(tptp_v7_0_0_0ParserRational-74))|(1<<(tptp_v7_0_0_0ParserInteger-74)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFile_nameContext is an interface to support dynamic dispatch.
type IFile_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_nameContext differentiates from other interfaces.
	IsFile_nameContext()
}

type File_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_nameContext() *File_nameContext {
	var p = new(File_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_file_name
	return p
}

func (*File_nameContext) IsFile_nameContext() {}

func NewFile_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_nameContext {
	var p = new(File_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = tptp_v7_0_0_0ParserRULE_file_name

	return p
}

func (s *File_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_nameContext) Single_quoted() antlr.TerminalNode {
	return s.GetToken(tptp_v7_0_0_0ParserSingle_quoted, 0)
}

func (s *File_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.EnterFile_name(s)
	}
}

func (s *File_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(tptp_v7_0_0_0Listener); ok {
		listenerT.ExitFile_name(s)
	}
}

func (p *tptp_v7_0_0_0Parser) File_name() (localctx IFile_nameContext) {
	localctx = NewFile_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, tptp_v7_0_0_0ParserRULE_file_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.Match(tptp_v7_0_0_0ParserSingle_quoted)
	}

	return localctx
}

func (p *tptp_v7_0_0_0Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 18:
		var t *Thf_or_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Thf_or_formulaContext)
		}
		return p.Thf_or_formula_Sempred(t, predIndex)

	case 19:
		var t *Thf_and_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Thf_and_formulaContext)
		}
		return p.Thf_and_formula_Sempred(t, predIndex)

	case 20:
		var t *Thf_apply_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Thf_apply_formulaContext)
		}
		return p.Thf_apply_formula_Sempred(t, predIndex)

	case 42:
		var t *Thf_xprod_typeContext = nil
		if localctx != nil {
			t = localctx.(*Thf_xprod_typeContext)
		}
		return p.Thf_xprod_type_Sempred(t, predIndex)

	case 43:
		var t *Thf_union_typeContext = nil
		if localctx != nil {
			t = localctx.(*Thf_union_typeContext)
		}
		return p.Thf_union_type_Sempred(t, predIndex)

	case 54:
		var t *Tff_or_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Tff_or_formulaContext)
		}
		return p.Tff_or_formula_Sempred(t, predIndex)

	case 55:
		var t *Tff_and_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Tff_and_formulaContext)
		}
		return p.Tff_and_formula_Sempred(t, predIndex)

	case 85:
		var t *Tff_xprod_typeContext = nil
		if localctx != nil {
			t = localctx.(*Tff_xprod_typeContext)
		}
		return p.Tff_xprod_type_Sempred(t, predIndex)

	case 94:
		var t *Fof_or_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Fof_or_formulaContext)
		}
		return p.Fof_or_formula_Sempred(t, predIndex)

	case 95:
		var t *Fof_and_formulaContext = nil
		if localctx != nil {
			t = localctx.(*Fof_and_formulaContext)
		}
		return p.Fof_and_formula_Sempred(t, predIndex)

	case 122:
		var t *Cnf_disjunctionContext = nil
		if localctx != nil {
			t = localctx.(*Cnf_disjunctionContext)
		}
		return p.Cnf_disjunction_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_or_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_and_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_apply_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_xprod_type_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Thf_union_type_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_or_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_and_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Tff_xprod_type_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_or_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Fof_and_formula_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *tptp_v7_0_0_0Parser) Cnf_disjunction_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
